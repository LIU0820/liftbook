#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Architecture
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
From our discussion:
\end_layout

\begin_layout Standard
Chapter: Arch: 
\end_layout

\begin_layout Standard
- all the fun in Boot (url rewriting, like the stuff you have) 
\end_layout

\begin_layout Standard
- how lift handles requests (what you have got) 
\end_layout

\begin_layout Standard
- intro to views, snippets and how they relate to dispatch
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to better understand how to use Lift to its fullest potential,
 we're going to dig into the guts a bit to examine how requests are handled.
 We assume that you have a basic understanding of how HTTP and Servlets
 work
\begin_inset Foot
status collapsed

\begin_layout Standard
For a refresher, check here: 
\begin_inset LatexCommand htmlurl
target "http://java.sun.com/developer/onlineTraining/Servlets/Fundamentals/index.html"

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Entry into Lift
\end_layout

\begin_layout Standard
The first step in Lift's request processing is intercepting the HTTP request.
 Originally, Lift used a Servlet instance to process incoming requests.
 This was changed to using a Filter instance
\begin_inset Foot
status open

\begin_layout Standard
\begin_inset LatexCommand htmlurl
target "http://groups.google.com/group/liftweb/browse_thread/thread/b484ea2a13b6f84b/90ba1ef1115055a6"

\end_inset


\end_layout

\end_inset

 because this allows the container to handle any requests that Lift does
 not (in particular, static content).
 The filter really acts as a thin wrapper on top of the existing LiftServlet
 (which still does all of the work), so don't be confused when you look
 at the ScalaDoc and see both classes.
 The main thing to remember is that your web.xml
\begin_inset LatexCommand index
name "web.xml"

\end_inset

 should specify the filter and not the servlet:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "lst:LiftFilter-setup-in-web.xml"

\end_inset

LiftFilter setup in web.xml
\end_layout

\end_inset


\end_layout

\begin_layout Standard

<?xml version="1.0" encoding="ISO-8859-1"?>
\end_layout

\begin_layout Standard

<!DOCTYPE web-app
\end_layout

\begin_layout Standard

PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
\end_layout

\begin_layout Standard

"http://java.sun.com/j2ee/dtds/web-app_2_3.dtd">
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

<web-app>
\end_layout

\begin_layout Standard

  <filter>
\end_layout

\begin_layout Standard

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Standard

    <display-name>Lift Filter</display-name>
\end_layout

\begin_layout Standard

    <description>The Filter that intercepts lift calls</description>
\end_layout

\begin_layout Standard

    <filter-class>net.liftweb.http.LiftFilter</filter-class>
\end_layout

\begin_layout Standard

  </filter>      
\end_layout

\begin_layout Standard

  <filter-mapping>
\end_layout

\begin_layout Standard

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Standard

    <url-pattern>/*</url-pattern>
\end_layout

\begin_layout Standard

  </filter-mapping>
\end_layout

\begin_layout Standard

</web-app>
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A full web.xml example is shown in section 
\begin_inset LatexCommand vref
reference "lst:JPA-web.xml"

\end_inset

.
 In particular, the filter-mapping specifies that the Filter is responsible
 for everything.
 When the filter receives the request, it checks a set of rules to see if
 it can handle it.
 If the request is one that Lift handles, it passes it on to an internal
 LiftServlet instance for processing; otherwise, it chains the request and
 allows the container to handle it.
\end_layout

\begin_layout Section
The Rendering Pipeline
\end_layout

\begin_layout Standard
Now that the request has entered the LiftServlet instance, it's time to
 process it.
 We break this processing up into several basic steps:
\end_layout

\begin_layout Enumerate
URL Rewriting
\end_layout

\begin_layout Enumerate
User-defined dispatch
\end_layout

\begin_layout Enumerate
SiteMap matching and access control (covered in section 
\begin_inset Note Note
status open

\begin_layout Standard
TODO: Cross-ref
\end_layout

\end_inset

)
\end_layout

\begin_layout Enumerate
View or Template dispatch and processing
\end_layout

\begin_layout Standard
A lot more is going on under the hood (Lift is highly customizable) but
 for now this should cover 95% of what you will want to do in a Lift application.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:URL-Rewriting"

\end_inset

URL Rewriting
\begin_inset LatexCommand index
name "Rewriting"

\end_inset


\end_layout

\begin_layout Standard
URL rewriting is a mechanism that allows you to modify the incoming request
 so that it dispatches to a different URL.
 This can be used, among other things, to allow you to
\end_layout

\begin_layout Itemize
Use short URLs so that users don't need to remember a huge link (think tinyurl.co
m)
\end_layout

\begin_layout Itemize
Use portions of the URL to determine how a particular snippet or view responds.
 For example, you could make it so that a user's profile is displayed via
 a URL like 
\family typewriter
http://someplace.com/user/derek
\family default
 instead of having the username sent as part of a query string.
\end_layout

\begin_layout Standard
The mechanism is fairly simple to set up.
 We need to write a function of type 
\family typewriter
PartialFunction[RewriteRequest,RewriteResponse]
\family default
 to determine if and how we want to rewrite particular requests.
 The simplest way to do this is with a match statement which will allow
 us to selectively match on some or all of the request information.
 It is important to understand that the Lift session is not created at the
 point when the rewrite functions run; that means that you generally can't
 set or access properties in the S object.
 RewriteRequest is a case object that contains three items: the parsed path,
 the request type and the original HttpServletRequest
\begin_inset LatexCommand index
name "HttpServletRequest"

\end_inset

 object.
\end_layout

\begin_layout Standard
The parsed path of the request in a ParsePath
\begin_inset LatexCommand index
name "ParsePath"

\end_inset

 case class instance.
 The ParsePath class contains
\end_layout

\begin_layout Enumerate
The parsed path as a List[String]
\end_layout

\begin_layout Enumerate
The suffix of the request (i.e.
 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

, etc)
\end_layout

\begin_layout Enumerate
Whether the path is absolute 
\begin_inset Note Note
status open

\begin_layout Standard
Clarification needed on what this means
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Whether the path ends in a slash (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
The latter three properties are useful only in specific circumstances, but
 the parsed path is what lets us work magic.
 The path of the request is defined as the parts of the URI between the
 context path and the query string.
 The following table shows examples of parsed paths for a Lift application
 under the 
\begin_inset Quotes eld
\end_inset

myapp
\begin_inset Quotes erd
\end_inset

 context path
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
Requested URL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
Parsed Path
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
http://foo.com/myapp/home?test_this=true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
http://foo.com/myapp/user/derek
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

derek
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
http://foo.com/myapp/view/item/14592
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

view
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

item
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

14592
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The RequestType basically maps to the five HTTP methods: GET, POST, HEAD,
 PUT and DELETE.
 These are represented by the corresponding GetRequest, PostRequest, etc
 cases classes, with an UnknownRequest case class to cover anything strange.
\end_layout

\begin_layout Standard
The flexibility of Scala's matching system is what really makes this powerful.
 With matching on Lists in particular, we can match parts of the path and
 capture others.
 For instance, for our second example we'd like to rewrite the 
\begin_inset Quotes eld
\end_inset

/user/<username>
\begin_inset Quotes erd
\end_inset

 path so that it's handled by the 
\begin_inset Quotes eld
\end_inset

/viewUser
\begin_inset Quotes erd
\end_inset

 template
\begin_inset Note Note
status open

\begin_layout Standard
Modify for PocketChange
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
val rewriter = {
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
  case RewriteRequest(ParsePath(
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

 :: username :: Nil, _, _, _), _, _) => 
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
       RewriteResponse(
\begin_inset Quotes eld
\end_inset

viewUser
\begin_inset Quotes erd
\end_inset

 :: Nil, Map(
\begin_inset Quotes eld
\end_inset

username
\begin_inset Quotes erd
\end_inset

 -> username))
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
}
\end_layout

\begin_layout Standard
The RewriteResponse
\begin_inset LatexCommand index
name "RewriteResponse"

\end_inset

 simply contains the new path to send and can also take a Map
\begin_inset LatexCommand index
name "Map"

\end_inset

 that contains parameters that will be accessible via S.param
\begin_inset LatexCommand index
name "S.param"

\end_inset


\begin_inset LatexCommand index
name "S"

\end_inset

 in the snippet or view.
 As we stated before, the LiftSession (and therefore most of S) isn't available
 at this time, so the Map is the only way to pass information on to the
 rewritten location.
 Technically, a rewrite results in a 
\begin_inset Quotes eld
\end_inset

302 Moved Temporarily
\begin_inset Quotes erd
\end_inset

 result code that forwards the client to a new request.
 Because of that, even if you could set data in LiftSession or S it would
 disappear when the redirect occurs.
\end_layout

\begin_layout Standard
We can combine the ParsePath matching with the RequestType and HttpServletReques
t to be very specific with our matches.
 For example, if we wanted to support the DELETE HTTP verb for a RESTful
\begin_inset LatexCommand index
name "RESTful"

\end_inset

 interface through an existing template, we could redirect it like so:
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
val rewriter = {
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
  case RewriteRequest(ParsePath(username :: Nil, _, _, _),
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
                      DeleteRequest,
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
                      httpreq) if isMgmtSubnet(httpreq.getRemoteHost()) =>
 
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
       RewriteResponse(
\begin_inset Quotes eld
\end_inset

deleteUser
\begin_inset Quotes erd
\end_inset

 :: Nil, Map(
\begin_inset Quotes eld
\end_inset

username
\begin_inset Quotes erd
\end_inset

 -> username))
\end_layout

\begin_layout LyX-Code

\series bold
\size footnotesize
}
\end_layout

\begin_layout Standard
We'll go into more detail about how you can use this in the following sections.
 In particular, SiteMap
\begin_inset LatexCommand index
name "SiteMap"

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Standard
Cross-ref
\end_layout

\end_inset

provides a mechanism for doing rewrites combined with menu entries.
\end_layout

\begin_layout Subsection
Custom Dispatch
\begin_inset LatexCommand label
name "sub:Custom-Dispatch"

\end_inset


\end_layout

\begin_layout Standard
Once the rewriting phase is complete (whether we pass through or are redirected)
, the next phase is to determine if there should be a custom dispatch for
 the request.
 A custom dispatch allows you to handle a matching request directly by a
 method instead of going through the template lookup system; because it
 bypasses templating, you're responsible for the full content of the response.
 Typical use cases for this would be a web service
\begin_inset LatexCommand index
name "web service"

\end_inset

 returning XML or a service to return, say, a generated image or PDF.
 In that sense, the custom dispatch mechanism allows you to write your own
 
\begin_inset Quotes eld
\end_inset

sub-servlets
\begin_inset Quotes erd
\end_inset

 without all the mess of implementing the interface and configuring them
 in web.xml
\begin_inset LatexCommand index
name "web.xml"

\end_inset

.
\end_layout

\begin_layout Standard
Custom dispatch is realized, like rewriting, via a partial function.
 In this case, it's a function of type 
\family typewriter
PartialFunction[RequestState, () => Can[LiftResponse]]
\family default
 that will do the work.
 The RequestState is similar to the the RewriteRequest case class; it provides
 the path as a List[String], the suffix, and the RequestType.
 Note that at this point in the request cycle the LiftSession has been initializ
ed, so you have full access to the S object
\begin_inset Note Note
status open

\begin_layout Standard
Confirm this!
\end_layout

\end_inset

.
 The result of the dispatch should be a function that returns a 
\family typewriter
Can[LiftResponse]
\family default
.
 If the function returns 
\family typewriter
Empty
\family default
 then Lift returns a 
\begin_inset Quotes eld
\end_inset

404 not found
\begin_inset Quotes erd
\end_inset

 response.
\end_layout

\begin_layout Standard
As a concrete example, let's look at returning a generated chart image from
 our application
\begin_inset Note Note
status open

\begin_layout Standard
Modify as appropriate for PocketChange
\end_layout

\end_inset

.
 There are several libraries for charting, but we'll take a look at JFreeChart
 in particular.
 First, let's write a method that will chart our account balances by month
 for the last year (full listing shown in section 
\begin_inset Note Note
status open

\begin_layout Standard
TODO: Cross-ref
\end_layout

\end_inset

):
\end_layout

\begin_layout LyX-Code
def chart (endDate : String) : LiftResponse = {
\end_layout

\begin_layout LyX-Code
  // Query, set up chart, etc...
\end_layout

\begin_layout LyX-Code
  val chartImage = ChartUtilities.encodeAsPNG(balanceChart.createBufferedImage(wid
th,height))
\end_layout

\begin_layout LyX-Code
  Full(InMemoryResponse(chartImage, (
\begin_inset Quotes eld
\end_inset

Content-Type
\begin_inset Quotes erd
\end_inset

 -> 
\begin_inset Quotes eld
\end_inset

image/png
\begin_inset Quotes erd
\end_inset

) :: Nil, Nil, 200))
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Once we've set up the chart, we use the ChartUtilities helper class from
 JFreeChart to encode the chart into a PNG byte array.
 We can then use Lift's InMemoryResponse
\begin_inset LatexCommand index
name "InMemoryResponse"

\end_inset

 to pass the encoded data back to the client with the appropriate Content-Type
\begin_inset LatexCommand index
name "Type"

\end_inset

 header.
 Now we just need to hook the request into the dispatch table from the Boot
 class:
\end_layout

\begin_layout LyX-Code
LiftRules.addDispatchBefore {
\end_layout

\begin_layout LyX-Code
  case RequestState(
\begin_inset Quotes eld
\end_inset

chart
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

balances
\begin_inset Quotes erd
\end_inset

 :: endDate :: Nil, _, _) =>
\end_layout

\begin_layout LyX-Code
    Charting.chart(endDate)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
As you can see, we capture the endDate parameter from the path and pass
 it into our chart method.
 This means we can use a URL like 
\family typewriter
http://foo.com/chart/balances/20080401
\family default
 to obtain the image.
 Since the dispatch function has an associated lift session, we can also
 use the S.param method to get query string parameters, in case we wanted
 to allow someone to send an optional width and height:
\end_layout

\begin_layout LyX-Code
val width = S.param(
\begin_inset Quotes eld
\end_inset

width
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 400
\end_layout

\begin_layout LyX-Code
val height = S.param(
\begin_inset Quotes eld
\end_inset

height
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 300
\end_layout

\begin_layout Standard
There are a number of other ListResponse subclasses to cover your needs,
 including responses for XHTML, XML, Atom, Javascript, CSS, and JSON
\begin_inset Note Note
status open

\begin_layout Standard
Should I give more examples?
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
View Processing
\begin_inset LatexCommand label
name "sub:View-Processing"

\end_inset


\end_layout

\begin_layout Standard
Views
\begin_inset LatexCommand index
name "Views"

\end_inset

 are essentially implicitly defined custom dispatch methods, very similar
 to what we just covered in section 
\begin_inset LatexCommand ref
reference "sub:Custom-Dispatch"

\end_inset

.
 A view is a normal Scala method that returns a NodeSeq
\begin_inset LatexCommand index
name "NodeSeq"

\end_inset

; the main difference is that with custom dispatch we explicitly define
 the path that will lead to the method via LiftRules, whereas in a view,
 the class itself defines the path.
 In either case, View lookup and dispatch is done after template resolution
 (to be covered later), so templates take priority
\begin_inset Note Note
status open

\begin_layout Standard
TODO: Confirm this!
\end_layout

\end_inset

.
 There are two options for implementing a view class: one is to extend the
 LiftView
\begin_inset LatexCommand index
name "LiftView"

\end_inset

 trait, the other is to implement the InsecureLiftView
\begin_inset LatexCommand index
name "InsecureLiftView"

\end_inset

 trait.
 As you may be able to tell from the names, we would prefer that you use
 the LiftView trait.
 The InsecureLiftView determines method dispatch by turning a request path
 into a class and method name.
 For instance, if we have a path 
\family typewriter
/MyStuff/enumerate
\family default
, then Lift will look for a class called 
\family typewriter
MyStuff
\family default
 in the view subpackage 
\begin_inset Note Note
status collapsed

\begin_layout Standard
Where to cross-ref for class resolution, LiftRules.addToPackages
\end_layout

\end_inset

 and if it finds it and it has a method called 
\family typewriter
enumerate
\family default
, then Lift will execute the method and return its results to the user.
 The main issue there is that Lift uses reflection
\begin_inset LatexCommand index
name "reflection"

\end_inset

 to get the method, so it can access any method in the class, even ones
 marked private.
 A better way to do it is to use the LiftView trait, which defines a dispatch
 partial function.
 This dispatch function maps a string (the 
\begin_inset Quotes eld
\end_inset

method name
\begin_inset Quotes erd
\end_inset

) to a function that will return a NodeSeq.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

 shows a custom LiftView class where the path 
\family typewriter
/MyView/enumerate
\family default
 will map to the MyView.doEnumerate method.
 If someone attempts to go to 
\family typewriter
/MyView/privateMethod
\family default
 they'll get a 404 since it's not defined in the dispatch function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This should be a pocketchange example
\end_layout

\end_inset

Dispatch in LiftView
\begin_inset LatexCommand label
name "lst:Dispatch-in-LiftView"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class MyView extends LiftView {
\end_layout

\begin_layout Standard

  override def dispatch = {
\end_layout

\begin_layout Standard

    case "enumerate" => doEnumerate _
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  def doEnumerate () : NodeSeq = {  
\end_layout

\begin_layout Standard

    ...
\end_layout

\begin_layout Standard

    <lift:surround with="default" at="content">
\end_layout

\begin_layout Standard

     { itemList.toTable }
\end_layout

\begin_layout Standard

    </lift:surround>
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another difference between custom dispatch and Views is that the NodeSeq
 returned from the view method is processed for template tags including
 surrounds and includes 
\begin_inset Note Note
status open

\begin_layout Standard
Confirm this!
\end_layout

\end_inset

, just like snippets.
 That means that you can use the full power of the templating system from
 within your View, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

's doEnumerate method.
\end_layout

\begin_layout Subsection
Template Processing
\end_layout

\begin_layout Standard
Templates form the backbone of Lift's flexibility and power.
\end_layout

\begin_layout Subsection
Displaying Messages to the User
\end_layout

\begin_layout Subsection
Template Tags
\end_layout

\begin_layout Subsection
SHtml Generator Methods
\end_layout

\begin_layout Section
To Be Written
\end_layout

\begin_layout Itemize
SiteMap matching and access control - New Loc/Menu stuff
\end_layout

\begin_layout Itemize
template or view matched? 
\end_layout

\begin_layout Itemize
recursive processing of template and any snippets contained therein 
\end_layout

\begin_layout Itemize
direct processing of view 
\end_layout

\begin_layout Itemize
LiftViewFirst - http://wiki.liftweb.net/index.php/Lift_View_First
\end_layout

\begin_layout Itemize
Error handling - Msgs and handling exceptions
\end_layout

\begin_layout Itemize
List of tags that are handled by Lift (stolen from http://liftweb.net/index.php/Li
ftTags, not sure how up-to-date this is) 
\end_layout

\begin_deeper
\begin_layout Itemize
surround 
\end_layout

\begin_layout Itemize
embed 
\end_layout

\begin_layout Itemize
comet 
\end_layout

\begin_layout Itemize
ignore 
\end_layout

\begin_layout Itemize
snippet (and, the alternative lift:<class>.<method>) 
\end_layout

\begin_layout Itemize
additional attribute handling in tags (via S.attr)
\end_layout

\end_deeper
\begin_layout Itemize
The SHtml object is used to create most of the input elements.
\end_layout

\begin_deeper
\begin_layout Description
ajaxButton An <input type=
\begin_inset Quotes erd
\end_inset

button
\begin_inset Quotes erd
\end_inset

> with onClick connected to an AjaxCall
\end_layout

\begin_layout Description
a An <a> tag with a function associated with it
\end_layout

\begin_layout Description
span A <span> with onClick connected to a JsCmd.
\end_layout

\begin_layout Description
toggleKids 
\end_layout

\begin_layout Description
ajaxCheckbox An <input type=
\begin_inset Quotes erd
\end_inset

checkbox
\begin_inset Quotes erd
\end_inset

> with onClick connected to an AjaxCall
\end_layout

\begin_layout Description
ajaxSelect 
\end_layout

\begin_layout Description
select A <select>
\end_layout

\begin_layout Description
text An <input type=
\begin_inset Quotes erd
\end_inset

text
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Description
ajaxText 
\end_layout

\begin_layout Description
textarea A <textarea>
\end_layout

\begin_layout Description
link Create an anchor tag around a body Xhtml fragment.
\end_layout

\begin_layout Description
select A <select> tag
\end_layout

\begin_layout Description
untrustedSelect A <select> tag that has no test to see whether or not the
 value was in the list.
 This is commonly used for dynamic select lists.
\end_layout

\begin_layout Description
multiselect A <select multiple=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Description
fileholder An <input type=
\begin_inset Quotes erd
\end_inset

file
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Description
radio An <input type=
\begin_inset Quotes erd
\end_inset

radio
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Description
submit An <input type=
\begin_inset Quotes erd
\end_inset

submit
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Description
hidden A hidden form element
\end_layout

\begin_layout Description
password An <input type=
\begin_inset Quotes erd
\end_inset

password
\begin_inset Quotes erd
\end_inset

> 
\end_layout

\end_body
\end_document
