#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Fundamentals
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-Architecture"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we will cover some of the fundamental aspects of writing
 a lift application, including the architecture of the Lift library and
 how it processes requests.
 We will cover the rendering pipeline in detail, and show you how you can
 add your own code to be a part of that processing.
 
\end_layout

\begin_layout Section
Entry into Lift
\begin_inset CommandInset label
LatexCommand label
name "sec:Entry-into-Lift"

\end_inset


\end_layout

\begin_layout Standard
The first step in Lift's request processing is intercepting the HTTP request.
 Originally, Lift used a Servlet instance to process incoming requests.
 This was changed to use a Filter instance
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://groups.google.com/group/liftweb/browse_thread/thread/b484ea2a13b6f84b/90ba1
ef1115055a6
\end_layout

\end_inset


\end_layout

\end_inset

 because this allows the container to handle any requests that Lift does
 not (in particular, static content).
 The filter acts as a thin wrapper on top of the existing LiftServlet (which
 still does all of the work), so don't be confused when you look at the
 ScalaDoc and see both classes.
 The main thing to remember is that your web.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web.xml
\end_layout

\end_inset

 should specify the filter and not the servlet, as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:LiftFilter-setup-in-web.xml"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:LiftFilter-setup-in-web.xml"

\end_inset

LiftFilter setup in web.xml
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="ISO-8859-1"?>
\end_layout

\begin_layout Plain Layout

<!DOCTYPE web-app
\end_layout

\begin_layout Plain Layout

PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
\end_layout

\begin_layout Plain Layout

"http://java.sun.com/j2ee/dtds/web-app_2_3.dtd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<web-app>
\end_layout

\begin_layout Plain Layout

  <filter>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <display-name>Lift Filter</display-name>
\end_layout

\begin_layout Plain Layout

    <description>The Filter that intercepts lift calls</description>
\end_layout

\begin_layout Plain Layout

    <filter-class>net.liftweb.http.LiftFilter</filter-class>
\end_layout

\begin_layout Plain Layout

  </filter>      
\end_layout

\begin_layout Plain Layout

  <filter-mapping>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <url-pattern>/*</url-pattern>
\end_layout

\begin_layout Plain Layout

  </filter-mapping>
\end_layout

\begin_layout Plain Layout

</web-app>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A full web.xml example is shown in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:JPA-web.xml"

\end_inset

.
 In particular, the filter-mapping (lines 13-16) specifies that the Filter
 is responsible for everything.
 When the filter receives the request, it checks a set of rules to see if
 it can handle it.
 If the request is one that Lift handles, it passes it on to an internal
 LiftServlet instance for processing; otherwise, it chains the request and
 allows the container to handle it.
\end_layout

\begin_layout Section
Bootstrap
\begin_inset CommandInset label
LatexCommand label
name "sec:Bootstrap"

\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
Bootstrap
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When Lift starts up there are a number of things that you'll want to set
 up before any requests are processed.
 These things include setting up a SiteMap (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

), URL rewriting, custom dispatch, and classpath search.
 The Lift servlet looks for the bootstrap.liftweb.Boot
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Boot
\end_layout

\end_inset

 class and executes the boot method in the class.
 You can also specify your own Boot instance by using the 
\family typewriter
bootloader
\begin_inset Index
status open

\begin_layout Plain Layout

\family typewriter
bootloader
\end_layout

\end_inset


\family default
 context param as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Overriding-bootloader"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Overriding the Boot loader class
\begin_inset CommandInset label
LatexCommand label
name "lst:Overriding-bootloader"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

  <context-param>     
\end_layout

\begin_layout Plain Layout

	<param-name>bootloader</param-name>
\end_layout

\begin_layout Plain Layout

    <param-value>foo.bar.baz.MyBoot</param-value>
\end_layout

\begin_layout Plain Layout

  </context-param> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Your MyBoot class must subclass Bootable
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.Bootable
\end_layout

\end_inset

 and implement the 
\family typewriter
boot
\family default
 method.
 The boot method will only be run once, so you can place any initialization
 calls for other libraries here as well.
\end_layout

\begin_layout Subsection
A Note on LiftRules
\end_layout

\begin_layout Standard
Most of your configuration in your Boot class will be done via the LiftRules
\begin_inset Index
status open

\begin_layout Plain Layout
LiftRules
\end_layout

\end_inset

 object; LiftRules serves as a common location for almost everything configurabl
e about Lift.
 Because LiftRules spans such a diverse range of functionality, we're not
 going to cover it directly; rather, we will mention it as we cover each
 of the aspects that it controls.
\end_layout

\begin_layout Subsection
Class Resolution
\begin_inset CommandInset label
LatexCommand label
name "sub:Class-Resolution"

\end_inset


\end_layout

\begin_layout Standard
As part of our discussion of the Boot class, it's also important to cover
 a small detail of how Lift determines where to find classes for Views and
 Snippet rendering.
 The 
\family typewriter
LiftRules.addToPackages
\family default
 method tells lift what Scala packages to look in for a given class.
 Lift has implicit extensions to the paths you enter; in particular, if
 you tell Lift to use the 
\family typewriter
com.pocketchangeapp
\family default
 package, Lift will look for View classes under 
\family typewriter
com.pocketchangeapp.view
\family default
 and will look for Snippet classes under 
\family typewriter
com.pocketchangeapp.snippet
\family default
.
 The 
\family typewriter
addToPackages
\family default
 method should almost always be executed in your Boot class.
 A minimal Boot class would look like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Minimal Boot class
\begin_inset CommandInset label
LatexCommand label
name "lst:Minimal-Boot-class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    LiftRules.addToPackages("com.pocketchangeapp")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Rendering Process
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Rendering-Process"

\end_inset


\end_layout

\begin_layout Standard
Before we move on, we want to give a brief overview of the processes involved
 when Lift transforms a request into a response (AKA the rendering pipeline
\begin_inset Index
status open

\begin_layout Plain Layout
rendering pipeline
\end_layout

\end_inset

).
 We're only going to touch on the major points here; a much more detailed
 tour of the pipeline is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

.
 The steps that we'll cover in this chapter are:
\end_layout

\begin_layout Enumerate
Perform any URL rewriting.
 This is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:URL-Rewriting"

\end_inset


\end_layout

\begin_layout Enumerate
Execute any matching custom dispatch functions.
 This is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset


\end_layout

\begin_layout Enumerate
Check to see if the request should be handled by a View.
 This is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Views"

\end_inset


\end_layout

\begin_layout Enumerate
If the request is not handled by a View, find a template that matches and
 use it.
 We'll cover templates in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Templates"

\end_inset


\end_layout

\begin_layout Standard
In our experience Views and Templates will cover most of your needs, but
 as we'll demonstrate in later chapters, Lift has plenty of ways to customize
 the request handling.
\end_layout

\begin_layout Section
Templates
\begin_inset CommandInset label
LatexCommand label
name "sec:Templates"

\end_inset


\end_layout

\begin_layout Standard
Templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Templates
\end_layout

\end_inset

 form the backbone of Lift's flexibility and power.
 A template is essentially an XML file that contains Lift-specific tags
 as well as whatever content you want returned to the user.
 There are a number of built-in XML tags that Lift uses for specific reasons,
 these are of the form 
\family typewriter
<lift:name/>
\family default
.
 Lift also allows you to create your own tags, which are called 
\emph on
snippets
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
snippets
\end_layout

\end_inset

 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

).
 These user-defined tags are linked directly to Scala methods and these
 methods can process the XML contents of the snippet tag, or can generate
 their own content from scratch.
 A simple template is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Sample template
\begin_inset CommandInset label
LatexCommand label
name "lst:Sample-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <head><title>Hello!</title></head>
\end_layout

\begin_layout Plain Layout

  <lift:Hello.world />
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the tags that are of the form 
\family typewriter
<lift:name>
\family default
 which in this case are 
\family typewriter
<lift:surround>
\family default
 and 
\family typewriter
<lift:snippet>.
 
\family default
These are two examples of Lift-specific tags.
 We'll discuss all of the tags that users will use in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ArchTags"

\end_inset

, but let's discuss the two contained here.
 We use the built-in 
\family typewriter
<lift:surround>
\begin_inset Index
status collapsed

\begin_layout Plain Layout
lift:surround
\end_layout

\end_inset


\family default
 tag (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:surround-tag"

\end_inset

) to make Lift embed our current template inside the 
\begin_inset Quotes eld
\end_inset


\family typewriter
default
\family default

\begin_inset Quotes erd
\end_inset

 template.
 We also use 
\family typewriter
<lift:snippet>
\family default
 tag (aliased to Hello.world) to execute a snippet that we defined.
 In this case we execute the method 
\family typewriter
world
\family default
 in the class 
\family typewriter
Hello 
\family default
to generate some content.
 
\end_layout

\begin_layout Standard
During template processing, Lift tries to locate a file in the WAR tree
 that matches the request.
 Lift tries several suffixes (html, xhtml, htm, and no suffix) and also
 tries to match based on the client's Accept-Language header.
 The pattern Lift uses is
\end_layout

\begin_layout LyX-Code
<path to template>[_<language, optional>][.<suffix>]
\end_layout

\begin_layout Standard
Because Lift will implicitly search for suffixes, it's best to leave the
 suffix off of your links within the web app.
 If you have a link with an href of 
\family typewriter
/test/template.xhtml
\family default
, it will only match that file, but if you use 
\family typewriter
/test/template
\family default
 for the href and you have the following templates in your web app:
\end_layout

\begin_layout Itemize

\family typewriter
/test/template.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_es-ES.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_ja.xhtml
\end_layout

\begin_layout Standard
then Lift will use the appropriate template based on the user's requested
 language if a corresponding template is available.
 In addition to normal templates, your application can make use of hidden
 templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
hidden templates
\end_layout

\end_inset

.
 These are templates that are located under the 
\family typewriter
/templates-hidden
\family default
 directory of your web app; technically, Lift hides files in any directory
 ending in 
\begin_inset Quotes eld
\end_inset

-hidden
\begin_inset Quotes erd
\end_inset

, but templates-hidden is somewhat of a de facto standard.
 Like the 
\family typewriter
WEB-XML
\family default
 directory, the contents cannot be directly requested by clients.
 They can, however, be used by other templates through mechanisms like the
 
\family typewriter
<lift:surround>
\family default
 and 
\family typewriter
<lift:embed>
\family default
 tags (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:embed-tag"

\end_inset

).
 If Lift cannot locate an appropriate template based on the request path
 then it will return a 404 to the user.
\end_layout

\begin_layout Standard
Once Lift has located the correct template, the next step is to process
 the contents.
 It is important to understand that Lift processes XML tags from the outside
 in.
 That means that in our example listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, the surround tag gets processed first.
 In this case the surround loads the default template and embeds our content
 at the appropriate location.
 The next tag to be processed is the 
\family typewriter
<lift:Hello.world/>
\family default
 snippet.
 This tag is essentially an alias for the lift:snippet tag (specifically,
 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello:world
\begin_inset Quotes erd
\end_inset

>
\family default
) , and will locate the Hello class and execute the world method on it.
 If you omit the 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

 part of the type and only specify the class (
\family typewriter
<lift:Hello>
\family default
 or 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

>
\family default
) then Lift will attempt to call the 
\family typewriter
render
\family default
 method of the class.
\end_layout

\begin_layout Standard
As you can see, templates are a nice way of setting up your layout and then
 writing a few methods to fill in the XML fragments that make up your web
 applications.
 They provide a simple way to generate a uniform look for your site, particularl
y if you composite your templates using the surround and embed tags.
 If you'd like more control or don't need a template for a certain section,
 you'll want to use a View, which is coming up in the next section.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center

\series medium
\begin_inset Box Shadowbox
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size small
If you inspect the API documentation closely, you might be tempted to manually
 load a template (from a snippet for example) using 
\family typewriter
LiftSession.processSurroundAndInclude
\family default
.
 Even though Lift will merge your templates and invoke snippets if you use
 this method, we 
\emph on
strongly
\emph default
 recommend against this technique.
 The basic issue is that Lift's function mappings are not properly updated
 because you're running this method 
\emph on
outside
\emph default
 of the normal rendering pipeline.
 That means that whatever callbacks you have in the page you'd like to return
 won't get called when the page is submitted.
 In general, we've never found a case where we required this functionality;
 usually you can accomplish the same thing by using a RedirectResponse and
 attaching your state to it via the Map parameter.
 For more details, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Views
\begin_inset CommandInset label
LatexCommand label
name "sec:Views"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Convert examples to PocketChange...
 aka, work on PocketChange :)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We just discussed Templates and saw that through a combination of an XML
 file, Lift tags, and Scala code we can respond to requests made by a user.
 You can also generate those responses entirely in code by using Views.
 
\end_layout

\begin_layout Standard
Views
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Views
\end_layout

\end_inset

 are implicitly defined custom dispatch methods; we'll cover explicit custom
 dispatch in more depth in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

.
 A view is a normal Scala method that returns a NodeSeq
\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

; the main difference is that with custom dispatch we explicitly define
 the path that will lead to the method via LiftRules, whereas in a view,
 the class itself defines the path.
 In either case, View lookup and dispatch is done after template resolution,
 so templates take priority.
 
\end_layout

\begin_layout Standard
There are two options for implementing a view class: one is to extend the
 LiftView
\begin_inset Index
status collapsed

\begin_layout Plain Layout
LiftView
\end_layout

\end_inset

 trait, the other is to implement the InsecureLiftView
\begin_inset Index
status collapsed

\begin_layout Plain Layout
InsecureLiftView
\end_layout

\end_inset

 trait.
 As you may be able to tell from the names, we would prefer that you use
 the LiftView trait.
 The InsecureLiftView determines method dispatch by turning a request path
 into a class and method name.
 For instance, if we have a path 
\family typewriter
/MyStuff/enumerate
\family default
, then Lift will look for a class called 
\family typewriter
MyStuff
\family default
 in the view subpackage (class resolution is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Class-Resolution"

\end_inset

) and if it finds it and it has a method called 
\family typewriter
enumerate
\family default
, then Lift will execute the method and return its results to the user.
 The main issue there is that Lift uses reflection
\begin_inset Index
status collapsed

\begin_layout Plain Layout
reflection
\end_layout

\end_inset

 to get the method, so it can access any method in the class, 
\emph on
even ones marked private
\emph default
.
 A better way to do it is to use the LiftView trait, which defines a dispatch
 partial function.
 This dispatch function maps a string (the 
\begin_inset Quotes eld
\end_inset

method name
\begin_inset Quotes erd
\end_inset

) to a function that will return a NodeSeq.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

 shows a custom LiftView class where the path 
\family typewriter
/ExpenseView/enumerate
\family default
 will map to the ExpenseView.doEnumerate method.
 If someone attempts to go to 
\family typewriter
/ExpenseView/privateMethod
\family default
 they'll get a 404 since it's not defined in the dispatch function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This should be a pocketchange example
\end_layout

\end_inset

Dispatch in LiftView
\begin_inset CommandInset label
LatexCommand label
name "lst:Dispatch-in-LiftView"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class ExpenseView extends LiftView {
\end_layout

\begin_layout Plain Layout

  override def dispatch = {
\end_layout

\begin_layout Plain Layout

    case "enumerate" => doEnumerate _
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def doEnumerate () : NodeSeq = {  
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    <lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

     { expenseItems.toTable }
\end_layout

\begin_layout Plain Layout

    </lift:surround>
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another difference between custom dispatch and Views is that the NodeSeq
 returned from the view method is processed for template tags including
 
\family typewriter
surrounds
\family default
 and 
\family typewriter
includes
\family default
, just like snippets; dispatch methods, on the other hand, expect a LiftResponse.
 That means that you can use the full power of the templating system from
 within your View, as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

's 
\family typewriter
doEnumerate
\family default
 method.
\end_layout

\begin_layout Standard
Since you can choose to not include any of the pre-defined template XHTML,
 you can easily generate any XML-based content such as Atom or RSS feeds
 using a View.
\end_layout

\begin_layout Section
Tags
\begin_inset CommandInset label
LatexCommand label
name "sec:ArchTags"

\end_inset


\end_layout

\begin_layout Standard
In the earlier sections on Templates and Views we briefly touched on some
 of Lift's built-in tags, namely 
\family typewriter
snippet
\family default
 and 
\family typewriter
surround
\family default
.
 In this section we'll go into more detail on those tags as well as cover
 the rest of Lift's tags.
\end_layout

\begin_layout Subsection
snippet
\begin_inset CommandInset label
LatexCommand label
name "sub:snippet-tag"

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
Usage: <lift:snippet form="GET/POST" type="Class:method" 
\end_layout

\begin_layout LyX-Code

\family typewriter
           multipart="true/false" />
\end_layout

\begin_layout LyX-Code
       <lift:Class.method form=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 multipart=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout LyX-Code
       <lift:Class form=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 multipart=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Standard
The snippet tag is the workhorse of Lift.
 In our experience, most of the functionality of your web apps will be handled
 via snippets.
 They're so important that we're going to cover their mechanism separately
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

.
 In this section, however, we'll cover the specifics of the snippet tag.
\end_layout

\begin_layout Standard
The most important part of the tag is the class and method definition.
 There are three ways to specify this:
\end_layout

\begin_layout Enumerate
Via the type attribute.
 The value should be 
\begin_inset Quotes eld
\end_inset


\family typewriter
ClassName
\family default
:
\family typewriter
method
\family default

\begin_inset Quotes erd
\end_inset

 for the particular snippet method you want to have handle the tag
\end_layout

\begin_layout Enumerate
Via a tag suffix of 
\family typewriter
Class.method
\family default
.
 This is the same as specifying the type=
\begin_inset Quotes erd
\end_inset

Class:method
\begin_inset Quotes erd
\end_inset

 attribute
\end_layout

\begin_layout Enumerate
Via a tag suffix of just 
\family typewriter
Class
\family default
.
 This will use the 
\family typewriter
render
\family default
 method on the specified class to handle the tag
\end_layout

\begin_layout Standard
Classes are resolved as specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Class-Resolution"

\end_inset

.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Snippet-tag-equivalence"

\end_inset

 shows three equivalent snippet tags.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet tag equivalence
\begin_inset CommandInset label
LatexCommand label
name "lst:Snippet-tag-equivalence"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:snippet type=
\begin_inset Quotes erd
\end_inset

MyClass:render
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Plain Layout

<lift:MyClass.render />
\end_layout

\begin_layout Plain Layout

<lift:MyClass />
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
form
\family default
 and 
\family typewriter
multipart
\family default
 attributes are optional.
 If 
\family typewriter
form
\family default
 is included then an appropriate form tag will be emitted into the XHTML
 using the specified submission method
\family typewriter
.
 
\family default
The 
\family typewriter
multipart
\family default
 attribute is a boolean, and specifies whether a generated form tag should
 be set to use multipart form submission; this is most typically used for
 file uploads (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:File-Uploads"

\end_inset

).
\end_layout

\begin_layout Subsection
surround
\begin_inset CommandInset label
LatexCommand label
name "sub:surround-tag"

\end_inset


\end_layout

\begin_layout LyX-Code
Usage:
\family typewriter
 <lift:surround with="template_name" at=
\begin_inset Quotes erd
\end_inset

binding
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\family typewriter
         children
\end_layout

\begin_layout LyX-Code

\family typewriter
       </lift:surround>
\end_layout

\begin_layout Standard
Surrounds the child nodes with the named template; the child nodes are inserted
 into the named template at the binding point specified by the 
\begin_inset Quotes eld
\end_inset

at
\begin_inset Quotes erd
\end_inset

 parameter (we'll cover the bind tag in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:bind-tag"

\end_inset

) Typically templates that will be used to surround other templates are
 incomplete by themselves, so we usually store them in the 
\family typewriter
<app
\begin_inset space ~
\end_inset

root>/templates-hidden
\family default
 subdirectory so that they can't be accessed directly.
 Having said that, it's not required that the templates be in any specific
 location (except for WEB-INF, obviously).
 The most common usage of surround is so that you can use a 
\begin_inset Quotes eld
\end_inset

master
\begin_inset Quotes erd
\end_inset

 template for your site CSS, menu, etc.
 An example use of surround is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Surrounding-your-page"

\end_inset

.
 We'll show the counterpart master template in the section on the bind tag.
 One more note is that the surrounding template name can either be a fully-quali
fied path (i.e.
 
\begin_inset Quotes eld
\end_inset

/templates-hidden/default
\begin_inset Quotes erd
\end_inset

), or can just be the base filename (
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

).
 In the latter case Lift will search all subdirectories of the app root
 for the template.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Surrounding your page
\begin_inset CommandInset label
LatexCommand label
name "lst:Surrounding-your-page"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at=
\begin_inset Quotes erd
\end_inset

content
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

  <p>Welcome to PocketChange!</p>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that you can use multiple surround templates for different functionality,
 and surrounds can be nested.
 For example, you might want to have a separate template for your administrative
 pages that adds a menu to your default template.
 In that case, your admin.html could look like listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Adding-an-Admin-menu"

\end_inset

.
 As you can see, we've named our bind in the admin template to also be 
\begin_inset Quotes eld
\end_inset

content
\begin_inset Quotes erd
\end_inset

 so that we keep things consistent for the rest of our templates.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Adding an Admin Menu
\begin_inset CommandInset label
LatexCommand label
name "lst:Adding-an-Admin-menu"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with=
\begin_inset Quotes erd
\end_inset

default
\begin_inset Quotes erd
\end_inset

 at=
\begin_inset Quotes erd
\end_inset

content
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

  <lift:Admin.menu />
\end_layout

\begin_layout Plain Layout

  <lift:bind name=
\begin_inset Quotes erd
\end_inset

content
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size small
You cannot have a hidden template with the same name as a sub-directory
 of your webapp directory.
 For example, if you had an admin.html template in /templates-hidden, you
 could not also have an admin directory.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
bind
\begin_inset CommandInset label
LatexCommand label
name "sub:bind-tag"

\end_inset


\end_layout

\begin_layout LyX-Code
Usage: <lift:bind name=
\begin_inset Quotes erd
\end_inset

binding_name
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Standard
The bind tag is the counterpart to the surround tag; it specifies where
 in the 
\begin_inset Quotes eld
\end_inset

surrounding
\begin_inset Quotes erd
\end_inset

 template the content will be placed.
 An example is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Binding-in-Templates"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Binding in Templates
\begin_inset CommandInset label
LatexCommand label
name "lst:Binding-in-Templates"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

  <body>
\end_layout

\begin_layout Plain Layout

  <lift:bind name=
\begin_inset Quotes erd
\end_inset

content
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Plain Layout

  </body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
embed
\begin_inset CommandInset label
LatexCommand label
name "sub:embed-tag"

\end_inset

 
\end_layout

\begin_layout LyX-Code
Usage:
\family typewriter
 <lift:embed what="template_name" />
\end_layout

\begin_layout Standard
The embed tag allows you to embed a template within another template.
 This can be used to compose your pages from multiple smaller templates,
 and it also allows you to access templates from javascript commands (chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Lift-and-Javascript"

\end_inset

).
 Like the surround tag, the template name can either be the base filename
 or a fully-qualified path.
\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size small
Note that if you use the embed tag to access templates from within a JsCmd
 (typically an Ajax call), any javascript in the embedded template won't
 be executed.
 This includes, but is not limited to Comet widgets.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
comet 
\end_layout

\begin_layout LyX-Code

\family typewriter
Usage: <lift:comet type="ClassName" name=
\begin_inset Quotes erd
\end_inset

optional
\begin_inset Quotes erd
\end_inset

/>
\end_layout

\begin_layout Standard
The comet tag embeds a comet actor into your page.
 The class of the comet actor is specified by the type attribute.
 The name attribute tells Lift to create a unique instance of the Comet
 actor; for example, you could have one comet actor for site updates and
 another for admin messages.
 The contents of the tag are used by the comet actor to bind a response.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Ledger-Entry-Comet"

\end_inset

 shows an example of a comet binding that displays ledger entries as they're
 added.
 Comet is covered in more detail in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},language=Java,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ledger Entry Comet
\begin_inset CommandInset label
LatexCommand label
name "lst:Ledger-Entry-Comet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<div class="ledgerUpdates">
\end_layout

\begin_layout Plain Layout

  <lift:comet type="LedgerMonitor">
\end_layout

\begin_layout Plain Layout

    <ul><ledger:entries>
\end_layout

\begin_layout Plain Layout

      <li><entry:time/> : <entry:user /> : <entry:amount /></li>
\end_layout

\begin_layout Plain Layout

    </ledger:entries></ul>
\end_layout

\begin_layout Plain Layout

  </lift:comet>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in the embed tag documentation, mixing Comet with AJAX responses
 can be a bit tricky due to the embedded Javascript that Comet uses.
\end_layout

\begin_layout Section
Head Merge
\begin_inset CommandInset label
LatexCommand label
name "sec:Head-Merge"

\end_inset


\end_layout

\begin_layout Standard
Another feature of Lift's template processing is the ability to merge the
 HTML 
\family typewriter
head
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
head
\end_layout

\end_inset

 tag from within a template.
 In our example listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, notice that we've specified a 
\family typewriter
head
\family default
 tag inside the template.
 Without the head merge, this head tag would show up in the default template
 where our template gets bound.
 Lift is smart about this, though, and instead takes the contents of the
 head tag and merges it into the outer template's head tag.
 This means that you can use a surround tag to keep a uniform default template,
 but still change things like the title of the tag, add in scripts or special
 CSS, etc.
 For example, if you have a table in a page that you'd like to style with
 jQuery's TableSorter, you would add a head tag:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Using Head Merge
\begin_inset CommandInset label
LatexCommand label
name "lst:Using-Head-Merge"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with=
\begin_inset Quotes erd
\end_inset

default
\begin_inset Quotes erd
\end_inset

 at=
\begin_inset Quotes erd
\end_inset

foo
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

<head><script src="/scripts/tablesorter.js" type="text/javascript" /><head>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And just for this snippet, you'll import TableSorter.
\end_layout

\begin_layout Section
Snippets
\begin_inset CommandInset label
LatexCommand label
name "sec:Snippets"

\end_inset


\end_layout

\begin_layout Standard
A snippet is a function that takes a single NodeSeq
\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

 argument and is expected to return a NodeSeq.
 The argument passed to the method is the XML contents of the snippet tag;
 because Lift processes from the outside in, the contents are not processed
 before being passed to the snippet method unless you specify the eager_eval
 attribute (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eager-Eval"

\end_inset

).
 As an example, let's say we wanted a snippet that would output the current
 balance of our ledger.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:a-simple-snippet"

\end_inset

 shows what our snippet method looks like.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A simple snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:a-simple-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    Text(currentLedger.formattedBalance)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We simply return an XML Text node with the formatted balance.
 Note that the XML that a snippet returns is further processed from the
 outside in, so if your snippet instead looked like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Returning tags from a snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Returning-tags-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    <p>{currentLedger.formattedBalance}
\end_layout

\begin_layout Plain Layout

      as of <lift:Util.time /></p>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the 
\family typewriter
lift:Util.time
\family default
 snippet will be processed as well after our snippet method returns.
 It is this hierarchical processing of template tags that makes Lift so
 flexible.
 For those of you coming here with some JSP experience, Lift is designed
 to let you write your own template libraries, except much more powerful
 and much simpler to use.
\end_layout

\begin_layout Subsection
Binding Values in Snippets
\end_layout

\begin_layout Standard
So far we've only shown our snippets generating complete output and ignoring
 the input to the method.
 Lift actually provides some very nice facilities for using the input NodeSeq
 within your snippet to help keep presentation and code separate.
 First, remember that the input NodeSeq consists of the child elements for
 the snippet tag in your template.
 That is, given a template containing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet tag children
\begin_inset CommandInset label
LatexCommand label
name "lst:Snippet-tag-children"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:Ledger.balance>
\end_layout

\begin_layout Plain Layout

  <ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Plain Layout

</lift:Ledger.balance>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then the Ledger.balance method receives
\end_layout

\begin_layout LyX-Code
<ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Standard
as its input parameter.
 This is perfectly valid XML, although it may look a little strange at first
 unless you've used prefixed elements in XML before.
 The key is that Lift allows you to selectively 
\begin_inset Quotes eld
\end_inset

bind
\begin_inset Quotes erd
\end_inset

, or replace, these elements with data inside your snippet.
 The 
\family typewriter
Helpers.bind
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.util.Helpers.
 Technically the bind method is overloaded, and can even fill in values
 for the lift:bind tag, but this is advanced usage and we're not going to
 cover that here.
\end_layout

\end_inset

 method takes three arguments:
\end_layout

\begin_layout Enumerate
The namespace, or prefix, of the elements you wish to bind.
 In our example the namespace is 
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
The NodeSeq that contains the elements you wish to bind
\end_layout

\begin_layout Enumerate
One or more BindParam elements that maps the element name to a replacement
 value
\end_layout

\begin_layout Standard
While you can create your own BindParam instances by hand, we generally
 recommend importing 
\family typewriter
Helpers._
\family default
, which among other things contains an implicit conversion from Pair to
 BindParam.
 With this knowledge in hand, we can change our previous definition of the
 balance method to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Binding the ledger balance
\begin_inset CommandInset label
LatexCommand label
name "lst:Binding-the-ledger-balance"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    bind (
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset

, content,
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

balance
\begin_inset Quotes erd
\end_inset

 -> Text(currentLegdger.formattedBalance),
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 -> Text((new java.util.Date).toString))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see here, we actually gain a line of code over our previous effort,
 but the trade-off makes it far simpler for us to change the layout just
 by editing the template.
\end_layout

\begin_layout Subsection
Stateless versus Stateful Snippets
\begin_inset CommandInset label
LatexCommand label
name "sub:Stateless-versus-Stateful"

\end_inset


\end_layout

\begin_layout Standard
The lifecycle of a snippet by default is stateless.
 That means that for each request, Lift creates a new instance of the snippet
 class to execute; any changes you make to instance variables will be discarded
 after the request is processed.
 If you want to keep some state around you have a couple of options:
\end_layout

\begin_layout Itemize
Store the state in a cookie (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cookies"

\end_inset

).
 This can be useful if you have data that you want persisted across sessions.
 The down side is that you have to manage the cookie as well as deal with
 any security implications for the data in the cookie since it's stored
 on the user's machine
\end_layout

\begin_layout Itemize
Store the state in a SessionVar (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-and-Request"

\end_inset

).
 This is a little easier to manage than cookies but you still have to manage
 adding and removing the session data if you don't want it around for the
 duration of the session.
 Like a cookie, it's also global, which means that it will be the same for
 all snippet instances
\end_layout

\begin_layout Itemize
Use a StatefulSnippet subclass.
 This is ideal for small, conversational state, such as a form that spans
 multiple pages or for a page where you have multiple variables that you
 want to be able to tweak individually
\end_layout

\begin_layout Standard
.
 Using a StatefulSnippet is very similar to a normal snippet, with the addition
 of a few mechanisms.
 First, the StatefulSnippet trait defines a dispatch method of type PartialFunct
ion[String, () => NodeSeq].
 This lets you define which methods handle which snippets.
 Because the def dispatch in the base DispatchSnippet can be overridden
 with a var, it also lets you redefine this behavior as a result of snippet
 processing.
 
\end_layout

\begin_layout Standard
Another key to using StatefulSnippets is that when you render a form, a
 hidden field is added to that form that causes the same instance to be
 used on the page that is the target of the form submission.
 If you need to link to a different page, but would like the same snippet
 instance to handle snippets on that page, use the StatefulSnippet.link method
 (instead of SHtml.link); likewise, if you need to redirect to a different
 page, the StatefulSnippet trait defines a redirectTo method.
 In either of these cases a function map is added to the link or redirect,
 respectively, that cause the instance to be reattached.
\end_layout

\begin_layout Standard
As an example of when you might use a stateful snippet, consider a graph
 that shows your spending for some time period and also allows you to specify
 criteria for selecting the data to graph.
 Say you've changed the time span from the default 1 month to 3 months.
 Now you'd like to limit the expense categories to show only 
\begin_inset Quotes eld
\end_inset

Food.
\begin_inset Quotes erd
\end_inset

 More than likely, you'll want the application to respect the change in
 time-span as well.
 This is a case where keeping a bit of state around will allow you to do
 this.
 Using a StatefulSnippet instance greatly simplifies writing the snippet
 because you can keep all of your pertinent information around as instance
 variables instead of having to insert and extract them from every request,
 link, etc.
\end_layout

\begin_layout Standard
Below is an example of a stateful snippet that handles the above example.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Write and then steal from PocketChange
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Eager Evaluation
\begin_inset CommandInset label
LatexCommand label
name "sub:Eager-Eval"

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

, Lift processes the contents of a snippet tag after it processes the tag
 itself.
 If you want the contents of a snippet tag to be processed 
\emph on
before
\emph default
 the snippet, then you need to specify the 
\family typewriter
eager_eval
\family default

\begin_inset Index
status open

\begin_layout Plain Layout
eager eval
\end_layout

\end_inset

 attribute on the tag:
\end_layout

\begin_layout LyX-Code
<lift:Hello.world eager_eval=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

>...</lift:Hello.world>
\end_layout

\begin_layout Standard
This is especially useful if you're using an embedded template (section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:embed-tag"

\end_inset

); without the eager_eval attribute your snippet just sees the <lift:embed>
 tag, but with eager_eval set to true you can put 
\emph on
bindable
\emph default
 common snippet content into a single embedded template instead of copying
 it between templates.
\end_layout

\begin_layout Section
URL Rewriting 
\begin_inset CommandInset label
LatexCommand label
name "sec:URL-Rewriting"

\end_inset


\end_layout

\begin_layout Standard
Now that we've gone over Templates, Views, Snippets, and how the dispatching
 of a request to a Class.method works we can discuss how to intercept requests
 and handle them any way we want.
 URL rewriting is the mechanism that allows you to modify the incoming request
 so that it dispatches to a different URL.
 It can be used, among other things, to allow you to:
\end_layout

\begin_layout Itemize
Use user-friendly, bookmarkable URLs like 
\family typewriter
http://www.example.com/budget/2008
\end_layout

\begin_layout Itemize
Use short URLs instead of long, hard to remember ones, similar to 
\begin_inset CommandInset href
LatexCommand href
target "http://tinyurl.com"

\end_inset


\end_layout

\begin_layout Itemize
Use portions of the URL to determine how a particular snippet or view responds.
 For example, you could make it so that a user's profile is displayed via
 a URL like 
\family typewriter
http://someplace.com/user/derek
\family default
 instead of having the username sent as part of a query string.
\end_layout

\begin_layout Standard
The mechanism is fairly simple to set up.
 We need to write a partial function from a RewriteRequest to a RewriteResponse
 to determine if and how we want to rewrite particular requests.
 The simplest way to do this is with a match statement which will allow
 us to selectively match on some or all of the request information.
 It is important to understand that the Lift session is not created at the
 point when the rewrite functions run; that means that you generally can't
 set or access properties in the S object.
 RewriteRequest is a case object that contains three items: the parsed path,
 the request type and the original HttpServletRequest
\begin_inset Index
status collapsed

\begin_layout Plain Layout
HttpServletRequest
\end_layout

\end_inset

 object.
\end_layout

\begin_layout Standard
The parsed path of the request in a ParsePath
\begin_inset Index
status collapsed

\begin_layout Plain Layout
ParsePath
\end_layout

\end_inset

 case class instance.
 The ParsePath class contains
\end_layout

\begin_layout Enumerate
The parsed path as a List[String]
\end_layout

\begin_layout Enumerate
The suffix of the request (i.e.
 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

, etc)
\end_layout

\begin_layout Enumerate
Whether the path is absolute 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Clarification needed on what this means
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Whether the path ends in a slash (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
The latter three properties are useful only in specific circumstances, but
 the parsed path is what lets us work magic.
 The path of the request is defined as the parts of the URI between the
 context path and the query string.
 The following table shows examples of parsed paths for a Lift application
 under the 
\begin_inset Quotes eld
\end_inset

myapp
\begin_inset Quotes erd
\end_inset

 context path:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Requested URL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Parsed Path
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/home?test_this=true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/user/derek
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

derek
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/view/item/14592
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

view
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

item
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

14592
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The RequestType basically maps to the five HTTP methods: GET, POST, HEAD,
 PUT and DELETE.
 These are represented by the corresponding GetRequest, PostRequest, etc
 case classes, with an UnknownRequest case class to cover anything strange.
\end_layout

\begin_layout Standard
The flexibility of Scala's matching system is what really makes this powerful.
 With matching on Lists in particular, we can match parts of the path and
 capture others.
 For instance, for our second example we'd like to rewrite the 
\begin_inset Quotes eld
\end_inset

/user/<username>
\begin_inset Quotes erd
\end_inset

 path so that it's handled by the 
\begin_inset Quotes eld
\end_inset

/viewUser
\begin_inset Quotes erd
\end_inset

 template
\begin_inset Note Note
status open

\begin_layout Plain Layout
Modify for PocketChange
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Simple rewrite example
\begin_inset CommandInset label
LatexCommand label
name "lst:Simple-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val rewriter = {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(ParsePath(user :: username :: Nil,_,_,_),_,_) => 
\end_layout

\begin_layout Plain Layout

       RewriteResponse(viewUser :: Nil, Map(username -> username))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The RewriteResponse
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RewriteResponse
\end_layout

\end_inset

 simply contains the new path to send and can also take a Map
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 that contains parameters that will be accessible via S.param
\begin_inset Index
status collapsed

\begin_layout Plain Layout
S.param
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
S
\end_layout

\end_inset

 in the snippet or view.
 As we stated before, the LiftSession (and therefore most of S) isn't available
 at this time, so the Map is the only way to pass information on to the
 rewritten location.
 Technically, a rewrite results in a 
\begin_inset Quotes eld
\end_inset

302 Moved Temporarily
\begin_inset Quotes erd
\end_inset

 result code that forwards the client to a new request.
 Because of that, even if you could set data in LiftSession or S it would
 disappear when the redirect occurs.
\end_layout

\begin_layout Standard
We can combine the ParsePath matching with the RequestType and HttpServletReques
t to be very specific with our matches.
 For example, if we wanted to support the DELETE HTTP verb for a RESTful
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RESTful
\end_layout

\end_inset

 interface through an existing template, we could redirect it like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Complex rewrite example
\begin_inset CommandInset label
LatexCommand label
name "lst:Complex-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val rewriter = {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(ParsePath(username :: Nil, _, _, _),
\end_layout

\begin_layout Plain Layout

                      DeleteRequest,
\end_layout

\begin_layout Plain Layout

                      httpreq) 
\end_layout

\begin_layout Plain Layout

                      if isMgmtSubnet(httpreq.getRemoteHost()) => 
\end_layout

\begin_layout Plain Layout

       RewriteResponse(deleteUser :: Nil, Map(username -> username))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We'll go into more detail about how you can use this in the following sections.
 In particular, SiteMap
\begin_inset Index
status collapsed

\begin_layout Plain Layout
SiteMap
\end_layout

\end_inset

 (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

) provides a mechanism for doing rewrites combined with menu entries.
\end_layout

\begin_layout Section
Custom Dispatch functions 
\begin_inset CommandInset label
LatexCommand label
name "sec:Custom-dispatch-func"

\end_inset


\end_layout

\begin_layout Standard
Once the rewriting phase is complete (whether we pass through or are redirected)
, the next phase is to determine if there should be a custom dispatch for
 the request.
 A custom dispatch allows you to handle a matching request directly by a
 method instead of going through the template lookup system; because it
 bypasses templating, you're responsible for the full content of the response.
 A typical use case would be a web service
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web service
\end_layout

\end_inset

 returning XML or a service to return, say, a generated image or PDF.
 In that sense, the custom dispatch mechanism allows you to write your own
 
\begin_inset Quotes eld
\end_inset

sub-servlets
\begin_inset Quotes erd
\end_inset

 without all the mess of implementing the interface and configuring them
 in web.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web.xml
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Custom dispatch is realized, like rewriting, via a partial function.
 In this case, it's a function of type 
\family typewriter
PartialFunction[Req,
\begin_inset Formula $()\Rightarrow Can[LiftResponse]$
\end_inset

]
\family default
 that will do the work.
 The 
\family typewriter
Req
\family default
 is similar to the the RewriteRequest case class; it provides the path as
 a List[String], the suffix of the request, and the RequestType.
 If you attach the dispatch function via 
\family typewriter
LiftRules.dispatch
\family default
 then you'll have full access to the S object and LiftSession; if you use
 
\family typewriter
LiftRules.statelessDispatchTable
\family default
 instead then these aren't available.
 The result of the dispatch should be a function that returns a 
\family typewriter
Can[LiftResponse]
\family default
.
 If the function returns 
\family typewriter
Empty
\family default
 then Lift returns a 
\begin_inset Quotes eld
\end_inset

404 not found
\begin_inset Quotes erd
\end_inset

 response.
\end_layout

\begin_layout Standard
As a concrete example, let's look at returning a generated chart image from
 our application
\begin_inset Note Note
status open

\begin_layout Plain Layout
Modify as appropriate for PocketChange
\end_layout

\end_inset

.
 There are several libraries for charting, but we'll take a look at JFreeChart
 in particular.
 First, let's write a method that will chart our account balances by month
 for the last year:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Charting method
\begin_inset CommandInset label
LatexCommand label
name "lst:Charting-method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def chart (endDate : String) : Can[LiftResponse] = {
\end_layout

\begin_layout Plain Layout

  // Query, set up chart, etc...
\end_layout

\begin_layout Plain Layout

  val buffered = balanceChart.createBufferedImage(width,height)
\end_layout

\begin_layout Plain Layout

  val chartImage = ChartUtilities.encodeAsPNG(buffered)
\end_layout

\begin_layout Plain Layout

  Full(InMemoryResponse(chartImage, 
\end_layout

\begin_layout Plain Layout

                        (Content-Type -> image/png) :: Nil,
\end_layout

\begin_layout Plain Layout

                        Nil,
\end_layout

\begin_layout Plain Layout

                        200))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we've set up the chart, we use the ChartUtilities helper class from
 JFreeChart to encode the chart into a PNG byte array.
 We can then use Lift's InMemoryResponse
\begin_inset Index
status collapsed

\begin_layout Plain Layout
InMemoryResponse
\end_layout

\end_inset

 to pass the encoded data back to the client with the appropriate Content-Type
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Type
\end_layout

\end_inset

 header.
 Now we just need to hook the request into the dispatch table from the Boot
 class as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Hooking-dispatch-into-Boot"

\end_inset

.
 In this case, we want state so that we can get the current user's chart,
 so we use LiftRules.dispatch
\begin_inset listings
lstparams "basicstyle={\footnotesize},frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Hooking dispatch into Boot
\begin_inset CommandInset label
LatexCommand label
name "lst:Hooking-dispatch-into-Boot"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

LiftRules.dispatch.append {
\end_layout

\begin_layout Plain Layout

  case Req(
\begin_inset Quotes eld
\end_inset

chart
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

balances
\begin_inset Quotes erd
\end_inset

 :: endDate :: Nil, _, _) =>
\end_layout

\begin_layout Plain Layout

    Charting.chart(endDate) _
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, we capture the endDate parameter from the path and pass
 it into our chart method.
 This means we can use a URL like 
\family typewriter
http://foo.com/chart/balances/20080401
\family default
 to obtain the image.
 Since the dispatch function has an associated lift session, we can also
 use the S.param method to get query string parameters, in case we wanted
 to allow someone to send an optional width and height:
\end_layout

\begin_layout LyX-Code
val width = S.param(
\begin_inset Quotes eld
\end_inset

width
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 400
\end_layout

\begin_layout LyX-Code
val height = S.param(
\begin_inset Quotes eld
\end_inset

height
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 300
\end_layout

\begin_layout Standard
There are a number of other ListResponse subclasses to cover your needs,
 including responses for XHTML, XML, Atom, Javascript, CSS, and JSON.
 We cover these in more detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

.
\end_layout

\begin_layout Section
HTTP Redirects 
\begin_inset CommandInset label
LatexCommand label
name "sec:HTTP-redirects"

\end_inset


\end_layout

\begin_layout Standard
HTTP redirects are an important part of many web applications.
 In Lift there are two main ways of sending a redirect to the client:
\end_layout

\begin_layout Enumerate
Call S.redirectTo.
 When you do this, Lift throws an exception and catches it later on; that
 means that any of your code following the redirect is skipped.
 If you're using a StatefulSnippet (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-versus-Stateful"

\end_inset

), use 
\family typewriter
this.redirectTo
\family default
 so that your snippet instance is used when the redirect is processed.
\end_layout

\begin_layout Enumerate
When you need to return a LiftResponse you can just return a RedirectResponse
 or a RedirectWithState response.
\end_layout

\begin_layout Standard
The RedirectWithState allows you to specify a function to be executed when
 the redirected request is processed.
 You can also sent Lift notices (see S.notice, S.warning, S.error) that would
 be rendered in the redirected page, as well as cookies to be set on the
 redirect.
 Similarly, there is an overloaded version of S.redirectTo that allows you
 to specify a function to be executed when the redirect is processed.
\end_layout

\begin_layout Section
Cookies
\begin_inset CommandInset label
LatexCommand label
name "sec:Cookies"

\end_inset


\end_layout

\begin_layout Standard
Cookies
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/Cookie.html"

\end_inset


\end_layout

\end_inset

 are a useful tool when you want data persisted across user sessions.
 Cookies are essentially a token of string data that is stored on the user's
 machine.
 While they can be quite useful, there are a few things that you should
 be aware of:
\end_layout

\begin_layout Enumerate
The user's browser may have cookies disabled, in which case you need to
 be prepared to work without cookies or tell the user that they need to
 enable them for your site
\end_layout

\begin_layout Enumerate
Cookies are relatively insecure
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
target "http://www.w3.org/Security/Faq/wwwsf2.html"

\end_inset

 (Q10) and 
\begin_inset CommandInset href
LatexCommand href
target "http://www.cookiecentral.com/faq/"

\end_inset

 for details on cookies and their security issues
\end_layout

\end_inset

; there have been a number of browser bugs related to data in cookies being
 read by viruses or other sites
\end_layout

\begin_layout Enumerate
Cookies are easy to fake, so you need to ensure that you validate any sensitive
 cookie data
\end_layout

\begin_layout Standard
Using Cookies in Lift is very easy.
 In a stateful context, everything you need is covered by a few methods
 on the S object:
\end_layout

\begin_layout Description
addCookie Adds a cookie to be sent in the response
\end_layout

\begin_layout Description
deleteCookie Deletes a cookie (technically, this adds a cookie with a maxage
 of zero so that the browser removes it).
 You can either delete a cookie by name, or with a Cookie object
\end_layout

\begin_layout Description
findCookie Looks for a cookie with a given name and returns a Can[Cookie].
 Empty means that the cookie doesn't exist
\end_layout

\begin_layout Description
receivedCookies Returns a List[Cookie] of all of the cookies sent in the
 request
\end_layout

\begin_layout Description
responseCookies Returns a List[Cookie] of the cookies that will be sent
 in the response
\end_layout

\begin_layout Standard
If you need to work with cookies in a stateless context, many of the ListRespons
e classes (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

) include a List[Cookie] in their constructor or apply arguments.
 Simply provide a list of the cookies you want set an they'll be sent in
 the response.
 If you want to delete a cookie in a LiftResponse you have to do it manually
 by adding a cookie with the same name and a maxage of zero.
 
\end_layout

\begin_layout Section
Session and Request State
\begin_inset CommandInset label
LatexCommand label
name "sec:Session-and-Request"

\end_inset


\end_layout

\begin_layout Standard
Lift provides a very easy way to store per-session and per-request data
 through the SessionVar and RequestVar classes.
 In true Lift fashion, these classes provide:
\end_layout

\begin_layout Itemize
Type-safe access to the data they hold
\end_layout

\begin_layout Itemize
A mechanism for providing a default value if the session or request doesn't
 exist yet
\end_layout

\begin_layout Itemize
A mechanism for cleaning up the data when the variable's lifecycle ends
\end_layout

\begin_layout Standard
Additionally, Lift provides easy access to HTTP request parameters
\begin_inset Index
status open

\begin_layout Plain Layout
request parameters
\end_layout

\end_inset

 via the S.param method, which returns a Can[String].
 Note that HTTP request parameters (sent either via GET or POST) differ
 from RequestVars in that query parameters are string values sent as part
 of the request; RequestVars, by contrast, use an internal per-request Map
 so that they can hold any type, and are initialized entirely in code.
 At this point you might ask what RequestVars can be used for; a typical
 example would be sharing state between different snippets, since there
 is no connection between snippets other than at the template level.
\end_layout

\begin_layout Standard
SessionVars and RequestVars are intended to be implemented as singleton
 objects so that they're accessible from anywhere in your code.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Defining-a-RequestVar"

\end_inset

 shows an example definition of a RequestVar used to hold the number of
 entries to show per page.
 We start by defining the object as extending the RequestVar.
 You must provide the type of the RequestVar so that Lift knows what to
 accept and return.
 The constructor argument is a by-name parameter which must evaluate to
 the var's type; in our case, we attempt to use the HTTP request variable
 
\begin_inset Quotes eld
\end_inset

pageSize
\begin_inset Quotes erd
\end_inset

, and if that isn't present or isn't an integer we default to 25.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Defining a RequestVar
\begin_inset CommandInset label
LatexCommand label
name "lst:Defining-a-RequestVar"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  object pageSize extends RequestVar[Int](S.param(
\begin_inset Quotes eld
\end_inset

pageSize
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 25)
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Accessing the value of the RequestVar is handled via the is method.
 You can also set the value using the apply method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Accessing the RequestVar
\begin_inset CommandInset label
LatexCommand label
name "lst:Accessing-the-RequestVar"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

query.setMaxResults(Ledger.pageSize.is)
\end_layout

\begin_layout Plain Layout

// Change the value
\end_layout

\begin_layout Plain Layout

Ledger.pageSize(50)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to taking a parameter that defines a default value for setup,
 you can also handle cleaning up the value when the variable ends it lifecycle.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Defining-a-Cleanup"

\end_inset

 shows an example of opening a socket and closing it at the end of the request.
 You can see that we override cleanupFunc and return a Full Can with the
 cleanup function.
 It's important to note that the cleanupFunc method is only used if the
 default value is used; if you always set the value of the RequestVar before
 you access it then you'll need to use the registerCleanupFunc instead.
 Also remember that you're responsible for handling any exceptions that
 might be thrown during either default initialization or cleanup.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Defining a Cleanup Function
\begin_inset CommandInset label
LatexCommand label
name "lst:Defining-a-Cleanup"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

object mySocket extends RequestVar[Socket](new Socket(
\begin_inset Quotes eld
\end_inset

localhost:23
\begin_inset Quotes erd
\end_inset

)) {
\end_layout

\begin_layout Plain Layout

  override def cleanupFunc = Full(() => this.is.close)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The inormation we've covered here is equally applicable to SessionVars;
 the only difference between them is the scope of their respective lifecycles.
\end_layout

\begin_layout Section
More Useful Objects
\end_layout

\begin_layout Standard
In addition to what we've covered so far, there a few more objects that
 are important to understand.
 We're going to cover these in detail in later sections, but we want to
 briefly mention each one here just so you're aware of them.
\end_layout

\begin_layout Subsection
S object
\begin_inset CommandInset label
LatexCommand label
name "sub:S-object"

\end_inset


\end_layout

\begin_layout Standard
The S object represents the state of the current request.
 As such, it is used to retrieve information about the request and modify
 information that is sent in the response.
 Among other things, it can be used for notices (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Message-Handling"

\end_inset

) , cookie management (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cookies"

\end_inset

), localization (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Internationalization"

\end_inset

) and redirection (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset

).
\end_layout

\begin_layout Subsection
SHtml
\begin_inset CommandInset label
LatexCommand label
name "sub:SHtml"

\end_inset


\end_layout

\begin_layout Standard
The SHtml object's main purpose is to define HTML generation functions,
 particularly those having to do with form elements.
 We cover forms in detail in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Forms-in-Lift"

\end_inset

).
 In addition to normal form elements, SHtml defines functions for Ajax and
 JSON form elements (chapters 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:JSON-Handling"

\end_inset

, respectively).
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We've covered a lot of material and we still have a lot more to go.
 Hopefully this chapter provides a firm basis to start from when exploring
 the rest of the book.
\end_layout

\end_body
\end_document
