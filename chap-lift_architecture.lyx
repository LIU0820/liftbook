#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Architecture
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This chapter will walk you through fundamental aspects of understanding
 how Lift works, lifecycle of various entities, understanding how you can
 add you own functions to be part of processing and rendering pipeline etc.
 We will be describing parts of the Lift API such as LiftRules object.
 
\end_layout

\begin_layout Section
Entry into Lift
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
From our discussion:
\end_layout

\begin_layout Plain Layout
Chapter: Arch: 
\end_layout

\begin_layout Plain Layout
- all the fun in Boot (url rewriting, like the stuff you have) 
\end_layout

\begin_layout Plain Layout
- how lift handles requests (what you have got) 
\end_layout

\begin_layout Plain Layout
- intro to views, snippets and how they relate to dispatch
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first step in Lift's request processing is intercepting the HTTP request.
 Originally, Lift used a Servlet instance to process incoming requests.
 This was changed to use a Filter instance
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://groups.google.com/group/liftweb/browse_thread/thread/b484ea2a13b6f84b/90ba1
ef1115055a6
\end_layout

\end_inset


\end_layout

\end_inset

 because this allows the container to handle any requests that Lift does
 not (in particular, static content).
 The filter acts as a thin wrapper on top of the existing LiftServlet (which
 still does all of the work), so don't be confused when you look at the
 ScalaDoc and see both classes.
 The main thing to remember is that your web.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web.xml
\end_layout

\end_inset

 should specify the filter and not the servlet:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},frame=single,language=XML,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:LiftFilter-setup-in-web.xml"

\end_inset

LiftFilter setup in web.xml
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="ISO-8859-1"?>
\end_layout

\begin_layout Plain Layout

<!DOCTYPE web-app
\end_layout

\begin_layout Plain Layout

PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
\end_layout

\begin_layout Plain Layout

"http://java.sun.com/j2ee/dtds/web-app_2_3.dtd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<web-app>
\end_layout

\begin_layout Plain Layout

  <filter>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <display-name>Lift Filter</display-name>
\end_layout

\begin_layout Plain Layout

    <description>The Filter that intercepts lift calls</description>
\end_layout

\begin_layout Plain Layout

    <filter-class>net.liftweb.http.LiftFilter</filter-class>
\end_layout

\begin_layout Plain Layout

  </filter>      
\end_layout

\begin_layout Plain Layout

  <filter-mapping>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <url-pattern>/*</url-pattern>
\end_layout

\begin_layout Plain Layout

  </filter-mapping>
\end_layout

\begin_layout Plain Layout

</web-app>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A full web.xml example is shown in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:JPA-web.xml"

\end_inset

.
 In particular, the filter-mapping specifies that the Filter is responsible
 for everything.
 When the filter receives the request, it checks a set of rules to see if
 it can handle it.
 If the request is one that Lift handles, it passes it on to an internal
 LiftServlet instance for processing; otherwise, it chains the request and
 allows the container to handle it.
\end_layout

\begin_layout Section
Bootstrap
\end_layout

\begin_layout Standard
When Lift starts up there are a number of things that you'll want to set
 up before any requests are processed.
 These things include setting up a SiteMenu, URL rewriting, custom dispatch,
 classpath search and pretty much all what LiftRules object has to offer.
 The Lift servlet looks for the bootstrap.liftweb.Boot
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Boot
\end_layout

\end_inset

 class and executes the boot method in the class.
 You can also specify your own Boot instance by using the following context
 param in web.xml
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 
\begin_inset Caption

\begin_layout Plain Layout
web.xml Boot param
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

  <context-param>     
\end_layout

\begin_layout Plain Layout

	<param-name>bootloader</param-name>
\end_layout

\begin_layout Plain Layout

    <param-value>foo.bar.baz.MyBoot</param-value>
\end_layout

\begin_layout Plain Layout

  </context-param> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Your MyBoot class needs to be a Bootable
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Bootable class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

abstract class Bootable {   
\end_layout

\begin_layout Plain Layout

	def boot() : Unit; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The boot method will only be run once, so you can place any initialization
 calls for other libraries here as well.
 
\end_layout

\begin_layout Standard
It is important to note that a lot of aspects related with Lift's behavior
 can be customized from boot by using LiftRules object.
 
\end_layout

\begin_layout Section
Classpath
\end_layout

\begin_layout Standard
As part of our discussion of the Boot class, it's important to cover a small
 detail of how Lift determines where to find classes for Views and Snippet
 rendering.
 The LiftRules.addToPackages method tells lift what Scala packages to look
 in for a given class.
 Lift has implicit extensions to the paths you enter; in particular, if
 you tell Lift to use the 
\begin_inset Quotes eld
\end_inset

com.pocketchangeapp
\begin_inset Quotes erd
\end_inset

 package, Lift will look for View classes under 
\begin_inset Quotes eld
\end_inset

com.pocketchangeapp.view
\begin_inset Quotes erd
\end_inset

 and will look for Snippet classes under 
\begin_inset Quotes eld
\end_inset

com.pocketchangeapp.snippet
\begin_inset Quotes erd
\end_inset

.
 Typically the 
\family typewriter
addToPackages
\family default
 method is excuted in your Boot class.
 A minimal Boot class would look like
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Minimal Boot class
\begin_inset CommandInset label
LatexCommand label
name "lst:Minimal-Boot-class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    LiftRules.addToPackages("com.pocketchangeapp")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
LiftRules object
\end_layout

\begin_layout Standard
Before going further with describing the how lift is processing the requests,
 how lifecycle is managed etc.
 it is important to discuss the LiftRules object as this is the entity that
 allow you to hook up your own functions to be part of processing/rendering
 pipeline.
 Think of LiftRules as a way of configuring Lift behavior to fit you application
 needs.
\end_layout

\begin_layout Subsection
Declared types
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	
\begin_inset Caption

\begin_layout Plain Layout
LiftRules types
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that will be called by lift when processing requests.
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type DispatchPF = PartialFunction[Req, () => Can[LiftResponse]];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that will be called very early by lift so that
\end_layout

\begin_layout Plain Layout

	 * you can transform an URI path into something else.
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type RewritePF = PartialFunction[RewriteRequest, RewriteResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows to specify a dynamic snippet
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type SnippetPF = PartialFunction[List[String], NodeSeq => NodeSeq]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows to specify application wide custom
 lift tags.
\end_layout

\begin_layout Plain Layout

	 * They can pe used in markup like <lift:xxx/>
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type LiftTagPF = PartialFunction[(String, Elem, MetaData, NodeSeq, String),
 NodeSeq]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows you to specify your own function when
 lift can not 
\end_layout

\begin_layout Plain Layout

	 * find a certain path.
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type URINotFoundPF = PartialFunction[(Req, Can[Failure]), LiftResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows you 
\begin_inset Quotes eld
\end_inset

decorate
\begin_inset Quotes erd
\end_inset

 the URL's used for links, form action,
\end_layout

\begin_layout Plain Layout

	 * Comet and Ajax requests.
 This is useful when you want to pass certain parameters for
\end_layout

\begin_layout Plain Layout

     * instance for load balancing rules.
 There are practices where sticky sessions needs to 
\end_layout

\begin_layout Plain Layout

	 * be used and Load balancer need to dispatch the requests of a certain
 session to the same 
\end_layout

\begin_layout Plain Layout

	 * cluster node.
 Not always jsessionid cookie or url rewriting.
 Thus load balancers support
\end_layout

\begin_layout Plain Layout

	 * to do balancing based on certain query parameters (i.e.
 srvid=1) which internally are mapped 
\end_layout

\begin_layout Plain Layout

	 * with the actual node IP address.
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type URLDecorator = PartialFunction[String, String]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows you to map a DispatchSnippet with
 a name.
 DispatchSnippet 
\end_layout

\begin_layout Plain Layout

	 * is a trait that allows you to dispatch to various snippet functions
 without the use
\end_layout

\begin_layout Plain Layout

	 * of reflection.
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type SnippetDispatchPF = PartialFunction[String, DispatchSnippet]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows you to map a DispatchSnippet with
 a name
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

	type ViewDispatchPF = PartialFunction[List[String], Either[() => Can[NodeSeq],
 LiftView]] 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * A partial function that allows the application to define requests
 that should be
\end_layout

\begin_layout Plain Layout

     * handled by lift rather than the default servlet handler
\end_layout

\begin_layout Plain Layout

     */ 
\end_layout

\begin_layout Plain Layout

    type LiftRequestPF = PartialFunction[Req, Boolean] 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
LiftRules variables
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftRules variables
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * A function that takes the HTTPSession and the contextPath as parameters
\end_layout

\begin_layout Plain Layout

 * and returns a LiftSession reference.
 This can be used in cases subclassing
\end_layout

\begin_layout Plain Layout

 * LiftSession is necessary.
    
\end_layout

\begin_layout Plain Layout

 */ 
\end_layout

\begin_layout Plain Layout

var sessionCreator: (HttpSession,  String, List[(String, String)]) => LiftSessio
n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The path to handle served resources.
 By default it is set to 
\begin_inset Quotes eld
\end_inset

classpath
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

 */ 
\end_layout

\begin_layout Plain Layout

var ResourceServerPath
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Allows you to switch between JavaScript framework that Lift is using.
 By default it 
\end_layout

\begin_layout Plain Layout

 * points to JQueryArtifacts.
 Lift also support YUIArtifacts
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var jsArtifacts: JSArtifacts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Use this PartialFunction to to automatically add static URL parameters
    
\end_layout

\begin_layout Plain Layout

 * to any URL reference from the markup of Ajax request.
    
\end_layout

\begin_layout Plain Layout

 */ 
\end_layout

\begin_layout Plain Layout

var urlDecorate: List[URLDecorator]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Calculate the Comet Server (by default, the server that
\end_layout

\begin_layout Plain Layout

 * the request was made on, but can do the multi-server thing  
\end_layout

\begin_layout Plain Layout

 * as well)    
\end_layout

\begin_layout Plain Layout

 */ 
\end_layout

\begin_layout Plain Layout

var cometServer: () => String
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The maximum concurrent requests.
  If this number of    
\end_layout

\begin_layout Plain Layout

 * requests are being serviced for a given session, messages    
\end_layout

\begin_layout Plain Layout

 * will be sent to all Comet requests to terminate    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var maxConcurrentRequests = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * A partial function that determines content type based on an incoming
    
\end_layout

\begin_layout Plain Layout

 * Req and Accept header    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var determineContentType: PartialFunction[(Can[Req], Can[String]), String]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Contains functions that willbe executed when LiftServlet.destroy is called.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

val unloadHooks: ListBuffer[() => Unit]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The maximum allowed size of a complete mime multi-part POST.
  Default
\end_layout

\begin_layout Plain Layout

 * 8MB    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var maxMimeSize: Long
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Should pages that are not found be passed along the servlet chain to
 the
\end_layout

\begin_layout Plain Layout

 * next handler?    
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var passNotFoundToChain = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The maximum allowed size of a single file in a mime multi-part POST.
  
\end_layout

\begin_layout Plain Layout

 * Default 7MB    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var maxMimeFileSize: Long
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The function referenced here is called if there's a localization lookup
 failure
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var localizationLookupFailureNotice: Can[(String, Locale) => Unit]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The default location to send people if SiteMap access control fails 
 
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var siteMapFailRedirectLocation: List[String]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * If you don't want lift to send the application/xhtml+xml mime type to
 those browsers    
\end_layout

\begin_layout Plain Layout

 * that understand it, then set this to {@code false}    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var useXhtmlMimeType: Boolean = true 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * A function that defines how a String should be converted to XML    
\end_layout

\begin_layout Plain Layout

 * for the localization stuff.
  By default, Text(s) is returned,    
\end_layout

\begin_layout Plain Layout

 * but you can change this to attempt to parse the XML in the String and
    
\end_layout

\begin_layout Plain Layout

 * return the NodeSeq.
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var localizeStringToXml: String => NodeSeq
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The base name of the resource bundle.
 Default set to 
\begin_inset Quotes eld
\end_inset

lift
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var resourceName = "lift"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The base name of the resource bundle of the lift core code
\end_layout

\begin_layout Plain Layout

 * Default set to 
\begin_inset Quotes eld
\end_inset

i18n.lift-core
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var liftCoreResourceName
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Where to send the user if there's no comet session.
 Default set to 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var noCometSessionPage
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Put a function that will calculate the request timeout based on the 
   
\end_layout

\begin_layout Plain Layout

 * incoming request.
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var calcRequestTimeout: Can[Req => Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * If you want the standard (non-AJAX) request timeout to be something other
 than 
\end_layout

\begin_layout Plain Layout

 * 10 seconds, put the value here    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var stdRequestTimeout: Can[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * If you want the AJAX request timeout to be something other than 120 seconds,
 put the value here
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var cometRequestTimeout: Can[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Meta information for the notices that are applied via Ajax response 
   
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxNoticeMeta: Can[AjaxMessageMeta]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Meta information for the warnings that are applied via Ajax response
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxWarningMeta: Can[AjaxMessageMeta]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Meta information for the errors that are applied via Ajax response  
  
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxErrorMeta: Can[AjaxMessageMeta]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * A function that takes the current HTTP request and returns the current
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var timeZoneCalculator: Can[HttpServletRequest] => TimeZone
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * How many times do we retry an Ajax command before calling it a failure?
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxRetryCount: Can[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The JavaScript to execute at the begining of an    
\end_layout

\begin_layout Plain Layout

 * Ajax request (for example, showing the spinning working thingy)    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxStart: Can[() => JsCmd]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The JavaScript to execute at the end of an  
\end_layout

\begin_layout Plain Layout

 * Ajax request (for example, removing the spinning working thingy) 
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxEnd: Can[() => JsCmd]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The default action to take when the JavaScript action fails    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxDefaultFailure: Can[() => JsCmd] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * A function that takes the current HTTP request and returns the current
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var localeCalculator: Can[HttpServletRequest] => Locale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The Ajax path
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var ajaxPath = "ajax_request"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The Comet path
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var cometPath = "comet_request"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * Determins the JsExp from the path.
 By default Lift also adds some unique sequences.
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var calcCometPath: String => JsExp
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * If there is an alternative way of calculating the context path    
\end_layout

\begin_layout Plain Layout

 * (by default inspecting the X-Lift-ContextPath header)    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var calculateContextPath: HttpServletRequest => Can[String]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The function that returns a LiftLogger
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var cometLoggerBuilder: () => LiftLogger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The partial function determining the default HTTP headers to be sent
 to client
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var defaultHeaders: PartialFunction[(NodeSeq, Req), List[(String, String)]]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * A lift of functions that allows tranforming the responses
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var responseTransformers: List[LiftResponse => LiftResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The functions to be executed when a snippet is not found
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var snippetFailedFunc: List[SnippetFailure => Unit]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The function that deals with how exceptions are presented to the user
 during processing    
\end_layout

\begin_layout Plain Layout

 * of an HTTP request.
  Put a new function here to change the behavior.
    
\end_layout

\begin_layout Plain Layout

 *    
\end_layout

\begin_layout Plain Layout

 * The function takes the Req and the Exception and returns a LiftResponse
 that's
\end_layout

\begin_layout Plain Layout

 * sent to the browser.
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var logAndReturnExceptionToBrowser: (Req, Throwable) => LiftResponse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The partial function (pattern matching) for handling converting an exception
 to something to    
\end_layout

\begin_layout Plain Layout

 * be sent to the browser depending on the current RunMode (development,
 etc.)
\end_layout

\begin_layout Plain Layout

 *
\end_layout

\begin_layout Plain Layout

 * The best thing to do is browserResponseToException = { case (...) => } orElse
 browserResponseToException    
\end_layout

\begin_layout Plain Layout

 * so that your response over-rides the default, but the processing falls
 through to the default.
    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var browserResponseToException: PartialFunction[(Props.RunModes.Value, Req,
 Throwable), LiftResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

 * The list of partial function for defining the behavior of what happens
 when    
\end_layout

\begin_layout Plain Layout

 * URI is invalid and you're not using a site map    
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

def uriNotFound: List[URINotFoundPF]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Hooks to be called when Lift start processing a request
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var onBeginServicing: List[Req => Unit]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Hooks to be called when Lift ends processing a request
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var onEndServicing: List[(Req, Can[LiftResponse]) => Unit]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * By default it is set to true
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var autoIncludeComet: LiftSession => Boolean 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * By default it is set to true
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var autoIncludeAjax: LiftSession => Boolean
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The deault Ajax script.
\end_layout

\begin_layout Plain Layout

 */   
\end_layout

\begin_layout Plain Layout

var renderAjaxScript: LiftSession => JsCmd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The deault Comet script.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var renderCometScript: LiftSession => JsCmd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Renders commet versioning
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var renderCometPageContents: (LiftSession, Seq[CometVersionPair]) => JsCmd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * If this time does not elapses Lift will send HTTP 304 status to client
\end_layout

\begin_layout Plain Layout

 * indicating that the cached content should be used.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var ajaxScriptUpdateTime: LiftSession => Long
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * If this time does not elapses Lift will send HTTP 304 status to client
\end_layout

\begin_layout Plain Layout

 * indicating that the cached content should be used.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var cometScriptUpdateTime: LiftSession => Long
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The name of the Ajax script
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var ajaxScriptName: () => String
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The name of the Comet script
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var cometScriptName: () => String
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Return the Comet JavaScript code
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var serveCometScript: (LiftSession, Req) => Can[LiftResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Return the Ajax JavaScript code
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

var serveAjaxScript: (LiftSession, Req) => Can[LiftResponse]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
LiftRules useful functions
\end_layout

\begin_layout Section
Request/Response Lifecycle
\end_layout

\begin_layout Standard
Now that the request has entered the LiftServlet instance, it's time to
 process it.
 There are a quite a few fundamental steps that must be mentioned in order
 have a clear picture how and where certain things are happening.
\end_layout

\begin_layout Enumerate
URL Rewriting - this is useful when you want to transform a URI path into
 something else such as query paramters etc.
 The result of the transformation will be passed to futher processing.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftRules object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

type RewritePf = PartialFunction[RewriteRequest, RewriteResponse]
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the begining of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def prependRewrite(pf: RewritePf)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the end of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def appendRewrite(pf: RewritePf)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Check for user-defined stateless dispatch
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftRules object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type DispatchPf = PartialFunction[Req, () => Can[LiftResponse]];
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

var statelessDispatchTable: DispatchPf
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The term stateless means that when the DispatchPf function is called the
 S object is not available and LiftSession not created yet.
\end_layout

\begin_layout Enumerate
Create Lift session (If there is no applicable stateless dispatch function)
\end_layout

\begin_layout Enumerate
Handle stateful request
\end_layout

\begin_deeper
\begin_layout Enumerate
Check the stateful dispatch functions (See LiftRules.addDispatchBefore, LiftRules.
addDispatchAfter)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftRules object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type DispatchPf = PartialFunction[Req, () => Can[LiftResponse]];
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the begining of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def prependDispatch(pf: DispatchPf)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the end of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def appendDispatch(pf: DispatchPf)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
If it's a Comet request process it 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add a reference to Comet processing
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
If it's an Ajax request process it.
 Bascally execute the user's function mapped with that specific request
 token (impersonated by a request parameter) and return the response which
 can be a JavaScript, an XML construct or virtualy any LiftReponse.
\end_layout

\begin_layout Enumerate
If it's a regular HTTP request process it such as:
\end_layout

\begin_deeper
\begin_layout Enumerate
Init S object (S stands for Stateful)
\end_layout

\begin_layout Enumerate
Call LoanWrapper-s
\end_layout

\begin_deeper
\begin_layout Enumerate
Essentially a LoanWrapper is used to wrap the lift processing logic so you
 can have code that handle pre and post condisions
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LoadWraper trait
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

trait LoanWrapper {   
\end_layout

\begin_layout Plain Layout

	def apply[T](f: => T): T 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
S object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def addAround(lw: List[LoanWrapper]): Unit
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def addAround(lw: LoanWrapper): Unit
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Code example for around-invocation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {   
\end_layout

\begin_layout Plain Layout

  def boot {   
\end_layout

\begin_layout Plain Layout

	S.addAround(new LoanWrapper { // Let's call it LW1
\end_layout

\begin_layout Plain Layout

				  def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

		    	    ...your before code goes here...
   
\end_layout

\begin_layout Plain Layout

		        	val result = f // Let lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

			        ...your after code goes here...
   
\end_layout

\begin_layout Plain Layout

				  }   
\end_layout

\begin_layout Plain Layout

				} :: new LoanWrapper { // Let's call it LW2
\end_layout

\begin_layout Plain Layout

				  def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

		    	    ...your before code goes here...
   
\end_layout

\begin_layout Plain Layout

		        	val result = f // Let lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

			        ...your after code goes here...
   
\end_layout

\begin_layout Plain Layout

				  }   
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				:: Nil)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // The call sequence would be LW1(LW2(<normal_request_processing>))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Check the user's dispatch functions that are set per-session.
 If there is a function applicable execute it and return its response
\end_layout

\begin_layout Enumerate
If there is no per-session dispatch function process the request by executing
 the Scala function that user set up for specific events (such as when clicking
 a link, or pressing the submit button, or a function that will be executed
 when a form field is set etc.)
\end_layout

\begin_layout Enumerate
Check the SiteMap and Loc functions 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add a reference to SiteMap/Loc section
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Lookup for the template based on the Request path.
 Lift will locate the templates using various aproaches:
\end_layout

\begin_deeper
\begin_layout Enumerate
Check for ViewDispatchPF functions.
 If there is a function defined for this path invoke it and return an Either
\end_layout

\begin_layout Enumerate
If there is no ViewDispatchPF look for the template in the path specified
 in the request
\end_layout

\begin_layout Standard
The ViewDispatchPf functions are defined in LiftRules
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftRules object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * A partial Function taking a List[String] parameter impersonating the
 path such as /foo/bar corresponds with 
\end_layout

\begin_layout Plain Layout

 * List(
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

type ViewDispatchPF = PartialFunction[List[String], Either[() => Can[NodeSeq],
 LiftView]] 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the begining of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def prependViewDispatch(in: ViewDispatchPF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Add the in partial function at the end of the list
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

def appendViewDispatch(in: ViewDispatchPF)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
Process the templates by executing snippets combining templates etc.
\end_layout

\begin_deeper
\begin_layout Enumerate
Merge <head> elements
\end_layout

\begin_deeper
\begin_layout Enumerate
Update the internal functions map.
 Basically associate user's scala functions with tokens that are impersonated
 in subsequent requests by HTTP parameters
\end_layout

\begin_layout Enumerate
Check to see if lift needs to send HTTP redirect 
\begin_inset Note Note
status open

\begin_layout Plain Layout
I think we need a dedicated section for redirects as we have redirect with
 state etc.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Convert the LiftResponse to raw bytes stream and send it to client as HTTP
 response
\end_layout

\begin_layout Standard
A lot more is going on under the hood (Lift is highly customizable) but
 for now this should cover 95% of what you will want to do in a Lift application.
\end_layout

\begin_layout Section
Templates
\end_layout

\begin_layout Standard
Templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Templates
\end_layout

\end_inset

 form the backbone of Lift's flexibility and power.
 A template is essentially an XML file that contains Lift-specific tags
 as well as whatever content you want returned to the user.
 There are a number of built-in XML tags that Lift uses for specific reasons,
 these are of the form 
\family typewriter
<lift:name />
\family default
.
 Lift also allows you to create your own tags, which are called 
\emph on
snippets
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
snippets
\end_layout

\end_inset

.
 These user-defined tags are linked directly to Scala methods and these
 methods can process the contents of the snippet tag, or can generate their
 own content from scratch.
 Below is a simple template:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},frame=single,language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Sample template
\begin_inset CommandInset label
LatexCommand label
name "lst:Sample-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <head><title>Hello!</title></head>
\end_layout

\begin_layout Plain Layout

  <lift:snippet type="Hello.world" />
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the tags that are of the form 
\family typewriter
<lift:name>
\family default
 which in this case are 
\family typewriter
<lift:surround>
\family default
 and 
\family typewriter
<lift:snippet>.
 
\family default
These are two examples of Lift-specific tags.
 We'll discuss all of the tags that users will use in section Tags 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ArchTags"

\end_inset

, but let's discuss the two contained here.
 We use the built-in 
\family typewriter
<lift:surround>
\begin_inset Index
status collapsed

\begin_layout Plain Layout
lift:surround
\end_layout

\end_inset


\family default
 tag to make Lift embed our current template inside the 
\begin_inset Quotes eld
\end_inset


\family typewriter
default
\family default

\begin_inset Quotes erd
\end_inset

 template.
 We also use 
\family typewriter
<lift:snippet>
\family default
 to execute a snippet that we defined.
 In this case we execute the method 
\family typewriter
world
\family default
 in the class 
\family typewriter
Hello 
\family default
to generate some content.
 
\end_layout

\begin_layout Standard
Following rewriting and custom dispatch, Lift checks to see if it can find
 a file in the WAR tree that matches the request.
 Lift tries several suffixes (html, xhtml, htm, and no suffix) and also
 tries to match based on the client's Accept-Language header.
 The pattern Lift uses is
\end_layout

\begin_layout LyX-Code
<path to template>[_<language, optional>][.<suffix>]
\end_layout

\begin_layout Standard
Because Lift will implicitly search for suffixes, it's best to leave the
 suffix off of your links within the web app.
 If you have a link with an href of 
\family typewriter
/test/template.xhtml
\family default
, it will only match that file, but if you use 
\family typewriter
/test/template
\family default
 for the href and you have the following templates in your web app:
\end_layout

\begin_layout Itemize

\family typewriter
/test/template.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_es-ES.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_ja.xhtml
\end_layout

\begin_layout Standard
then Lift will use the appropriate template based on the user's requested
 language if a corresponding template is available.
 In addition to normal templates, your application can make use of hidden
 templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
hidden templates
\end_layout

\end_inset

.
 These are templates that are located under the 
\family typewriter
/templates-hidden
\family default
 directory of your web app.
 Like the 
\family typewriter
WEB-XML
\family default
 directory, the contents cannot be directly requested by clients.
 They can, however, be used by other templates through mechanisms like the
 
\family typewriter
lift:surround
\family default
 and 
\family typewriter
lift:embed
\family default
 tags.
 If Lift cannot locate an appropriate template based on the request path
 then it will return a 404 to the user.
\end_layout

\begin_layout Standard
Once Lift has located the correct template, the next step is to process
 the contents.
 It is important to understand that Lift processes XML tags from the outside
 in.
 That means that in our example listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, the surround tag gets processed first.
 In this case the surround loads the default template and embeds our content
 at the appropriate location.
 The next tag to be processed is the 
\family typewriter
<lift:Hello.world/>
\family default
 snippet.
 This tag is essentially an alias for the lift:snippet tag (specifically,
 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello:world
\begin_inset Quotes erd
\end_inset

>
\family default
) , and will locate the Hello class and execute the world method on it.
 If you omit the 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

 part of the type and only specify the class (
\family typewriter
<lift:Hello>
\family default
 or 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

>
\family default
) then Lift will attempt to call the 
\family typewriter
render
\family default
 method of the class.
\end_layout

\begin_layout Standard
So templates are a nice way of setting up your layout and then writing a
 few methods to fill in the XML fragments that make up your web applications.
 They provide a simple way to generate a uniform look for your site.
 If you'd like more control or don't need a template for a certain section,
 you'll want to use a View, which is coming up in the next section.
\end_layout

\begin_layout Subparagraph

\emph on
Sometimes it might be tempted to load manually a template (from a snippet
 for example) using 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LiftSession class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

processSurroundAndInclude(page: String, in: NodeSeq)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Even if Lift will merge your templates and invoke snippets it is HIGHLY
 recommended to NOT use this as the processing functions will not be invoked
 as the functions mapping will not happen as this is called 
\bar under
outside 
\bar default
of normal rendering pipeline.
 
\end_layout

\begin_layout Section
Views
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Convert examples to PocketChange...
 aka, work on PocketChange :)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We just discussed Templates and we saw how through a combination of an XML
 file, Lift tags, and Scala code we can respond to requests made by a user.
 You can also generate those responses entirely in code by using Views.
\end_layout

\begin_layout Standard
Views
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Views
\end_layout

\end_inset

 are implicitly defined custom dispatch methods.
 We'll cover Dispatch in more depth in the next section.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Custom-Dispatch"

\end_inset

.
 A view is a normal Scala method that returns a NodeSeq
\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

; the main difference is that with custom dispatch we explicitly define
 the path that will lead to the method via LiftRules, whereas in a view,
 the class itself defines the path.
 In either case, View lookup and dispatch is done after template resolution
 (to be covered later), so templates take priority
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
TODO: Confirm this!
\end_layout

\end_inset

.
 There are two options for implementing a view class: one is to extend the
 LiftView
\begin_inset Index
status collapsed

\begin_layout Plain Layout
LiftView
\end_layout

\end_inset

 trait, the other is to implement the InsecureLiftView
\begin_inset Index
status collapsed

\begin_layout Plain Layout
InsecureLiftView
\end_layout

\end_inset

 trait.
 As you may be able to tell from the names, we would prefer that you use
 the LiftView trait.
 The InsecureLiftView determines method dispatch by turning a request path
 into a class and method name.
 For instance, if we have a path 
\family typewriter
/MyStuff/enumerate
\family default
, then Lift will look for a class called 
\family typewriter
MyStuff
\family default
 in the view subpackage 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Where to cross-ref for class resolution, LiftRules.addToPackages
\end_layout

\end_inset

 and if it finds it and it has a method called 
\family typewriter
enumerate
\family default
, then Lift will execute the method and return its results to the user.
 The main issue there is that Lift uses reflection
\begin_inset Index
status collapsed

\begin_layout Plain Layout
reflection
\end_layout

\end_inset

 to get the method, so it can access any method in the class, even ones
 marked private.
 A better way to do it is to use the LiftView trait, which defines a dispatch
 partial function.
 This dispatch function maps a string (the 
\begin_inset Quotes eld
\end_inset

method name
\begin_inset Quotes erd
\end_inset

) to a function that will return a NodeSeq.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

 shows a custom LiftView class where the path 
\family typewriter
/ExpenseView/enumerate
\family default
 will map to the ExpenseView.doEnumerate method.
 If someone attempts to go to 
\family typewriter
/ExpenseView/privateMethod
\family default
 they'll get a 404 since it's not defined in the dispatch function.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This should be a pocketchange example
\end_layout

\end_inset

Dispatch in LiftView
\begin_inset CommandInset label
LatexCommand label
name "lst:Dispatch-in-LiftView"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class ExpenseView extends LiftView {
\end_layout

\begin_layout Plain Layout

  override def dispatch = {
\end_layout

\begin_layout Plain Layout

    case "enumerate" => doEnumerate _
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def doEnumerate () : NodeSeq = {  
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    <lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

     { expenseItems.toTable }
\end_layout

\begin_layout Plain Layout

    </lift:surround>
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another difference between custom dispatch and Views is that the NodeSeq
 returned from the view method is processed for template tags including
 
\family typewriter
surrounds
\family default
 and 
\family typewriter
includes
\family default
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Confirm this!
\end_layout

\end_inset

, just like snippets.
 That means that you can use the full power of the templating system from
 within your View, as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

's 
\family typewriter
doEnumerate
\family default
 method.
\end_layout

\begin_layout Standard
Since you can choose to not include any of the pre-defined template XHTML,
 you generate Atom or RSS feeds using a View.
 Resources of that nature, such as XML responses, or JSON, or an image response,
 would most likely be handled by a View.
\end_layout

\begin_layout Section
URL Rewriting and Dispatch
\begin_inset CommandInset label
LatexCommand label
name "sec:URL-Rewriting"

\end_inset


\end_layout

\begin_layout Standard
Now that we've gone over Templates and Views and how the dispatching of
 a request to a Class.method works we can discuss how to intercept requests
 and handle them any way we want.
 URL rewriting is the mechanism that allows you to modify the incoming request
 so that it dispatches to a different URL.
 It can be used, among other things, to allow you to:
\end_layout

\begin_layout Itemize
Use user-friendly URLs like www.example.com/user/joe instead of www.example.com/admi
n/users/88
\end_layout

\begin_layout Itemize
Use short URLs instead of long, hard to remember ones, similar to tinyurl.com
\end_layout

\begin_layout Itemize
Use portions of the URL to determine how a particular snippet or view responds.
 For example, you could make it so that a user's profile is displayed via
 a URL like 
\family typewriter
http://someplace.com/user/derek
\family default
 instead of having the username sent as part of a query string.
\end_layout

\begin_layout Standard
The mechanism is fairly simple to set up.
 We need to write a function of type 
\family typewriter
PartialFunction[RewriteRequest,RewriteResponse]
\family default
 to determine if and how we want to rewrite particular requests.
 The simplest way to do this is with a match statement which will allow
 us to selectively match on some or all of the request information.
 It is important to understand that the Lift session is not created at the
 point when the rewrite functions run; that means that you generally can't
 set or access properties in the S object.
 RewriteRequest is a case object that contains three items: the parsed path,
 the request type and the original HttpServletRequest
\begin_inset Index
status collapsed

\begin_layout Plain Layout
HttpServletRequest
\end_layout

\end_inset

 object.
\end_layout

\begin_layout Standard
The parsed path of the request in a ParsePath
\begin_inset Index
status collapsed

\begin_layout Plain Layout
ParsePath
\end_layout

\end_inset

 case class instance.
 The ParsePath class contains
\end_layout

\begin_layout Enumerate
The parsed path as a List[String]
\end_layout

\begin_layout Enumerate
The suffix of the request (i.e.
 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

, etc)
\end_layout

\begin_layout Enumerate
Whether the path is absolute 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Clarification needed on what this means
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Whether the path ends in a slash (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
The latter three properties are useful only in specific circumstances, but
 the parsed path is what lets us work magic.
 The path of the request is defined as the parts of the URI between the
 context path and the query string.
 The following table shows examples of parsed paths for a Lift application
 under the 
\begin_inset Quotes eld
\end_inset

myapp
\begin_inset Quotes erd
\end_inset

 context path:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Requested URL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Parsed Path
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
http://foo.com/myapp/home?test_this=true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
http://foo.com/myapp/user/derek
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

derek
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
http://foo.com/myapp/view/item/14592
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

view
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

item
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

14592
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The RequestType basically maps to the five HTTP methods: GET, POST, HEAD,
 PUT and DELETE.
 These are represented by the corresponding GetRequest, PostRequest, etc
 case classes, with an UnknownRequest case class to cover anything strange.
\end_layout

\begin_layout Standard
The flexibility of Scala's matching system is what really makes this powerful.
 With matching on Lists in particular, we can match parts of the path and
 capture others.
 For instance, for our second example we'd like to rewrite the 
\begin_inset Quotes eld
\end_inset

/user/<username>
\begin_inset Quotes erd
\end_inset

 path so that it's handled by the 
\begin_inset Quotes eld
\end_inset

/viewUser
\begin_inset Quotes erd
\end_inset

 template
\begin_inset Note Note
status open

\begin_layout Plain Layout
Modify for PocketChange
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Simple rewrite example
\begin_inset CommandInset label
LatexCommand label
name "lst:Simple-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val rewriter = {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(ParsePath(user :: username :: Nil,_,_,_),_,_) => 
\end_layout

\begin_layout Plain Layout

       RewriteResponse(viewUser :: Nil, Map(username -> username))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The RewriteResponse
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RewriteResponse
\end_layout

\end_inset

 simply contains the new path to send and can also take a Map
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 that contains parameters that will be accessible via S.param
\begin_inset Index
status collapsed

\begin_layout Plain Layout
S.param
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
S
\end_layout

\end_inset

 in the snippet or view.
 As we stated before, the LiftSession (and therefore most of S) isn't available
 at this time, so the Map is the only way to pass information on to the
 rewritten location.
 Technically, a rewrite results in a 
\begin_inset Quotes eld
\end_inset

302 Moved Temporarily
\begin_inset Quotes erd
\end_inset

 result code that forwards the client to a new request.
 Because of that, even if you could set data in LiftSession or S it would
 disappear when the redirect occurs.
\end_layout

\begin_layout Standard
We can combine the ParsePath matching with the RequestType and HttpServletReques
t to be very specific with our matches.
 For example, if we wanted to support the DELETE HTTP verb for a RESTful
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RESTful
\end_layout

\end_inset

 interface through an existing template, we could redirect it like so:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Complex rewrite example
\begin_inset CommandInset label
LatexCommand label
name "lst:Complex-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val rewriter = {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(ParsePath(username :: Nil, _, _, _),
\end_layout

\begin_layout Plain Layout

                      DeleteRequest,
\end_layout

\begin_layout Plain Layout

                      httpreq) 
\end_layout

\begin_layout Plain Layout

                      if isMgmtSubnet(httpreq.getRemoteHost()) => 
\end_layout

\begin_layout Plain Layout

       RewriteResponse(deleteUser :: Nil, Map(username -> username))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We'll go into more detail about how you can use this in the following sections.
 In particular, SiteMap
\begin_inset Index
status collapsed

\begin_layout Plain Layout
SiteMap
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cross-ref
\end_layout

\end_inset

provides a mechanism for doing rewrites combined with menu entries.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ArchTags"

\end_inset

Tags
\end_layout

\begin_layout Subsection
surround 
\end_layout

\begin_layout Standard

\emph on
Example:
\family typewriter
\emph default
 <lift:surround with="template_name">children</lift:surround>
\end_layout

\begin_layout Standard
Surrounds the child nodes with a named template (located in the <app_root>/webap
p/templates-hidden).
 It is used to apply a unified template to all the pages in a site.
 
\end_layout

\begin_layout Standard
Demo example:<lift:surround with="default"> <b>Dude</b>...
 this is my page...
 but it'll appear in your browser in a template.
 </lift:surround> 
\end_layout

\begin_layout Standard
In the target template there must be a <lift:bind /> tag to indicate where
 the contents should be bound.
 Note that you can use multiple surround templates by adding them to the
 /templates-hidden directory.
 For example, you might want to have a separate template for your administrative
 pages.
 In that case, you might add that template as admin.html in the /templates-hidden
 directory and then call it from your other pages using:<lift:surround with="adm
in">page code here</lift:surround>
\end_layout

\begin_layout Standard
Notes: You cannot have a hidden template with the same name as a sub-directory
 of your webapp directory.
 For example, if you had an admin.html template in /templates-hidden, you
 could not also have an admin directory.
 
\end_layout

\begin_layout Subsection
snippet
\begin_inset CommandInset label
LatexCommand label
name "sub:snippet-tag"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Example:
\family typewriter
\emph default
 <lift:snippet form="METHOD" type="ClassName:method" multipart="true" />
\end_layout

\begin_layout Standard
The 
\family typewriter
form
\family default
 and 
\family typewriter
multipart
\family default
 attributes are optional.
 If 
\family typewriter
form
\family default
 is included the attribute options are 
\family typewriter
GET
\family default
 and 
\family typewriter
POST.

\family default
 The 
\family typewriter
type
\family default
 attribute resolves to the method call 
\family typewriter
ClassName.method
\family default
.
 The 
\family typewriter
multipart
\family default
 attribute is a boolean.
\end_layout

\begin_layout Standard
Demo example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet that generates a NodeSeq
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Entry {
\end_layout

\begin_layout Plain Layout

def add(xhtml: Group): NodeSeq =     
\end_layout

\begin_layout Plain Layout

  selectedUser.is.openOr(new User).toForm(Empty, saveUser _) ++ 
\end_layout

\begin_layout Plain Layout

  <tr>     
\end_layout

\begin_layout Plain Layout

    <td><a href="/simple/index.html">Cancel</a></td>     
\end_layout

\begin_layout Plain Layout

    <td><input type="submit" value="Create"/></td>     
\end_layout

\begin_layout Plain Layout

  </tr>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y ou could use this snippet in the following manner:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

<lift:Entry.add form="POST"/>
\end_layout

\begin_layout Plain Layout

or
\end_layout

\begin_layout Plain Layout

<lift:snippet type="Entry.add" form="POST" />
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet that generates Nodes to bind...
 TODO: Explain the difference better...
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Entry {
\end_layout

\begin_layout Plain Layout

  def showCount(in: NodeSeq): NodeSeq = {     
\end_layout

\begin_layout Plain Layout

    val attr: String = S.attr("name").openOr("N/A")     
\end_layout

\begin_layout Plain Layout

    val value = CountHolder.is(attr)
\end_layout

\begin_layout Plain Layout

    bind("count", in, "value" -> value, 
\end_layout

\begin_layout Plain Layout

      "incr" -> link("/count", () => CountHolder.is(attr) = value + 1, Text("++")
),     
\end_layout

\begin_layout Plain Layout

      "decr" -> link("/count", () => CountHolder.is(attr) = 0 max (value
 - 1), Text("--")))   
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You would then use this snippet like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

<lift:Entry.showCount>
\end_layout

\begin_layout Plain Layout

  Click this to increse the counter: <count:incr /><br />
\end_layout

\begin_layout Plain Layout

  Click this to decrease the counter: <count:decr />
\end_layout

\begin_layout Plain Layout

</lift:Entry.showCount>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
embed 
\end_layout

\begin_layout Standard

\emph on
Example:
\family typewriter
\emph default
 <lift:embed what="template" />
\end_layout

\begin_layout Standard
Uses: Allows you to embed a template within another template (or to access
 a template from a JsCmd such as SetHtml, ModalDialog, etc.)
\end_layout

\begin_layout Standard
Note that incoming requests that contain *-hidden in the request will not
 be serviced, but you can access templates in directories named *-hidden.
 So, you can put AJAX templates in /ajax-templates-hidden in webapps.
\end_layout

\begin_layout Standard
Also, lift's i18n support extends to templates as well, so you can specify
 "/ajax-templates-hidden/welcome" and lift will serve the appropriate localized
 template.
 For example, if the current locale is set to French Canadian lift will
 look for /ajax-templates-hidden/welcome_fr_CA.html, /ajax-templates-hidden/welco
me_fr.html, and /ajax-templates-hidden/welcome.html 
\end_layout

\begin_layout Standard
Demo example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Embedding Templates within Templates
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:embed what="/templates-hidden/supersecret-template"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<lift:embed what="/ajax-templates-hidden/welcome" />
\end_layout

\begin_layout Standard
<lift:embed what="/templates-hidden/ajax"/>
\end_layout

\begin_layout Standard
Caveats: JavaScript contained in templates rendered via JsCmd (sent in response
 to AJAX requests) will not be executed.
 This includes Comet Widgets.
 
\end_layout

\begin_layout Subsection
comet 
\end_layout

\begin_layout Standard

\emph on
Example:
\family typewriter
\emph default
 <lift:comet type="ClassName" name="optional"/>
\end_layout

\begin_layout Standard
Uses: Defines a block of the XML document that is to be con
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},language=Java,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Comet Html template
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<div class="widget">
\end_layout

\begin_layout Plain Layout

  <lift:comet type="Clock">Current Time: 
\end_layout

\begin_layout Plain Layout

    <clk:time>Missing Clock</clk:time>
\end_layout

\begin_layout Plain Layout

  </lift:comet>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Will turn into this after processing:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Comet as rendered in the browser
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<div style="text-align: center" class="widget">   
\end_layout

\begin_layout Plain Layout

<span id="LCHVVTE3H5CHZ31L1C2ZEQ_outer">     
\end_layout

\begin_layout Plain Layout

<span id="LCHVVTE3H5CHZ31L1C2ZEQ" lift:when="12">
\end_layout

\begin_layout Plain Layout

  Current Time: 
\end_layout

\begin_layout Plain Layout

  <span id="LCHVVTE3H5CHZ31L1C2ZEQ_timespan">Fri Nov 14 17:29:53 EST 2008</span>
     
\end_layout

\begin_layout Plain Layout

<script>     
\end_layout

\begin_layout Plain Layout

// <![CDATA[     /* JSON Func clk $$ F1226701773224999000_BBP */     
\end_layout

\begin_layout Plain Layout

function F1226701773224999000_BBP(obj) {
\end_layout

\begin_layout Plain Layout

  lift_ajaxHandler('F1226701773224999000_BBP='+ encodeURIComponent(JSON.stringify
(obj)), 
\end_layout

\begin_layout Plain Layout

  null, null);
\end_layout

\begin_layout Plain Layout

}     
\end_layout

\begin_layout Plain Layout

// ]]>     
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</span>
\end_layout

\begin_layout Plain Layout

<script>     
\end_layout

\begin_layout Plain Layout

// <![CDATA[     
\end_layout

\begin_layout Plain Layout

var destroy_LCHVVTE3H5CHZ31L1C2ZEQ = function() {}     
\end_layout

\begin_layout Plain Layout

// ]]>     
\end_layout

\begin_layout Plain Layout

</script>     
\end_layout

\begin_layout Plain Layout

</span>     
\end_layout

\begin_layout Plain Layout

</div>  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Caveats: if you have a <lift:comet /> tag and you're using the tag from
 within sending AJAX stuff back, things might not work well.
 
\end_layout

\begin_layout Standard
More in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset


\end_layout

\begin_layout Section
Snippets
\end_layout

\begin_layout Standard
A snippet method takes a single Scala.xml.NodeSeq
\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

 argument and is expected to return a NodeSeq.
 The argument passed to the method is the XML contents of the snippet tag;
 because Lift processes from the outside in, the contents are not processed
 by default before being passed to the snippet method.
 For our current example, we could simply have a method that looks like
 this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Hello World snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Hello-World-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Hello {
\end_layout

\begin_layout Plain Layout

  def world (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    Text("Hello, world!")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We simply return an XML Text node with our greeting.
 Note that the XML that a snippet returns is further processed from the
 outside in, so if your snippet instead looked like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Returning tags from a snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Returning-tags-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Hello {
\end_layout

\begin_layout Plain Layout

  def world (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    <p>{"Hello, "}<lift:User.name /></p>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the lift:User.name snippet will be processed as well after our snippet
 method returns.
 It is this hierarchical processing of template tags that makes Lift so
 flexible.
\end_layout

\begin_layout Subsection
Stateless Snippets
\end_layout

\begin_layout Standard
All of the above examples showed Stateless snippets, those that execute
 and render a block of XML and send it back to the broswer.
 The life This is the default type of snippet.
 
\end_layout

\begin_layout Subsection
Stateful Snippets
\end_layout

\begin_layout Standard
Lift also has a the concept of a stateful snippet.
 All of our previous examples, while simple, were stateless.
 That is to say, from request to request, there is no saved state on the
 server-side.
 Stateless snippets are useful in the sense that many requirements for a
 web applications need no state to be preserved as the user moves from page
 to page.
 There are a similar number of cases where we would like to preserve some
 state as the user navigates.
 For example, if you think about a graph that shows your spending for the
 last 3 months.
 You've changed the time span from the default 1 month to 3 months.
 Now you'd like to limit the exspense categories to show only 
\begin_inset Quotes eld
\end_inset

Food.
\begin_inset Quotes erd
\end_inset

 More than likely, you'll want the application to respect the change in
 time-span as well.
 This is a case where keeping a bit of state around will allow you to do
 this.
 The same StatefulSnippet instance is used across a given page rendering.
 If you use a StatefulSnippet to render a form, a hidden field is added
 to that form that causes the same instance to be used on the page that
 is the target of the form submission.
 
\end_layout

\begin_layout Standard
Below is an example of a stateful snippet that handles the above example.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Write and then steal from PocketChange
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Notes
\end_layout

\begin_layout Standard
There are a few things to mention about snippets that will help.
 If you define a snippet as 
\family typewriter
<lift:CSS />
\family default
 rather than 
\family typewriter
<lift:CSS.show /> 
\family default
Lift will look for the method named 
\family typewriter
render
\family default
 in the class 
\family typewriter
CSS
\family default
.
\end_layout

\begin_layout Section
Eager Eval
\end_layout

\begin_layout Standard
If you want the contents of a snippet tag to be processed 
\emph on
before
\emph default
 the snippet, then you would specify the 
\family typewriter
eager_eval
\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
Add index entry
\end_layout

\end_inset

 attribute on the tag:
\end_layout

\begin_layout LyX-Code
<lift:Hello.world eager_eval=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

>...</lift:Hello.world>
\end_layout

\begin_layout Standard
This is especially useful if you're using a 
\family typewriter
lift:embed
\family default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add index entry
\end_layout

\end_inset

tag; without the eager_eval attribute your snippet just sees the <lift:embed>
 tag, but with eager_eval set to true you can put 
\emph on
bindable
\emph default
 common snippet content into a single embedded template instead of copying
 it between templates.
 In addition to eager_eval, there are attributes such as 
\family typewriter
form
\family default
 and 
\family typewriter
multipart
\family default
 which we will cover in extensive detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:snippet-tag"

\end_inset

.
 
\end_layout

\begin_layout Section
Head Merge
\end_layout

\begin_layout Standard
Another feature of Lift's template processing is the ability to merge the
 HTML 
\family typewriter
head
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
head
\end_layout

\end_inset

 tag from within a template.
 In our example listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, notice that we've specified a 
\family typewriter
head
\family default
 tag inside the template.
 Without the head merge, this head tag would show up in the default template
 where our template gets bound.
 Lift is smart about this, though, and instead takes the contents of the
 head tag and merges it into the outer template's head tag.
 This means that you can use a surround tag to keep a uniform default template,
 but still change things like the title of the tag, add in scripts or special
 CSS, etc.
 For example, if you have a table in a page that you'd like to style with
 jQuery's TableSorter, you would add a Lift tag:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<lift:tohead><script src="/scripts/tablesorter.js" type="text/javascript"
 /></lift:tohead>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And just for this snippet, you'll import TableSorter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Better example: Head merge looks like it's gone...
 WARN - Snippet Failure: SnippetFailure(/index -> ParsePath(List(index),,true,fa
lse),Full(tohead),Class Not Found)
\end_layout

\end_inset


\end_layout

\begin_layout Section
SHtml
\end_layout

\begin_layout Standard
The SHtml object is where most of the form element methods are defined.
 If you browse through the source you'll see what convenience functions
 are defined.
 There are a lot so we won't list them here, but throughout the book you'll
 see them appear in the example application we're building.
\end_layout

\begin_layout Standard
Some of the functions are text, button, select, checkbox, there are a lot
 more helper functions, so take a look at the ScalaDocs and at net/liftweb/http/
SHtml.scala.
\end_layout

\begin_layout Standard
Here's a short snippet for generating a form:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add the tag in the template as well? Add the output that lift generates?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
SHtml Example - Snippet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ajax {
\end_layout

\begin_layout Plain Layout

  def addForm = {     
\end_layout

\begin_layout Plain Layout

    <div>
\end_layout

\begin_layout Plain Layout

     {SHtml.text("Date", println _)}      
\end_layout

\begin_layout Plain Layout

     {SHtml.textarea("Description", println _)}     
\end_layout

\begin_layout Plain Layout

     {SHtml.text("Tags", println _)}     
\end_layout

\begin_layout Plain Layout

     {SHtml.text("Value", println _)}     
\end_layout

\begin_layout Plain Layout

     {SHtml.submit("Submit", () => S.notice("Submitted"))}
\end_layout

\begin_layout Plain Layout

    </div>   
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the template would be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
SHtml Example - Template
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

  <lift:Ajax.addForm form="POST" />
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which generates the markup:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
SHtml Example - Generated Markup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<form method="post" action="/ajax">
\end_layout

\begin_layout Plain Layout

  <div>     
\end_layout

\begin_layout Plain Layout

    <input name="F1228357378876744000_D3J" type="text" value="Date" /><br
 />     
\end_layout

\begin_layout Plain Layout

    <textarea name="F1228357378876890000_GXL">Description</textarea><br
 />     
\end_layout

\begin_layout Plain Layout

    <input name="F1228357378876940000_BLK" type="text" value="Tags" /><br
 />     
\end_layout

\begin_layout Plain Layout

    <input name="F1228357378877015000_RED" type="text" value="Value" /><br
 />
\end_layout

\begin_layout Plain Layout

    <input name="F1228357378877116000_SZF" type="submit" value="Submit"
 /><br />     
\end_layout

\begin_layout Plain Layout

  </div>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\end_inset


\end_layout

\begin_layout Section
SiteMap
\end_layout

\begin_layout Standard
We're only going to touch on SiteMap here as we have a whole chapter dedicated
 to it due to it's size, but an introduction, we think, is required.
 
\end_layout

\begin_layout Standard
SiteMap has a number of roles and they all build off the main goal, which
 is acting as a URL whitelist, arbitrating a users access to resources.
 And because it acts like the gatekeeper of resources, it can automatically
 generate your menu items.
 SiteMap can use all of the URL rewriting methods we discussed above as
 well.
\end_layout

\begin_layout Standard
Take a look at the SiteMap chapter to get a better feel of what it can do.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reference???
\end_layout

\begin_layout Plain Layout
Sets up URL whitelisting
\end_layout

\begin_layout Plain Layout
Builds a menu with submenus
\end_layout

\begin_layout Plain Layout
URL rewriting
\end_layout

\begin_layout Plain Layout
When a request comes in, it is recursively re-written and query params are
 optionally extracted.
\end_layout

\begin_layout Plain Layout
The Menu generation is a freebie based on the URL access control
\end_layout

\begin_layout Plain Layout
We're mentioning it here briefly, as we have an entire chapter dedicated
 to SiteMap.
 It's worth touching on as it relates to most of what we just discussed.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We just gave you a detailed view of Lift's architecture.
 This is important material, so you'll want to understand it before moving
 on.
\end_layout

\end_body
\end_document
