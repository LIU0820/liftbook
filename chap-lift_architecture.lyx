#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Fundamentals
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-Architecture"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we will cover some of the fundamental aspects of writing
 a lift application, including the architecture of the Lift library and
 how it processes requests.
 We will cover the rendering pipeline in detail, and show you how you can
 add your own code to be a part of that processing.
 
\end_layout

\begin_layout Section
Entry into Lift
\begin_inset CommandInset label
LatexCommand label
name "sec:Entry-into-Lift"

\end_inset


\end_layout

\begin_layout Standard
The first step in Lift's request processing is intercepting the HTTP request.
 Originally, Lift used a 
\family typewriter
java.servlet.Servlet
\family default
 instance to process incoming requests.
 This was changed to use a 
\family typewriter
java.servlet.Filter
\family default
 instance
\begin_inset Foot
status open

\begin_layout Plain Layout
You can see the discussion on the Lift mailing list that lead to this change
 here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/dy9u9d
\end_layout

\end_inset


\end_layout

\end_inset

 because this allows the container to handle any requests that Lift does
 not (in particular, static content).
 The filter acts as a thin wrapper on top of the existing LiftServlet (which
 still does all of the work), so don't be confused when you look at the
 Lift API and see both classes (LiftFilter and LiftServlet).
 The main thing to remember is that your 
\family typewriter
web.xml
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
web.xml
\end_layout

\end_inset

 should specify the filter and not the servlet, as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:LiftFilter-setup-in-web.xml"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:LiftFilter-setup-in-web.xml"

\end_inset

LiftFilter Setup in web.xml
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="ISO-8859-1"?>
\end_layout

\begin_layout Plain Layout

<!DOCTYPE web-app
\end_layout

\begin_layout Plain Layout

  PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
\end_layout

\begin_layout Plain Layout

  "http://java.sun.com/j2ee/dtds/web-app_2_3.dtd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<web-app>
\end_layout

\begin_layout Plain Layout

  <filter>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <display-name>Lift Filter</display-name>
\end_layout

\begin_layout Plain Layout

    <description>The Filter that intercepts lift calls</description>
\end_layout

\begin_layout Plain Layout

    <filter-class>net.liftweb.http.LiftFilter</filter-class>
\end_layout

\begin_layout Plain Layout

  </filter>      
\end_layout

\begin_layout Plain Layout

  <filter-mapping>
\end_layout

\begin_layout Plain Layout

    <filter-name>LiftFilter</filter-name>
\end_layout

\begin_layout Plain Layout

    <url-pattern>/*</url-pattern>
\end_layout

\begin_layout Plain Layout

  </filter-mapping>
\end_layout

\begin_layout Plain Layout

</web-app>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A full 
\family typewriter
web.xml
\family default
 example is shown in Section 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:JPA-web.xml"

\end_inset

.
 In particular, the filter-mapping (lines 13-16) specifies that the Filter
 is responsible for everything.
 When the filter receives the request, it checks a set of rules to see if
 it can handle it.
 If the request is one that Lift handles, it passes it on to an internal
 LiftServlet instance for processing; otherwise, it chains the request and
 allows the container to handle it.
\end_layout

\begin_layout Section
A Note on Standard Imports
\end_layout

\begin_layout Standard
For the sake of saving space, the following import statements are assumed
 for all example code throughout the rest of the book:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Standard Import Statements
\begin_inset CommandInset label
LatexCommand label
name "lst:Standard-import-statements"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import _root_.net.liftweb.http._
\end_layout

\begin_layout Plain Layout

import S._
\end_layout

\begin_layout Plain Layout

import _root_.net.liftweb.util._
\end_layout

\begin_layout Plain Layout

import Helpers._
\end_layout

\begin_layout Plain Layout

import _root_.scala.xml._
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lift's Main Objects
\end_layout

\begin_layout Standard
Before we dive into Lift's fundamentals, we want to briefly discuss three
 objects you will use heavily in your Lift code.
 We'll be covering these in more detail later in this chapter and in further
 chapters, so feel free to skip ahead if you want more details.
\end_layout

\begin_layout Subsection
S object
\begin_inset CommandInset label
LatexCommand label
name "sub:S-object"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
net.liftweb.http.S
\family default
 object represents the state of the current request (according to David
 Pollak, 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 is for Stateful).
 As such, it is used to retrieve information about the request and modify
 information that is sent in the response.
 Among other things, it can be used for notices (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Message-Handling"

\end_inset

) , cookie management (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cookies"

\end_inset

), localization/internationalization (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Internationalization"

\end_inset

) and redirection (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset

).
\end_layout

\begin_layout Subsection
SHtml
\begin_inset CommandInset label
LatexCommand label
name "sub:SHtml"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
net.liftweb.http.SHtml
\family default
 object's main purpose is to define HTML generation functions, particularly
 those having to do with form elements.
 We cover forms in detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Forms-in-Lift"

\end_inset

).
 In addition to normal form elements, SHtml defines functions for AJAX and
 JSON form elements (Chapters 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Lift-and-Javascript"

\end_inset

, respectively).
\end_layout

\begin_layout Subsection
LiftRules
\end_layout

\begin_layout Standard
The 
\family typewriter
net.liftweb.http.LiftRules
\family default
 object is where the vast majority of Lift's global configuration is handled.
 Almost everything that is configurable about Lift is set up based on variables
 in LiftRules.
 We won't be covering LiftRules directly, but as we discuss each Lift mechanism
 we'll touch on the LiftRules variables and methods related to the configuration
 of that mechanism.
\end_layout

\begin_layout Section
Bootstrap
\begin_inset CommandInset label
LatexCommand label
name "sec:Bootstrap"

\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
Bootstrap
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When Lift starts up there are a number of things that you'll want to set
 up before any requests are processed.
 These things include setting up a SiteMap (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

), URL rewriting, custom dispatch, and classpath search.
 The Lift servlet looks for the bootstrap.liftweb.Boot
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Boot
\end_layout

\end_inset

 class and executes the boot method in the class.
 You can also specify your own Boot instance by using the 
\family typewriter
bootloader
\begin_inset Index
status open

\begin_layout Plain Layout

\family typewriter
bootloader
\end_layout

\end_inset


\family default
 init param for the LiftFilter as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Overriding-bootloader"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Overriding the Boot Loader Class
\begin_inset CommandInset label
LatexCommand label
name "lst:Overriding-bootloader"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<filter>
\end_layout

\begin_layout Plain Layout

  ...
 filter setup here ...
\end_layout

\begin_layout Plain Layout

  <init-param>     
\end_layout

\begin_layout Plain Layout

    <param-name>bootloader</param-name>
\end_layout

\begin_layout Plain Layout

    <param-value>foo.bar.baz.MyBoot</param-value>
\end_layout

\begin_layout Plain Layout

  </init-param> 
\end_layout

\begin_layout Plain Layout

</filter>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Your MyBoot class must subclass Bootable
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.Bootable
\end_layout

\end_inset

 and implement the 
\family typewriter
boot
\family default
 method.
 The boot method will only be run once, so you can place any initialization
 calls for other libraries here as well.
\end_layout

\begin_layout Subsection
A Note on LiftRules
\end_layout

\begin_layout Standard
Most of your configuration in your Boot class will be done via the LiftRules
\begin_inset Index
status open

\begin_layout Plain Layout
LiftRules
\end_layout

\end_inset

 object.
 LiftRules serves as a common location for almost everything configurable
 about Lift.
 Because LiftRules spans such a diverse range of functionality, we're not
 going to cover it directly; rather, we will mention it as we discuss each
 of the aspects that it controls.
\end_layout

\begin_layout Subsection
Class Resolution
\begin_inset CommandInset label
LatexCommand label
name "sub:Class-Resolution"

\end_inset


\end_layout

\begin_layout Standard
As part of our discussion of the Boot class, it's also important to explain
 how Lift determines where to find classes for Views and Snippet rendering.
 The 
\family typewriter
LiftRules.addToPackages
\family default
 method tells lift which Scala packages to look in for a given class.
 Lift has implicit extensions to the paths you enter: in particular, if
 you tell Lift to use the 
\family typewriter
com.pocketchangeapp
\family default
 package, Lift will look for View classes under 
\family typewriter
com.pocketchangeapp.view
\family default
 and will look for Snippet classes under 
\family typewriter
com.pocketchangeapp.snippet
\family default
.
 The 
\family typewriter
addToPackages
\family default
 method should almost always be executed in your Boot class.
 A minimal Boot class would look like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Minimal Boot Class
\begin_inset CommandInset label
LatexCommand label
name "lst:Minimal-Boot-class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    LiftRules.addToPackages("com.pocketchangeapp")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Rendering Process
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Rendering-Process"

\end_inset


\end_layout

\begin_layout Standard
Before we move on, we want to give a brief overview of the processes by
 which Lift transforms a request into a response (AKA the rendering pipeline
\begin_inset Index
status open

\begin_layout Plain Layout
rendering pipeline
\end_layout

\end_inset

).
 We're only going to touch on the major points here.
 A much more detailed tour of the pipeline is given in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

.
 The steps that we'll cover in this chapter are:
\end_layout

\begin_layout Enumerate
URL rewriting.
 This is covered in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:URL-Rewriting"

\end_inset

.
\end_layout

\begin_layout Enumerate
Executing any matching custom dispatch functions.
 This is covered in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

.
\end_layout

\begin_layout Enumerate
Locating the template to use for the request.
 This is handled via three mechanisms:
\end_layout

\begin_deeper
\begin_layout Enumerate
Checking the 
\family typewriter
LiftRules.viewDispatch
\family default
 
\family typewriter
RulesSeq
\family default
 to see if any custom dispatch rules have been defined.
 We cover custom view dispatch in Section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Request/Response-Lifecycle"

\end_inset

.
\end_layout

\begin_layout Enumerate
If there is no matching 
\family typewriter
viewDispatch
\family default
, locating a template that matches and using it.
 We'll cover templates, and how they're located, in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Templates"

\end_inset

.
\end_layout

\begin_layout Enumerate
If no templates match, attempting to locate a view based on matching a class
 name and method dispatch.
 We'll cover views in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Views"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
In our experience views and templates will cover most of your needs, but
 as we'll demonstrate in later chapters, Lift has plenty of ways to customize
 request handling.
\end_layout

\begin_layout Standard
The following sections cover each aspect of the rendering steps defined
 above, but in order of decreasing frequency of use, rather than the order
 in which they occur in the pipeline.
 We'll start with Templates, because those are by far the most common mechanism
 for rendering content in Lift.
 Next, we'll cover Views, which are essentially programmatic templates.
 Then we'll examine the various Lift tags for Template and View content.
 After that, we'll take an in-depth look at Snippets, which are the bridge
 between your Template (XML) content and your Scala code.
 Finally, we'll cover how you can provide highly customized processing of
 your requests using URL rewriting and custom dispatch functions.
 
\end_layout

\begin_layout Section
Templates
\begin_inset CommandInset label
LatexCommand label
name "sec:Templates"

\end_inset


\end_layout

\begin_layout Standard
Templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Templates
\end_layout

\end_inset

 form the backbone of Lift's flexibility and power.
 A template is an XML file that contains Lift-specific tags, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ArchTags"

\end_inset

, as well as whatever content you want returned to the user.
 Lift includes built-in Tags for specific actions.
 These are of the form 
\family typewriter
<lift:snippet_name/>
\family default
.
 Lift also allows you to create your own tags, which are called 
\emph on
snippets
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
snippets
\end_layout

\end_inset

 (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

).
 These user-defined tags are linked directly to Scala methods and these
 methods can process the XML contents of the snippet tag, or can generate
 their own content from scratch.
 A simple template is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Sample Template
\begin_inset CommandInset label
LatexCommand label
name "lst:Sample-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <head><title>Hello!</title></head>
\end_layout

\begin_layout Plain Layout

  <lift:Hello.world />
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the tags that are of the form 
\family typewriter
<lift:name>
\family default
 which in this case are 
\family typewriter
<lift:surround>
\family default
 and 
\family typewriter
<lift:snippet>.
 
\family default
These are two examples of Lift-specific tags.
 We'll discuss all of the tags that users will use in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ArchTags"

\end_inset

, but let's briefly discuss the two shown here.
 We use the built-in 
\family typewriter
<lift:surround>
\begin_inset Index
status collapsed

\begin_layout Plain Layout
lift:surround
\end_layout

\end_inset


\family default
 tag (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:surround-tag"

\end_inset

) to make Lift embed our current template inside the 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 template.
 We also use 
\family typewriter
<lift:snippet>
\family default
 tag (aliased to Hello.world) to execute a snippet that we defined.
 In this instance, we execute the method 
\family typewriter
world
\family default
 in the class 
\family typewriter
Hello 
\family default
to generate some content.
 
\end_layout

\begin_layout Standard
During template processing, Lift tries to locate a file in the template
 directory tree (typically in a WAR archive) that matches the request.
 Lift tries several suffixes (html, xhtml, htm, and no suffix) and also
 tries to match based on the client's Accept-Language header.
 The pattern Lift uses is:
\end_layout

\begin_layout LyX-Code
<path to template>[_<language>][.<suffix>]
\end_layout

\begin_layout Standard
Because Lift will implicitly search for suffixes, it's best to leave the
 suffix off of your links within the web app.
 If you have a link with an href of 
\family typewriter
/test/template.xhtml
\family default
, it will only match that file, but if you use 
\family typewriter
/test/template
\family default
 for the href and you have the following templates in your web app:
\end_layout

\begin_layout Itemize

\family typewriter
/test/template.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_es-ES.xhtml
\end_layout

\begin_layout Itemize

\family typewriter
/test/template_ja.xhtml
\end_layout

\begin_layout Standard
then Lift will use the appropriate template based on the user's requested
 language if a corresponding template is available.
 For more information regarding internationalization please see Appendix
 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Internationalization"

\end_inset

.
 In addition to normal templates, your application can make use of hidden
 templates
\begin_inset Index
status collapsed

\begin_layout Plain Layout
hidden templates
\end_layout

\end_inset

.
 These are templates that are located under the 
\family typewriter
/templates-hidden
\family default
 directory of your web app.
 Technically, Lift hides files in any directory ending in 
\begin_inset Quotes eld
\end_inset

-hidden
\begin_inset Quotes erd
\end_inset

, but templates-hidden is somewhat of a de facto standard.
 Like the 
\family typewriter
WEB-XML
\family default
 directory, the contents cannot be directly requested by clients.
 They can, however, be used by other templates through mechanisms such as
 the 
\family typewriter
<lift:surround>
\family default
 and 
\family typewriter
<lift:embed>
\family default
 tags (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:embed-tag"

\end_inset

).
 If Lift cannot locate an appropriate template based on the request path
 then it will return a 404 to the user.
\end_layout

\begin_layout Standard
Once Lift has located the correct template, the next step is to process
 the contents.
 It is important to understand that Lift processes XML tags recursively,
 from the outermost tag to the innermost tag.
 That means that in our example Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, the surround tag gets processed first.
 In this case the surround loads the default template and embeds our content
 at the appropriate location.
 The next tag to be processed is the 
\family typewriter
<lift:Hello.world/>
\family default
 snippet.
 This tag is essentially an alias for the lift:snippet tag (specifically,
 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello:world
\begin_inset Quotes erd
\end_inset

>
\family default
) , and will locate the Hello class and execute the world method on it.
 If you omit the 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

 part of the type and only specify the class (
\family typewriter
<lift:Hello>
\family default
 or 
\family typewriter
<lift:snippet type=
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

>
\family default
), then Lift will attempt to call the 
\family typewriter
render
\family default
 method of the class.
\end_layout

\begin_layout Standard
To give a more complex example that illustrates the order of tag processing,
 consider Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:A-Recursive-Tag"

\end_inset

.
 In this example we have several nested snippet tags, starting with 
\family typewriter
<A.snippet />
\family default
.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Recursive-Tag-Snippets"

\end_inset

 shows the backing code for this example.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Recursive Tag Processing Example
\begin_inset CommandInset label
LatexCommand label
name "lst:A-Recursive-Tag"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:A.snippet>
\end_layout

\begin_layout Plain Layout

  <p>Hello, <A:name />!</p>
\end_layout

\begin_layout Plain Layout

  <p>
\end_layout

\begin_layout Plain Layout

    <lift:B.snippet>
\end_layout

\begin_layout Plain Layout

      <B:title />
\end_layout

\begin_layout Plain Layout

      <lift:C.snippet />
\end_layout

\begin_layout Plain Layout

    </lift:B.snippet>
\end_layout

\begin_layout Plain Layout

  </p>
\end_layout

\begin_layout Plain Layout

</lift:A.snippet>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first thing that happens is that the contents of the 
\family typewriter
<lift:A.snippet>
\family default
 tag are passed as a 
\family typewriter
NodeSeq
\family default
 argument to the 
\family typewriter
A.snippet
\family default
 method.
 In the 
\family typewriter
A.snippet
\family default
 method we bind
\begin_inset Index
status open

\begin_layout Plain Layout
bind
\end_layout

\end_inset

, or replace, the 
\family typewriter
<A:name />
\family default
 tag with an XML Text node of 
\begin_inset Quotes eld
\end_inset

The A snippet
\begin_inset Quotes erd
\end_inset

.
 The rest of the input is left as-is and is returned to Lift for more processing.
 Lift examines the returned 
\family typewriter
NodeSeq
\family default
 for more lift tags and finds the 
\family typewriter
<lift:B.snippet>
\family default
 tag.
 The contents of the 
\family typewriter
<lift:B.snippet>
\family default
 tag are passed as a 
\family typewriter
NodeSeq
\family default
 argument to the 
\family typewriter
B.snippet
\family default
 method, where the 
\family typewriter
<B.title />
\family default
 tag is bound with the XML Text node 
\begin_inset Quotes eld
\end_inset

The B snippet
\begin_inset Quotes erd
\end_inset

.
 The rest of the contents are left unchanged and the transformed 
\family typewriter
NodeSeq
\family default
 is returned to Lift, which scans for and finds the 
\family typewriter
<lift:C.snippet />
\family default
 tag.
 Since there are no child elements for the 
\family typewriter
<lift:C.snippet />
\family default
 tag, the 
\family typewriter
C.snippet
\family default
 method is invoked with an empty 
\family typewriter
NodeSeq
\family default
 and the 
\family typewriter
C.snippet
\family default
 returns the Text node 
\begin_inset Quotes eld
\end_inset

The C snippet
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
The Recursive Tag Snippets Code
\begin_inset CommandInset label
LatexCommand label
name "lst:Recursive-Tag-Snippets"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

...
 standard Lift imports ...
\end_layout

\begin_layout Plain Layout

class A {
\end_layout

\begin_layout Plain Layout

  def snippet (xhtml : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    bind("A", xhtml, "name" -> Text("The A snippet"))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class B {
\end_layout

\begin_layout Plain Layout

  def snippet (xhtml : NodeSeq) : NodeSeq =
\end_layout

\begin_layout Plain Layout

    bind("B", xhtml, "title" -> Text("The B snippet"))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class C {
\end_layout

\begin_layout Plain Layout

  def snippet (xhtml : NodeSeq) : NodeSeq = Text("The C snippet")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While the contents of the 
\family typewriter
A.snippet
\family default
 tag are passed to the 
\family typewriter
A.snippet
\family default
 method, there's no requirement that the contents are actually used.
 For example, consider what would happen if we swapped the B and C snippet
 tags in our template, as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:The-Swapped-Recursive"

\end_inset

.
 In this example, the 
\family typewriter
C.snippet
\family default
 method is called before the 
\family typewriter
B.snippet
\family default
 method.
 Since our 
\family typewriter
C.snippet
\family default
 method returns straight XML that doesn't contain the B snippet tag, the
 B snippet will never be executed! We'll cover how the 
\family typewriter
eager_eval
\family default
 tag attribute can be used to reverse this behavior in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eager-Eval"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
The Swapped Recursive Snippet Template
\begin_inset CommandInset label
LatexCommand label
name "lst:The-Swapped-Recursive"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:A.snippet>
\end_layout

\begin_layout Plain Layout

  <p>Hello, <A:name />!</p>
\end_layout

\begin_layout Plain Layout

  <p>
\end_layout

\begin_layout Plain Layout

    <lift:C.snippet>
\end_layout

\begin_layout Plain Layout

      <lift:B.snippet>
\end_layout

\begin_layout Plain Layout

        <B:title />
\end_layout

\begin_layout Plain Layout

      </lift:B.snippet>
\end_layout

\begin_layout Plain Layout

    </lift:C.snippet>
\end_layout

\begin_layout Plain Layout

  </p>
\end_layout

\begin_layout Plain Layout

</lift:A.snippet>
\end_layout

\begin_layout Plain Layout

<!-- After the A and C snippets have been processed: -->
\end_layout

\begin_layout Plain Layout

<p>Hello, The A snippet</p>
\end_layout

\begin_layout Plain Layout

<p>The C snippet</p>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, templates are a nice way of setting up your layout and then
 writing a few methods to fill in the XML fragments that make up your web
 applications.
 They provide a simple way to generate a uniform look for your site, particularl
y if you assemble your templates using the surround and embed tags.
 If you'd like more control or don't need a template for a certain section,
 you'll want to use a View, which is discussed in the next section below.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not sure if we actually want this here:
\end_layout

\begin_layout Plain Layout

\size small
If you inspect the API documentation closely, you might be tempted to manually
 load a template (from a snippet for example) using 
\family typewriter
LiftSession.processSurroundAndInclude
\family default
.
 Even though Lift will merge your templates and invoke snippets if you use
 this method, we 
\emph on
strongly
\emph default
 recommend against this technique.
 The basic issue is that Lift's function mappings are not properly updated
 because you're running this method 
\emph on
outside
\emph default
 of the normal rendering pipeline.
 That means that whatever callbacks you have in the page you'd like to return
 won't get called when the page is submitted.
 In general, we've never found a case where we required this functionality;
 usually you can accomplish the same thing by using a RedirectResponse and
 attaching your state to it via the Map parameter.
 For more details, see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Views
\begin_inset CommandInset label
LatexCommand label
name "sec:Views"

\end_inset


\end_layout

\begin_layout Standard
We just discussed Templates and saw that through a combination of an XML
 file, Lift tags, and Scala code we can respond to requests made by a user.
 You can also generate a response entirely in code using a View.
 
\end_layout

\begin_layout Standard
Views
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Views
\end_layout

\end_inset

 are generally used as implicitly defined custom dispatch methods.
 We'll cover explicit custom dispatch in more depth in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

.
 A view function is a normal Scala method of type 
\begin_inset Formula $()\Rightarrow scala.xml.NodeSeq$
\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

.
 As we showed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-Rendering-Process"

\end_inset

, there are two ways that a View can be invoked.
 The first is by defining a partial function for 
\family typewriter
LiftRules.viewDispatch
\family default
.
 This allows you to dispatch to a view for any arbitrary request path, but
 it is usually overkill for most use cases.
 The second way that a View can be invoked is that if the first element
 of the request path matches the class name of the View, then the second
 element is used to lookup the View function depending on what trait the
 View class implements.
 The following paragraph will make this clearer.
\end_layout

\begin_layout Standard
There are two traits that you can use when implementing a view class: one
 is the 
\family typewriter
LiftView
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
LiftView
\end_layout

\end_inset

 trait, the other is the 
\family typewriter
InsecureLiftView
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
InsecureLiftView
\end_layout

\end_inset

 trait
\begin_inset Foot
status open

\begin_layout Plain Layout
Both can be found under the net.liftweb.http package.
\end_layout

\end_inset

.
 As you may be able to tell from the names, we would prefer that you extend
 the 
\family typewriter
LiftView
\family default
 trait.
 The 
\family typewriter
InsecureLiftView
\family default
 determines method dispatch by turning a request path into a class and method
 name.
 For example, if we have a path 
\family typewriter
/MyStuff/enumerate
\family default
, then Lift will look for a class called 
\family typewriter
MyStuff
\family default
 in the view subpackage (class resolution is covered in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Class-Resolution"

\end_inset

) and if it finds 
\family typewriter
MyStuff
\family default
 and it has a method called 
\family typewriter
enumerate
\family default
, then Lift will execute the 
\family typewriter
enumerate
\family default
 method and return its result to the user.
 The main concern here is that Lift uses reflection
\begin_inset Index
status collapsed

\begin_layout Plain Layout
reflection
\end_layout

\end_inset

 to get the method with 
\family typewriter
InsecureLiftView
\family default
, so it can access any method in the class, even ones that you don't intend
 to make public.
 A better way to invoke a View is to extend the 
\family typewriter
LiftView
\family default
 trait, which defines a dispatch partial function.
 This dispatch function maps a string (the 
\begin_inset Quotes eld
\end_inset

method name
\begin_inset Quotes erd
\end_inset

) to a function that will return a 
\family typewriter
NodeSeq
\family default
.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

 shows a custom 
\family typewriter
LiftView
\family default
 class where the path 
\family typewriter
/ExpenseView/enumerate
\family default
 will map to the 
\family typewriter
ExpenseView.doEnumerate
\family default
 method.
 If a user attempts to go to 
\family typewriter
/ExpenseView/privateMethod
\family default
 they'll get a 404 because 
\family typewriter
privateMethod
\family default
 is not defined in the dispatch method.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This should be a pocketchange example
\end_layout

\end_inset

Dispatch in LiftView
\begin_inset CommandInset label
LatexCommand label
name "lst:Dispatch-in-LiftView"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class ExpenseView extends LiftView {
\end_layout

\begin_layout Plain Layout

  override def dispatch = {
\end_layout

\begin_layout Plain Layout

    case "enumerate" => doEnumerate _
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def doEnumerate () : NodeSeq = {  
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    <lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

     { expenseItems.toTable }
\end_layout

\begin_layout Plain Layout

    </lift:surround>
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another difference between custom dispatch and Views is that the 
\family typewriter
NodeSeq
\family default
 returned from the View method is processed for template tags including
 
\family typewriter
surrounds
\family default
 and 
\family typewriter
includes
\family default
, just as it would be for a snippet.
 Dispatch methods, on the other hand, expect a 
\family typewriter
LiftResponse
\family default
.
 That means that you can use the full power of the templating system from
 within your View, as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Dispatch-in-LiftView"

\end_inset

's 
\family typewriter
doEnumerate
\family default
 method.
\end_layout

\begin_layout Standard
Since you can choose not to include any of the pre-defined template XHTML,
 you can easily generate any XML-based content, such as Atom or RSS feeds,
 using a View.
\end_layout

\begin_layout Section
Tags
\begin_inset CommandInset label
LatexCommand label
name "sec:ArchTags"

\end_inset


\end_layout

\begin_layout Standard
In the earlier sections on Templates and Views we briefly touched on some
 of Lift's built-in tags, namely, 
\family typewriter
snippet
\family default
 and 
\family typewriter
surround
\family default
.
 In this section we'll go into more detail on those tags as well as cover
 the rest of Lift's tags.
\end_layout

\begin_layout Subsection
snippet
\begin_inset CommandInset label
LatexCommand label
name "sub:snippet-tag"

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
Usage: <lift:snippet form="GET/POST" type="Class:method" 
\end_layout

\begin_layout LyX-Code

\family typewriter
           multipart="true/false" />
\end_layout

\begin_layout LyX-Code
       <lift:Class.method form=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 multipart=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout LyX-Code
       <lift:Class form=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 multipart=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Standard
The snippet tag is the workhorse of Lift.
 In our experience, most of the functionality of your web apps will be handled
 via snippets.
 They're so important that we're going to cover their mechanism separately
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

.
 In this section, however, we'll cover the specifics of the snippet tag.
\end_layout

\begin_layout Standard
The most important part of the tag is the class and method definition.
 There are three ways to specify this:
\end_layout

\begin_layout Enumerate
Via the type attribute.
 The value should be 
\begin_inset Quotes eld
\end_inset


\family typewriter
ClassName
\family default
:
\family typewriter
method
\family default

\begin_inset Quotes erd
\end_inset

 for the particular snippet method you want to have handle the tag
\end_layout

\begin_layout Enumerate
Via a tag suffix of 
\family typewriter
Class.method
\family default
.
 This is the same as specifying the type=
\begin_inset Quotes erd
\end_inset

Class:method
\begin_inset Quotes erd
\end_inset

 attribute
\end_layout

\begin_layout Enumerate
Via a tag suffix of just 
\family typewriter
Class
\family default
.
 This will use the 
\family typewriter
render
\family default
 method on the specified class to handle the tag
\end_layout

\begin_layout Standard
Classes are resolved as specified in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Class-Resolution"

\end_inset

.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Snippet-tag-equivalence"

\end_inset

 shows three equivalent snippet tags.
 Note: these are only equivalent because the method name is 
\begin_inset Quotes eld
\end_inset

render.
\begin_inset Quotes erd
\end_inset

 If we had chose a different method, e.g., 
\begin_inset Quotes eld
\end_inset

list,
\begin_inset Quotes erd
\end_inset

 then the third example below will still call a 
\begin_inset Quotes eld
\end_inset

render
\begin_inset Quotes erd
\end_inset

 method.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet Tag Equivalence
\begin_inset CommandInset label
LatexCommand label
name "lst:Snippet-tag-equivalence"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:snippet type="MyClass:render" />
\end_layout

\begin_layout Plain Layout

<lift:MyClass.render />
\end_layout

\begin_layout Plain Layout

<lift:MyClass />
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
form
\family default
 and 
\family typewriter
multipart
\family default
 attributes are optional.
 If 
\family typewriter
form
\family default
 is included then an appropriate form tag will be emitted into the XHTML
 using the specified submission method
\family typewriter
 
\family default
(
\family typewriter
POST 
\family default
or
\family typewriter
 GET
\family default
).

\family typewriter
 
\family default
The 
\family typewriter
multipart
\family default
 attribute is a boolean, and specifies whether a generated form tag should
 be set to use multipart form submission.
 This is most typically used for file uploads (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:File-Uploads"

\end_inset

).
\end_layout

\begin_layout Subsection
surround
\begin_inset CommandInset label
LatexCommand label
name "sub:surround-tag"

\end_inset


\end_layout

\begin_layout LyX-Code
Usage:
\family typewriter
 <lift:surround with="template_name" at=
\begin_inset Quotes erd
\end_inset

binding
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\family typewriter
         children
\end_layout

\begin_layout LyX-Code

\family typewriter
       </lift:surround>
\end_layout

\begin_layout Standard
The 
\family typewriter
surround
\family default
 tag surrounds the child nodes with the named template.
 The child nodes are inserted into the named template at the binding point
 specified by the 
\family typewriter
at
\family default
 parameter (we'll cover the bind tag in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:bind-tag"

\end_inset

).
 Typically, templates that will be used to surround other templates are
 incomplete by themselves, so we usually store them in the 
\family typewriter
<app
\begin_inset space ~
\end_inset

root>/templates-hidden
\family default
 subdirectory so that they can't be accessed directly.
 Having said that, 
\begin_inset Quotes eld
\end_inset

incomplete
\begin_inset Quotes erd
\end_inset

 templates may be placed in any directory that templates would normally
 go in.
 The most common usage of 
\family typewriter
surround
\family default
 is to permit you to use a 
\begin_inset Quotes eld
\end_inset

master
\begin_inset Quotes erd
\end_inset

 template for your site CSS, menu, etc.
 An example use of 
\family typewriter
surround
\family default
 is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Surrounding-your-page"

\end_inset

.
 We'll show the counterpart master template in the section on the bind tag.
 Note also that the surrounding template name can be either a fully-qualified
 path (i.e.
 
\begin_inset Quotes eld
\end_inset

/templates-hidden/default
\begin_inset Quotes erd
\end_inset

), or just the base filename (
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

).
 In the latter case, Lift will search all subdirectories of the app root
 for the template.
 By default, Lift will use 
\begin_inset Quotes eld
\end_inset

/templates-hidden/default
\begin_inset Quotes erd
\end_inset

 if you don't specify a 
\family typewriter
with
\family default
 attribute, so Listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Surrounding-your-page"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Surrounding-with-the-default-template"

\end_inset

 are equivalent.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Surrounding Your Page
\begin_inset CommandInset label
LatexCommand label
name "lst:Surrounding-your-page"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <p>Welcome to PocketChange!</p>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Surrounding with the default template
\begin_inset CommandInset label
LatexCommand label
name "lst:Surrounding-with-the-default-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround at="content">
\end_layout

\begin_layout Plain Layout

  <p>Welcome to PocketChange!</p>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that you can use multiple surround templates for different functionality,
 and surrounds can be nested.
 For example, you might want to have a separate template for your administrative
 pages that adds a menu to your default template.
 In that case, your 
\family typewriter
admin.html
\family default
 could look like Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Adding-an-Admin-menu"

\end_inset

.
 As you can see, we've named our bind point in the admin template 
\begin_inset Quotes eld
\end_inset

content
\begin_inset Quotes erd
\end_inset

 so that we keep things consistent for the rest of our templates.
 So if, for example, we were going to nest the template in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Surrounding-your-page"

\end_inset

 above into the 
\family typewriter
admin.html
\family default
 template in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Adding-an-Admin-menu"

\end_inset

, all we'd need to do is change it's 
\family typewriter
with
\family default
 attribute from 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

admin.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Adding an Admin Menu
\begin_inset CommandInset label
LatexCommand label
name "lst:Adding-an-Admin-menu"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <lift:Admin.menu />
\end_layout

\begin_layout Plain Layout

  <lift:bind name="content" />
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size small
You cannot have a hidden template with the same name as a sub-directory
 of your webapp directory.
 For example, if you had an admin.html template in /templates-hidden, you
 could not also have an admin directory.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
bind
\begin_inset CommandInset label
LatexCommand label
name "sub:bind-tag"

\end_inset


\end_layout

\begin_layout LyX-Code
Usage: <lift:bind name=
\begin_inset Quotes erd
\end_inset

binding_name
\begin_inset Quotes erd
\end_inset

 />
\end_layout

\begin_layout Standard
The bind tag is the counterpart to the surround tag: it specifies where
 in the 
\begin_inset Quotes eld
\end_inset

surrounding
\begin_inset Quotes erd
\end_inset

 template the content will be placed.
 An example is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Binding-in-Templates"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Binding in Templates
\begin_inset CommandInset label
LatexCommand label
name "lst:Binding-in-Templates"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

  <body>
\end_layout

\begin_layout Plain Layout

    <lift:bind name="content" />
\end_layout

\begin_layout Plain Layout

  </body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
embed
\begin_inset CommandInset label
LatexCommand label
name "sub:embed-tag"

\end_inset

 
\end_layout

\begin_layout LyX-Code
Usage:
\family typewriter
 <lift:embed what="template_name" />
\end_layout

\begin_layout Standard
The 
\family typewriter
embed
\family default
 tag allows you to embed a template within another template.
 This can be used to assemble your pages from multiple smaller templates,
 and it also allows you to access templates from JavaScript commands (Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Lift-and-Javascript"

\end_inset

).
 As with the 
\family typewriter
surround
\family default
 tag, the template name can be either the base filename or a fully-qualified
 path.
\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size small
Note that if you use the embed tag to access templates from within a JsCmd
 (typically an AJAX call), any JavaScript in the embedded template won't
 be executed.
 This includes, but is not limited to, Comet widgets.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
comet 
\end_layout

\begin_layout LyX-Code

\family typewriter
Usage: <lift:comet type="ClassName" name=
\begin_inset Quotes erd
\end_inset

optional
\begin_inset Quotes erd
\end_inset

/>
\end_layout

\begin_layout Standard
The 
\family typewriter
comet
\family default
 tag embeds a Comet actor into your page.
 The class of the Comet actor is specified by the 
\family typewriter
type
\family default
 attribute.
 The 
\family typewriter
name
\family default
 attribute tells Lift to create a unique instance of the Comet actor; for
 example, you could have one Comet actor for site updates and another for
 admin messages.
 The contents of the tag are used by the Comet actor to bind a response.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Ledger-Entry-Comet"

\end_inset

 shows an example of a Comet binding that displays expense entries as they're
 added.
 Comet is covered in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},language=Java,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Account Entry Comet
\begin_inset CommandInset label
LatexCommand label
name "lst:Ledger-Entry-Comet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<div class="accountUpdates">
\end_layout

\begin_layout Plain Layout

  <lift:comet type="AccountMonitor">
\end_layout

\begin_layout Plain Layout

    <ul><account:entries>
\end_layout

\begin_layout Plain Layout

      <li><entry:time/> : <entry:user /> : <entry:amount /></li>
\end_layout

\begin_layout Plain Layout

    </account:entries></ul>
\end_layout

\begin_layout Plain Layout

  </lift:comet>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in the 
\family typewriter
embed
\family default
 tag documentation, mixing Comet with AJAX responses can be a bit tricky
 due to the embedded JavaScript that Comet uses.
\end_layout

\begin_layout Section
Head Merge
\begin_inset CommandInset label
LatexCommand label
name "sec:Head-Merge"

\end_inset


\end_layout

\begin_layout Standard
Another feature of Lift's template processing is the ability to merge the
 HTML 
\family typewriter
head
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
head
\end_layout

\end_inset

 element in a template with the 
\family typewriter
head
\family default
 element in the surrounding template.
 In our example, Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Sample-template"

\end_inset

, notice that we've specified a 
\family typewriter
head
\family default
 tag inside the template.
 Without the head merge, this 
\family typewriter
head
\family default
 tag would show up in the default template where our template gets bound.
 Lift is smart about this, though, and instead takes the content of the
 
\family typewriter
head
\family default
 element and merges it into the outer template's 
\family typewriter
head
\family default
 element.
 This means that you can use a 
\family typewriter
surround
\family default
 tag to keep a uniform default template, but still do things such as changing
 the title of the page, adding scripts or special CSS, etc.
 For example, if you have a table in a page that you'd like to style with
 jQuery's TableSorter, you could add a head element to insert the appropriate
 script:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Using Head Merge
\begin_inset CommandInset label
LatexCommand label
name "lst:Using-Head-Merge"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="foo">
\end_layout

\begin_layout Plain Layout

<head><script src="/scripts/tablesorter.js" type="text/javascript" /><head>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this manner, you'll import TableSorter for this template alone.
\end_layout

\begin_layout Section
Notices, Warnings, and Error Messages
\begin_inset CommandInset label
LatexCommand label
name "sub:Notices/Warnings/Errors-messages"

\end_inset


\end_layout

\begin_layout Standard
Feedback to the user is important.
 The application must be able to notify the user of errors, warn the user
 of potential problems, and notify the user when system status changes.
 Lift provides a unified model for such messages that can be used for static
 pages as well as for AJAX and Comet calls.
 We cover messaging support in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Message-Handling"

\end_inset

.
\end_layout

\begin_layout Section
Snippets
\begin_inset CommandInset label
LatexCommand label
name "sec:Snippets"

\end_inset


\end_layout

\begin_layout Standard
A snippet is a method that takes a single 
\family typewriter
scala.xml.NodeSeq
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
NodeSeq
\end_layout

\end_inset

 argument and is expected to return a 
\family typewriter
NodeSeq
\family default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note: Although Scala can often infer return types, it's important to explicitly
 specify the return type of your snippet methods as 
\family typewriter
NodeSeq
\family default
.
 Failure to do so sometimes means that Lift can't locate the snippet method,
 in which case the snippet may not execute!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The argument passed to the snippet method is the XML content of the snippet
 tag.
 Because Lift processes starting with the outer tag and working in, the
 contents of the outer tag are processed 
\emph on
after
\emph default
 the snippet method processes them.
 You may change the order of processing by specifying the 
\family typewriter
eager_eval
\family default
 attribute on the tag (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eager-Eval"

\end_inset

).
 As an example, let's say we wanted a snippet that would output the current
 balance of our ledger.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:a-simple-snippet"

\end_inset

 shows what our snippet method looks like.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=single"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Simple Snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:a-simple-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    Text(currentLedger.formattedBalance)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We simply return an XML Text node with the formatted balance.
 Note that the XML that a snippet returns is itself processed recursively,
 so if your snippet instead looked like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Returning Tags from a Snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Returning-tags-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    <p>{currentLedger.formattedBalance}
\end_layout

\begin_layout Plain Layout

      as of <lift:Util.time /></p>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the 
\family typewriter
lift:Util.time
\family default
 snippet will be processed as well after our snippet method returns.
 It is this hierarchical processing of template tags that makes Lift so
 flexible.
 For those of you coming to Lift with some JSP experience, Lift is designed
 to let you write your own tag libraries, but libraries that are much more
 powerful and much simpler to use.
\end_layout

\begin_layout Subsection
Binding Values in Snippets
\begin_inset CommandInset label
LatexCommand label
name "sub:Binding-Values-in-snippets"

\end_inset


\end_layout

\begin_layout Standard
So far we've only shown our snippets generating complete output and ignoring
 the input to the method.
 Lift actually provides some very nice facilities for using the input NodeSeq
 within your snippet to help keep presentation and code separate.
 First, remember that the input NodeSeq consists of the child elements for
 the snippet tag in your template.
 That is, given a template containing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet Tag Children
\begin_inset CommandInset label
LatexCommand label
name "lst:Snippet-tag-children"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:Ledger.balance>
\end_layout

\begin_layout Plain Layout

  <ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Plain Layout

</lift:Ledger.balance>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then the Ledger.balance method receives
\end_layout

\begin_layout LyX-Code
<ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Standard
as its input parameter.
 This is perfectly correct XML, although it may look a little strange at
 first unless you've used prefixed elements in XML before.
 The key is that Lift allows you to selectively 
\begin_inset Quotes eld
\end_inset

bind
\begin_inset Quotes erd
\end_inset

, or replace, these elements with data inside your snippet.
 The 
\family typewriter
Helpers.bind
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.util.Helpers.
 Technically the bind method is overloaded, and can even fill in values
 for the lift:bind tag, but this is advanced usage and we're not going to
 cover that here.
\end_layout

\end_inset

 method takes three arguments:
\end_layout

\begin_layout Enumerate
The prefix for the tags you wish to bind, in this instance, 
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
The NodeSeq that contains the tags you wish to bind
\end_layout

\begin_layout Enumerate
One or more BindParam elements that map the tag name to a replacement value
\end_layout

\begin_layout Standard
While you can create your own BindParam instances by hand, we generally
 recommend importing 
\family typewriter
Helpers._
\family default
, which among other things contains an implicit conversion from Pair to
 BindParam.
 With this knowledge in hand, we can change our previous definition of the
 balance method to that in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Binding-the-ledger-balance"

\end_inset

 below.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Binding the Ledger Balance
\begin_inset CommandInset label
LatexCommand label
name "lst:Binding-the-ledger-balance"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = 
\end_layout

\begin_layout Plain Layout

    bind ("ledger", content,
\end_layout

\begin_layout Plain Layout

          "balance" -> Text(currentLedger.formattedBalance),
\end_layout

\begin_layout Plain Layout

          "time" -> Text((new java.util.Date).toString))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see here, we actually gain a line of code over our previous effort,
 but the trade-off makes it far simpler for us to change the layout just
 by editing the template.
\end_layout

\begin_layout Standard
One last aspect of binding that we want to discuss is that any attributes
 set on the input elements that are being bound will be discarded
\begin_inset Index
status open

\begin_layout Plain Layout
Attributes ! discarded in bind
\end_layout

\end_inset

 if you use the 
\begin_inset Quotes eld
\end_inset

->
\begin_inset Quotes erd
\end_inset

 binding operator.
 See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Handling-XHTML-Attributes"

\end_inset

 for more details on how you manipulate attributes in bindings, including
 how you can retain attributes on binding elements from your templates.
\end_layout

\begin_layout Subsection
Stateless versus Stateful Snippets
\begin_inset CommandInset label
LatexCommand label
name "sub:Stateless-versus-Stateful"

\end_inset


\end_layout

\begin_layout Standard
The lifecycle of a snippet is stateless by default.
 That means that for each request, Lift creates a new instance of the snippet
 class to execute.
 Any changes you make to instance variables will be discarded after the
 request is processed.
 If you want to keep some state around, you have a couple of options:
\end_layout

\begin_layout Itemize
Store the state in a cookie (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cookies"

\end_inset

).
 This can be useful if you have data that you want to persist across sessions.
 The down side is that you have to manage the cookie as well as deal with
 any security implications for the data in the cookie as it's stored on
 the user's machine.
\end_layout

\begin_layout Itemize
Store the state in a SessionVar (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-and-Request"

\end_inset

).
 This is a little easier to manage than cookies, but you still have to handle
 adding and removing the session data if you don't want it around for the
 duration of the session.
 As with a cookie, it is global, which means that it will be the same for
 all snippet instances.
\end_layout

\begin_layout Itemize
Pass the state around in a RequestVar by setting 
\begin_inset Quotes eld
\end_inset

injector
\begin_inset Quotes erd
\end_inset

 functions in your page transition functions (e.g.
 
\family typewriter
SHtml.link
\family default
, 
\family typewriter
S.redirectTo
\family default
, etc).
 We'll cover this technique in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-and-Request"

\end_inset

.
\end_layout

\begin_layout Itemize
Use a StatefulSnippet subclass.
 This is ideal for small, conversational state, such as a form that spans
 multiple pages or for a page where you have multiple variables that you
 want to be able to tweak individually.
\end_layout

\begin_layout Standard
Using a StatefulSnippet is very similar to using a normal snippet but with
 the addition of a few mechanisms.
 First, the StatefulSnippet trait defines a 
\family typewriter
dispatch
\family default
 method of type 
\family typewriter
PartialFunction[String, () => NodeSeq]
\family default
.
 This lets you define which methods handle which snippets.
 Because the 
\family typewriter
dispatch
\family default
 method in the base DispatchSnippet can be overridden with a var, it also
 lets you redefine this behavior as a result of snippet processing.
 
\end_layout

\begin_layout Standard
Another thing to remember when using StatefulSnippets is that when you render
 a form, a hidden field is added to the form that permits the same instance
 of the StatefulSnippet that created the form to be the target of the form
 submission.
 If you need to link to a different page, but would like the same snippet
 instance to handle snippets on that page, use the 
\family typewriter
StatefulSnippet.link
\family default
 method (instead of 
\family typewriter
SHtml.link
\family default
); similarly, if you need to redirect to a different page, the StatefulSnippet
 trait defines a 
\family typewriter
redirectTo
\family default
 method.
 In either of these instances, a function map is added to the link or redirect,
 respectively, that causes the instance to be reattached.
\end_layout

\begin_layout Standard
When might you use a stateful snippet? Consider a multi-part form where
 you'd like to have a user enter data over several pages.
 You'll want the application to maintain the previously entered data while
 you validate the current entry, but you don't want to have to deal with
 a lot of hidden form variables.
 Using a StatefulSnippet instance greatly simplifies writing the snippet
 because you can keep all of your pertinent information around as instance
 variables instead of having to insert and extract them from every request,
 link, etc.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Using-a-StatefulSnippet"

\end_inset

 shows an example of a stateful snippet that handles the above example.
 Note that for this example, the URL (and therefore, the template) don't
 change between pages.
 The template we use is shown in Listing .
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Using a StatefulSnippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Using-a-StatefulSnippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

...
 standard Lift imports ...
\end_layout

\begin_layout Plain Layout

import _root_.scala.xml.Text
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class BridgeKeeper extends StatefulSnippet {
\end_layout

\begin_layout Plain Layout

  // Define the dispatch for snippets.
 Note that we are defining
\end_layout

\begin_layout Plain Layout

  // it as a var so that the snippet for each portion of the 
\end_layout

\begin_layout Plain Layout

  // multi-part form can update it after validation.
\end_layout

\begin_layout Plain Layout

  var dispatch : DispatchIt = {
\end_layout

\begin_layout Plain Layout

    // We default to dispatching the "challenge" snippet to our
\end_layout

\begin_layout Plain Layout

    // namePage snippet method.
 We'll update this below
\end_layout

\begin_layout Plain Layout

    case "challenge" => firstPage _
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Define our state variables:
\end_layout

\begin_layout Plain Layout

  var name = ""
\end_layout

\begin_layout Plain Layout

  var quest = ""
\end_layout

\begin_layout Plain Layout

  var color = ""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Our first form page
\end_layout

\begin_layout Plain Layout

  def firstPage (xhtml : NodeSeq) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    def processName (nm : String) {
\end_layout

\begin_layout Plain Layout

      name = nm
\end_layout

\begin_layout Plain Layout

      if (name != "") {
\end_layout

\begin_layout Plain Layout

        dispatch = { case "challenge" => questPage _ }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        S.error("You must provide a name!")
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    bind("form", xhtml,
\end_layout

\begin_layout Plain Layout

         "question" -> Text("What is your name?"),
\end_layout

\begin_layout Plain Layout

         "answer" -> SHtml.text(name, processName))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def questPage (xhtml : NodeSeq) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    def processQuest (qst : String) {
\end_layout

\begin_layout Plain Layout

      quest = qst
\end_layout

\begin_layout Plain Layout

      if (quest != "") {
\end_layout

\begin_layout Plain Layout

        dispatch = { 
\end_layout

\begin_layout Plain Layout

          case "challenge" if name == "Arthur" => swallowPage _
\end_layout

\begin_layout Plain Layout

          case "challenge" => colorPage _ 
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        S.error("You must provide a quest!")
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    bind("form", xhtml,
\end_layout

\begin_layout Plain Layout

         "question" -> Text("What is your quest?"),
\end_layout

\begin_layout Plain Layout

         "answer" -> SHtml.text(quest, processQuest))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def colorPage (xhtml : NodeSeq) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    def processColor (clr : String) {
\end_layout

\begin_layout Plain Layout

      color = clr
\end_layout

\begin_layout Plain Layout

      if (color.toLowercase.contains "No,") {
\end_layout

\begin_layout Plain Layout

        // This is a cleanup that removes the mapping for this
\end_layout

\begin_layout Plain Layout

        // StatefulSnippet from the session.
 This will happen 
\end_layout

\begin_layout Plain Layout

        // over time with GC, but it's best practice to manually 
\end_layout

\begin_layout Plain Layout

        // do this when you're finished with the snippet
\end_layout

\begin_layout Plain Layout

        this.unregisterThisSnippet()
\end_layout

\begin_layout Plain Layout

        S.redirectTo("/pitOfEternalPeril")
\end_layout

\begin_layout Plain Layout

      } else if (color != "") {
\end_layout

\begin_layout Plain Layout

        this.unregisterThisSnippet()
\end_layout

\begin_layout Plain Layout

        S.redirectTo("/scene24")
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        S.error("You must provide a color!")
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    bind("form", xhtml,
\end_layout

\begin_layout Plain Layout

         "question" -> Text("What is your favorite color?"),
\end_layout

\begin_layout Plain Layout

         "answer" -> SHtml.text(color, processColor))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // and so on for the swallowPage snippet
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
The StatefulSnippet Example Template
\begin_inset CommandInset label
LatexCommand label
name "lst:The-StatefulSnippet-Example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

  <lift:BridgeKeeper.challenge form="POST">
\end_layout

\begin_layout Plain Layout

    <form:question /> : <form:answer /> <br />
\end_layout

\begin_layout Plain Layout

    <input type="submit" value="Answer" />
\end_layout

\begin_layout Plain Layout

  </lift:BridgeKeeper.challenge>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Eager Evaluation
\begin_inset CommandInset label
LatexCommand label
name "sub:Eager-Eval"

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Snippets"

\end_inset

, Lift processes the contents of a snippet tag after it processes the tag
 itself.
 If you want the contents of a snippet tag to be processed 
\emph on
before
\emph default
 the snippet, then you need to specify the 
\family typewriter
eager_eval
\family default

\begin_inset Index
status open

\begin_layout Plain Layout
eager eval
\end_layout

\end_inset

 attribute on the tag:
\end_layout

\begin_layout LyX-Code
<lift:Hello.world eager_eval=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

>...</lift:Hello.world>
\end_layout

\begin_layout Standard
This is especially useful if you're using an embedded template (Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:embed-tag"

\end_inset

).
 Consider Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Embedding-and-eager"

\end_inset

: in this case, the 
\family typewriter
eager_eval
\family default
 parameter makes Lift process the 
\family typewriter
<lift:embed />
\family default
 tag before it executes the 
\family typewriter
Hello.world
\family default
 snippet method.
 If the 
\begin_inset Quotes eld
\end_inset

formTemplate
\begin_inset Quotes erd
\end_inset

 template looks like Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:The-formTemplate-template"

\end_inset

, then the 
\family typewriter
Hello.world
\family default
 snippet sees the 
\family typewriter
<hello:name />
\family default
 and 
\family typewriter
<hello:time />
\family default
 XML tags as its NodeSeq input.
 If the 
\family typewriter
eager_eval
\family default
 attribute is removed, however, the Hello.world snippet sees only a 
\family typewriter
<lift:embed />
\family default
 tag.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Embedding and eager evaluation
\begin_inset CommandInset label
LatexCommand label
name "lst:Embedding-and-eager"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:Hello.world eager_eval="true">
\end_layout

\begin_layout Plain Layout

  <lift:embed what="formTemplate" />
\end_layout

\begin_layout Plain Layout

</lift:Hello.world>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
The formTemplate template
\begin_inset CommandInset label
LatexCommand label
name "lst:The-formTemplate-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<hello:name />
\end_layout

\begin_layout Plain Layout

<hello:time />
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add example of same snippet on multiple pages.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Handling-XHTML-Attributes"

\end_inset

Handling XHTML Attributes
\begin_inset Index
status open

\begin_layout Plain Layout
Attributes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's a common requirement that elements contain XHTML attributes to control
 things like style, provide an id, register javascript event handlers, and
 other functionality.
 Lift provides two main approaches to applying attributes to elements either
 in your Scala code or directly in the XHTML template.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Direct-attr-manip"

\end_inset

Direct Manipulation in Code
\end_layout

\begin_layout Standard
You can apply attributes directly to XHTML elements using the 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 operator
\begin_inset Index
status open

\begin_layout Plain Layout
Attributes ! % operator
\end_layout

\end_inset

 to apply a
\begin_inset Newline linebreak
\end_inset


\family typewriter
scala.xml.UnprefixedAttribute
\family default
 instance
\begin_inset Foot
status open

\begin_layout Plain Layout
there's a corresponding 
\family typewriter
PrefixedAttribute
\family default
 as well
\end_layout

\end_inset

 to an element.
 Lift's 
\family typewriter
net.liftweb.util.Helpers
\family default
 trait contains an implicit conversion from a 
\family typewriter
Pair[String,_]
\family default
 to an 
\family typewriter
UnprefixedAttribute
\family default
 called 
\family typewriter
pairToUnprefixed
\family default
 that allows you to use a simpler syntax.
 You may chain invocations of 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 to apply multiple attributes.
 For example, Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Applying-Attributes-percent"

\end_inset

 shows how you can apply an 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

 attribute to a text box and to a normal paragraph.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val myInput = SHtml.text("", processText(_)) % ("id" -> "inputField") % 
\end_layout

\begin_layout Plain Layout

  ("class" -> "highlighted")
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Applying-Attributes-percent"

\end_inset

Applying Attributes with 
\family typewriter
%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note that the % metadata mechanism is actually part of the Scala XML library.
 Specifically, 
\family typewriter
scala.xml.Elem
\family default
 has a 
\family typewriter
%
\family default
 method that allows the user to update the attributes on a given XML element
 by passing in a 
\family typewriter
scala.xml.UnprefixedAttribute
\family default
.
 We suggest reading more about this in the Scala API documents, or in the
 Scala XML docbook at 
\begin_inset CommandInset href
LatexCommand href
target "http://burak.emir.googlepages.com/scalaxbook.docbk.html"

\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:XHTML-Attribute-Pass-through"

\end_inset

XHTML Attribute Pass-through
\begin_inset Index
status open

\begin_layout Plain Layout
Attributes ! binding
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second main approach to modifying XHTML attributes is to specify them
 directly in your templates.
 This has the benefit of allowing your template designers to directly manipulate
 things like style-related attributes and keeping the markup and the logic
 separate.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Snippet-mixin-attributes"

\end_inset

 shows how you can utilize the 
\begin_inset Quotes eld
\end_inset

-%>
\begin_inset Quotes erd
\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
Attributes ! -%> operator
\end_layout

\end_inset

 binding operator instead of 
\begin_inset Quotes eld
\end_inset

->
\begin_inset Quotes erd
\end_inset

 to preserve attributes.
 Note that you need to prefix attributes that you want to retain with the
 same prefix as the element in which they're defined.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet mixin attributes 
\begin_inset CommandInset label
LatexCommand label
name "lst:Snippet-mixin-attributes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// the markup
\end_layout

\begin_layout Plain Layout

<lift:Ledger.balance>
\end_layout

\begin_layout Plain Layout

  <ledger:time ledger:id="myId"/>
\end_layout

\begin_layout Plain Layout

</lift:Ledger.balance>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// The snippet class
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    bind ("ledger", content,
\end_layout

\begin_layout Plain Layout

          "time" -%> <span>{(new java.util.Date).toString}</span>)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting node will be something like
\end_layout

\begin_layout LyX-Code

\family typewriter
<span id=
\begin_inset Quotes erd
\end_inset

myId
\begin_inset Quotes erd
\end_inset

>Sat Mar 28 16:43:48 EET 2009</span>
\end_layout

\begin_layout Section
URL Rewriting 
\begin_inset CommandInset label
LatexCommand label
name "sec:URL-Rewriting"

\end_inset


\end_layout

\begin_layout Standard
Now that we've gone over Templates, Views, Snippets, and how requests are
 dispatched to a Class.method, we can discuss how to intercept requests and
 handle them the way we want to.
 URL rewriting
\begin_inset Index
status open

\begin_layout Plain Layout
rewriting
\end_layout

\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
URL rewriting
\end_layout

\end_inset

 is the mechanism that allows you to modify the incoming request so that
 it dispatches to a different URL.
 It can be used, among other things, to allow you to:
\end_layout

\begin_layout Itemize
Use user-friendly, bookmarkable URLs like 
\family typewriter
http://www.example.com/budget/2008
\end_layout

\begin_layout Itemize
Use short URLs instead of long, hard to remember ones, similar to 
\begin_inset CommandInset href
LatexCommand href
target "http://tinyurl.com"

\end_inset


\end_layout

\begin_layout Itemize
Use portions of the URL to determine how a particular snippet or view responds.
 For example, you could make it so that a user's profile is displayed via
 a URL such as
\begin_inset Newline linebreak
\end_inset


\family typewriter
http://someplace.com/user/derek
\family default
 instead of having the username sent as part of a query string.
\end_layout

\begin_layout Standard
The mechanism is fairly simple to set up.
 We need to write a partial function from a RewriteRequest to a RewriteResponse
 to determine if and how we want to rewrite particular requests.
 Once we have the partial function, we modify the 
\family typewriter
LiftRules.rewrite
\family default
 configuration to hook into Lift's processing chain.
 The simplest way to write a partial function is with Scala's match statement,
 which will allow us to selectively match on some or all of the request
 information.
 (Recall that for a partial function, the matches do not have to be exhaustive.
 In the instance that no RewriteRequest matches, no RewriteResponse will
 be generated.) It is also important to understand that when the rewrite
 functions run, the Lift session has not yet been created.
 This means that you generally can't set or access properties in the S object.
 RewriteRequest is a 
\family typewriter
case
\family default
 object that contains three items: the parsed path, the request type and
 the original HttpServletRequest
\begin_inset Index
status collapsed

\begin_layout Plain Layout
HttpServletRequest
\end_layout

\end_inset

 object.
 (If you are not familiar with case classes, you may wish to review the
 Scala documentation for them.
 Adding the 
\family typewriter
case
\family default
 modifier to a class results in some nice syntactic conveniences.)
\end_layout

\begin_layout Standard
The parsed path of the request is in a ParsePath
\begin_inset Index
status collapsed

\begin_layout Plain Layout
ParsePath
\end_layout

\end_inset

 
\family typewriter
case
\family default
 class instance.
 The ParsePath class contains
\end_layout

\begin_layout Enumerate
The parsed path as a List[String]
\end_layout

\begin_layout Enumerate
The suffix of the request (i.e.
 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

, etc)
\end_layout

\begin_layout Enumerate
Whether this path is root-relative path.
 If true, then it will start with /<context-path>, followed by the rest
 of the path.
 For example, if your application is deployed on the app context path (
\begin_inset Quotes eld
\end_inset

/app
\begin_inset Quotes erd
\end_inset

) and we want to reference the file <webapp-folder>/pages/index.html, then
 the root-relative path will be /app/pages/index.html.
 
\end_layout

\begin_layout Enumerate
Whether the path ends in a slash (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
The latter three properties are useful only in specific circumstances, but
 the parsed path is what lets us work magic.
 The path of the request is defined as the parts of the URI between the
 context path and the query string.
 The following table shows examples of parsed paths for a Lift application
 under the 
\begin_inset Quotes eld
\end_inset

myapp
\begin_inset Quotes erd
\end_inset

 context path:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Requested URL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Parsed Path
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/home?test_this=true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/user/derek
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

derek
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
http://foo.com/myapp/view/item/14592
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
List[String](
\begin_inset Quotes eld
\end_inset

view
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

item
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

14592
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The RequestType maps to one of the five HTTP methods: GET, POST, HEAD, PUT
 and DELETE.
 These are represented by the corresponding GetRequest, PostRequest, etc.
 case classes, with an UnknownRequest case class to cover anything strange.
\end_layout

\begin_layout Standard
The flexibility of Scala's matching system is what really makes this powerful.
 In particular, when matching on Lists, we can match parts of the path and
 capture others.
 For example, suppose we'd like to rewrite the 
\family typewriter
/account/<account name>
\family default
 path so that it's handled by the 
\family typewriter
/viewAcct
\family default
 template as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Simple-rewrite-example"

\end_inset

.
 In this case we provide two rewrites.
 The first matches /account/<account name> and redirects it to the /viewAcct
 template, passing the acctName as a 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 parameter.
 The second matches /account/<account name>/<tag>, redirecting it to /viewAcct
 as before, but passing both the 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

tag
\begin_inset Quotes erd
\end_inset

 parameter with the acctName and tag matches from the ParsePath, respectively.
 Remember that the underscore (_) in these matching statements means that
 we don't care what that parameter is, i.e., match anything in that spot.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Simple Rewrite Example
\begin_inset CommandInset label
LatexCommand label
name "lst:Simple-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

LiftRules.rewrite.append {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(
\end_layout

\begin_layout Plain Layout

         ParsePath(List("account",acctName),_,_,_),_,_) => 
\end_layout

\begin_layout Plain Layout

         RewriteResponse("viewAcct" :: Nil, Map("name" -> acctName))
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(
\end_layout

\begin_layout Plain Layout

         ParsePath(List("account",acctName, tag),_,_,_),_,_) => 
\end_layout

\begin_layout Plain Layout

         RewriteResponse("viewAcct" :: Nil, Map("name" -> acctName,
\end_layout

\begin_layout Plain Layout

                                                "tag" -> tag)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The RewriteResponse
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RewriteResponse
\end_layout

\end_inset

 simply contains the new path to follow.
 It can also take a Map
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 that contains parameters that will be accessible via S.param
\begin_inset Index
status collapsed

\begin_layout Plain Layout
S.param
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
S
\end_layout

\end_inset

 in the snippet or view.
 As we stated before, the LiftSession (and therefore most of S) isn't available
 at this time, so the Map is the only way to pass information on to the
 rewritten location.
 
\end_layout

\begin_layout Standard
We can combine the ParsePath matching with the RequestType and HttpServletReques
t to be very specific with our matches.
 For example, if we wanted to support the DELETE HTTP verb for a RESTful
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
url{http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
RESTful
\end_layout

\end_inset

 interface through an existing template, we could redirect as shown in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Complex-rewrite-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Complex Rewrite Example
\begin_inset CommandInset label
LatexCommand label
name "lst:Complex-rewrite-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val rewriter = {
\end_layout

\begin_layout Plain Layout

  case RewriteRequest(ParsePath(username :: Nil, _, _, _),
\end_layout

\begin_layout Plain Layout

                      DeleteRequest,
\end_layout

\begin_layout Plain Layout

                      httpreq) 
\end_layout

\begin_layout Plain Layout

                      if isMgmtSubnet(httpreq.getRemoteHost()) => 
\end_layout

\begin_layout Plain Layout

       RewriteResponse(deleteUser :: Nil, Map(username -> username))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

LiftRules.rewrite.append(rewriter)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We'll go into more detail about how you can use this in the following sections.
 In particular, SiteMap
\begin_inset Index
status collapsed

\begin_layout Plain Layout
SiteMap
\end_layout

\end_inset

 (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

) provides a mechanism for doing rewrites combined with menu entries.
\end_layout

\begin_layout Section
Custom Dispatch Functions 
\begin_inset CommandInset label
LatexCommand label
name "sec:Custom-dispatch-func"

\end_inset


\end_layout

\begin_layout Standard
Once the rewriting phase is complete (whether we pass through or are redirected)
, the next phase is to determine whether there should be a custom dispatch
 for the request.
 A custom dispatch allows you to handle a matching request directly by a
 method instead of going through the template lookup system.
 Because it bypasses templating, you're responsible for the full content
 of the response.
 A typical use case would be a web service
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web service
\end_layout

\end_inset

 returning XML or a service to return, say, a generated image or PDF.
 In that sense, the custom dispatch mechanism allows you to write your own
 
\begin_inset Quotes eld
\end_inset

sub-servlets
\begin_inset Quotes erd
\end_inset

 without all the mess of implementing the interface and configuring them
 in web.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
web.xml
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
As with rewriting, custom dispatch is realized via a partial function.
 In this case, it's a function of type 
\family typewriter
PartialFunction[Req,
\begin_inset Formula $()\Rightarrow Box[LiftResponse]$
\end_inset

]
\family default
 that does the work.
 The 
\family typewriter
Req
\family default
 is similar to the RewriteRequest case class: it provides the path as a
 List[String], the suffix of the request, and the RequestType.
 If you attach the dispatch function via 
\family typewriter
LiftRules.dispatch
\family default
 then you'll have full access to the S object and LiftSession; if you use
\begin_inset Newline linebreak
\end_inset


\family typewriter
LiftRules.statelessDispatchTable
\family default
 instead, then these aren't available.
 The result of the dispatch should be a function that returns a 
\family typewriter
Box[LiftResponse]
\family default
.
 If the function returns 
\family typewriter
Empty
\family default
, then Lift returns a 
\begin_inset Quotes eld
\end_inset

404 Not Found
\begin_inset Quotes erd
\end_inset

 response.
\end_layout

\begin_layout Standard
As a concrete example, let's look at returning a generated chart image from
 our application.
 There are several libraries for charting, but we'll take a look at JFreeChart
 in particular.
 First, let's write a method that will chart our account balances by month
 for the last year:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Charting Method
\begin_inset CommandInset label
LatexCommand label
name "lst:Charting-method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def chart (endDate : String) : Box[LiftResponse] = {
\end_layout

\begin_layout Plain Layout

  // Query, set up chart, etc...
\end_layout

\begin_layout Plain Layout

  val buffered = balanceChart.createBufferedImage(width,height)
\end_layout

\begin_layout Plain Layout

  val chartImage = ChartUtilities.encodeAsPNG(buffered)
\end_layout

\begin_layout Plain Layout

  // InMemoryResponse is a subclass of LiftResponse
\end_layout

\begin_layout Plain Layout

  // it takes an Array of Bytes, a List[(String,String)] of
\end_layout

\begin_layout Plain Layout

  // headers, a List[Cookie] of Cookies, and an integer
\end_layout

\begin_layout Plain Layout

  // return code (here 200 for HTTP 200: OK)
\end_layout

\begin_layout Plain Layout

  Full(InMemoryResponse(chartImage, 
\end_layout

\begin_layout Plain Layout

                        ("Content-Type" -> "image/png") :: Nil,
\end_layout

\begin_layout Plain Layout

                        Nil,
\end_layout

\begin_layout Plain Layout

                        200))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we've set up the chart, we use the ChartUtilities helper class from
 JFreeChart to encode the chart into a PNG byte array.
 We can then use Lift's InMemoryResponse
\begin_inset Index
status collapsed

\begin_layout Plain Layout
InMemoryResponse
\end_layout

\end_inset

 to pass the encoded data back to the client with the appropriate Content-Type
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Type
\end_layout

\end_inset

 header.
 Now we just need to hook the request into the dispatch table from the Boot
 class as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Hooking-dispatch-into-Boot"

\end_inset

.
 In this instance, we want state so that we can get the current user's chart.
 For this reason, we use 
\family typewriter
LiftRules.dispatch
\family default
 as opposed to 
\family typewriter
LiftRules.statelessDispatch
\family default
.
 Because we're using a partial function to perform a Scala match operation,
 the case that we define here uses the 
\family typewriter
Req
\family default
 object's 
\family typewriter
unapply
\family default
 method, which is why we only need to provide the 
\family typewriter
List[String]
\family default
 argument.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Hooking Dispatch into Boot
\begin_inset CommandInset label
LatexCommand label
name "lst:Hooking-dispatch-into-Boot"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

LiftRules.dispatch.append {
\end_layout

\begin_layout Plain Layout

  case Req("chart" :: "balances" :: endDate :: Nil, _, _) =>
\end_layout

\begin_layout Plain Layout

    Charting.chart(endDate) _
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, we capture the endDate parameter from the path and pass
 it into our chart method.
 This means that we can use a URL like 
\family typewriter
http://foo.com/chart/balances/20080401
\family default
 to obtain the image.
 Since the dispatch function has an associated Lift session, we can also
 use the S.param method to get query string parameters, if, for example,
 we wanted to allow someone to send an optional width and height:
\end_layout

\begin_layout LyX-Code
val width = S.param(
\begin_inset Quotes eld
\end_inset

width
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 400
\end_layout

\begin_layout LyX-Code
val height = S.param(
\begin_inset Quotes eld
\end_inset

height
\begin_inset Quotes erd
\end_inset

).map(_.toInt) openOr 300
\end_layout

\begin_layout Standard
Or you can use a slightly different approach by using the 
\family typewriter
Box.dmap
\family default
 method:
\end_layout

\begin_layout LyX-Code
val width = S.param(
\begin_inset Quotes eld
\end_inset

width
\begin_inset Quotes erd
\end_inset

).dmap(400)(_.toInt)
\end_layout

\begin_layout LyX-Code
val height = S.param(
\begin_inset Quotes eld
\end_inset

height
\begin_inset Quotes erd
\end_inset

).dmap(300)(_.toInt)
\end_layout

\begin_layout Standard
Where dmap is identical with map function except that the first argument
 is the default value to use if the 
\family typewriter
Box
\family default
 is 
\family typewriter
Empty
\family default
.
 There are a number of other ListResponse subclasses to cover your needs,
 including responses for XHTML, XML, Atom, Javascript, CSS, and JSON.
 We cover these in more detail in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

.
\end_layout

\begin_layout Section
HTTP Redirects 
\begin_inset CommandInset label
LatexCommand label
name "sec:HTTP-redirects"

\end_inset


\end_layout

\begin_layout Standard
HTTP redirects are an important part of many web applications.
 In Lift there are two main ways of sending a redirect to the client:
\end_layout

\begin_layout Enumerate
Call S.redirectTo.
 When you do this, Lift throws an exception and catches it later on.
 This means that any code following the redirect is skipped.
 It also means that if you use S.redirectTo within a try/catch block, you'll
 need to make sure that you aren't catching the redirect exception (Scala
 usesunchecked exceptions), or test for the redirect's exception and rethrow
 it.
 Ifyou mistakenly catch the redirect exception, then no redirect will occur.
 If you're using a StatefulSnippet (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-versus-Stateful"

\end_inset

), use 
\family typewriter
this.redirectTo
\family default
 so that your snippet instance is used when the redirect is processed.
\end_layout

\begin_layout Enumerate
When you need to return a LiftResponse, you can simply return a RedirectResponse
 or a RedirectWithState response.
\end_layout

\begin_layout Standard
The RedirectWithState response allows you to specify a function to be executed
 when the redirected request is processed.
 You can also send Lift messages (notices, warnings, and errors) that will
 be rendered in the redirected page, as well as cookies to be set on redirect.
 Similarly, there is an overloaded version of S.redirectTo that allows you
 to specify a function to be executed when the redirect is processed.
\end_layout

\begin_layout Section
Cookies
\begin_inset CommandInset label
LatexCommand label
name "sec:Cookies"

\end_inset


\end_layout

\begin_layout Standard
Cookies
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/Cookie.html"

\end_inset


\end_layout

\end_inset

 are a useful tool when you want data persisted across user sessions.
 Cookies are essentially a token of string data that is stored on the user's
 machine.
 While they can be quite useful, there are a few things that you should
 be aware of:
\end_layout

\begin_layout Enumerate
The user's browser may have cookies disabled, in which case you need to
 be prepared to work without cookies or tell the user that they need to
 enable them for your site
\end_layout

\begin_layout Enumerate
Cookies are relatively insecure
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
target "http://www.w3.org/Security/Faq/wwwsf2.html"

\end_inset

 (Q10) and 
\begin_inset CommandInset href
LatexCommand href
target "http://www.cookiecentral.com/faq/"

\end_inset

 for details on cookies and their security issues.
\end_layout

\end_inset

.
 There have been a number of browser bugs related to data in cookies being
 read by viruses or other sites
\end_layout

\begin_layout Enumerate
Cookies are easy to fake, so you need to ensure that you validate any sensitive
 cookie data
\end_layout

\begin_layout Standard
Using Cookies in Lift is very easy.
 In a stateful context, everything you need is provided by a few methods
 on the S object:
\end_layout

\begin_layout Description
addCookie Adds a cookie to be sent in the response
\end_layout

\begin_layout Description
deleteCookie Deletes a cookie (technically, this adds a cookie with a maximum
 age of zero so that the browser removes it).
 You can either delete a cookie by name, or with a Cookie object
\end_layout

\begin_layout Description
findCookie Looks for a cookie with a given name and returns a Box[Cookie].
 Empty means that the cookie doesn't exist
\end_layout

\begin_layout Description
receivedCookies Returns a List[Cookie] of all of the cookies sent in the
 request
\end_layout

\begin_layout Description
responseCookies Returns a List[Cookie] of the cookies that will be sent
 in the response
\end_layout

\begin_layout Standard
If you need to work with cookies in a stateless context, many of the ListRespons
e classes (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

) include a List[Cookie] in their constructor or 
\family typewriter
apply
\family default
 arguments.
 Simply provide a list of the cookies you want to set, and they'll be sent
 in the response.
 If you want to delete a cookie in a LiftResponse, you have to do it manually
 by adding a cookie with the same name and a 
\family typewriter
maxage
\family default
 of zero.
 
\end_layout

\begin_layout Section
Session and Request State
\begin_inset CommandInset label
LatexCommand label
name "sec:Session-and-Request"

\end_inset


\end_layout

\begin_layout Standard
Lift provides a very easy way to store per-session and per-request data
 through the SessionVar and RequestVar classes.
 In true Lift fashion, these classes provide:
\end_layout

\begin_layout Itemize
Type-safe access to the data they hold
\end_layout

\begin_layout Itemize
A mechanism for providing a default value if the session or request doesn't
 exist yet
\end_layout

\begin_layout Itemize
A mechanism for cleaning up the data when the variable's lifecycle ends
\end_layout

\begin_layout Standard
Additionally, Lift provides easy access to HTTP request parameters
\begin_inset Index
status open

\begin_layout Plain Layout
request parameters
\end_layout

\end_inset

 via the S.param method, which returns a Box[String].
 Note that HTTP request parameters (sent via GET or POST) differ from RequestVar
s in that query parameters are string values sent as part of the request;
 RequestVars, in contrast, use an internal per-request Map so that they
 can hold any type, and are initialized entirely in code.
 At this point you might ask what RequestVars can be used for.
 A typical example would be sharing state between different snippets, since
 there is no connection between snippets other than at the template level.
\end_layout

\begin_layout Standard
SessionVars and RequestVars are intended to be implemented as singleton
 objects so that they're accessible from anywhere in your code.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Defining-a-RequestVar"

\end_inset

 shows an example definition of a RequestVar used to hold the number of
 entries to show per page.
 We start by defining the object as extending the RequestVar.
 You must provide the type of the RequestVar so that Lift knows what to
 accept and return.
 In this instance, the type is an Int.
 The constructor argument is a by-name parameter which must evaluate to
 the var's type.
 In our case, we attempt to use the HTTP request variable 
\begin_inset Quotes eld
\end_inset

pageSize,
\begin_inset Quotes erd
\end_inset

 and if that isn't present or isn't an integer, then we default to 25.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Defining a RequestVar
\begin_inset CommandInset label
LatexCommand label
name "lst:Defining-a-RequestVar"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class AccountOps {
\end_layout

\begin_layout Plain Layout

  object pageSize extends RequestVar[Int](S.param("pageSize").map(_.toInt)
 openOr 25)
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Accessing the value of the 
\family typewriter
RequestVar
\family default
 is done via the 
\family typewriter
is
\family default
 method.
 You can also set the value using the 
\family typewriter
apply
\family default
 method, which in Scala is syntactically like using the 
\family typewriter
RequestVar
\family default
 as a function.
 Common uses of apply in Scala include array element access by index and
 companion object methods that can approximate custom constructors.
 For example, the 
\family typewriter
Loc
\family default
 object (which we'll cover in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

), has an overloaded 
\family typewriter
apply
\family default
 method that creates a new 
\family typewriter
Loc
\family default
 class instance based on input parameters.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Accessing the RequestVar
\begin_inset CommandInset label
LatexCommand label
name "lst:Accessing-the-RequestVar"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// get the value contained in the AccountOps.pageSize RequestVar
\end_layout

\begin_layout Plain Layout

query.setMaxResults(AccountOps.pageSize.is)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Change the value of the RequestVar.
 The following two lines
\end_layout

\begin_layout Plain Layout

// of code are equivalent:
\end_layout

\begin_layout Plain Layout

AccountOps.pageSize(50)
\end_layout

\begin_layout Plain Layout

AccountOps.pageSize.apply(50)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to taking a parameter that defines a default value for setup,
 you can also clean up the value when the variable ends it lifecycle.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Defining-a-Cleanup"

\end_inset

 shows an example of opening a socket and closing it at the end of the request.
 This is all handled by passing a function to the 
\family typewriter
registerCleanupFunc
\family default
 method.
 The type of the function that you need to pass is 
\begin_inset Formula $CleanUpParam\Rightarrow Unit$
\end_inset

, where 
\family typewriter
CleanUpParam
\family default
 is defined based on whether you're using a 
\family typewriter
RequestVar
\family default
 or a 
\family typewriter
SessionVar
\family default
.
 With 
\family typewriter
RequestVar
\family default
, 
\family typewriter
CleanUpParam
\family default
 is of type 
\family typewriter
Box[LiftSession]
\family default
, reflecting that the session may not be in scope when the cleanup function
 executes.
 For a 
\family typewriter
SessionVar
\family default
 the 
\family typewriter
CleanUpParam
\family default
 is of type 
\family typewriter
LiftSession
\family default
, since the session is always in scope for a 
\family typewriter
SessionVar
\family default
 (it holds a reference to the session).
 In our example in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Defining-a-Cleanup"

\end_inset

 we simply ignore the input parameter to the cleanup function, since closing
 the socket is independent of any session state.
 Another important thing to remember is that you're responsible for handling
 any exceptions that might be thrown during either default initialization
 or cleanup.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Defining a Cleanup Function
\begin_inset CommandInset label
LatexCommand label
name "lst:Defining-a-Cleanup"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

object mySocket extends RequestVar[Socket](new Socket("localhost:23")) {
\end_layout

\begin_layout Plain Layout

  registerCleanupFunc(ignore => this.is.close)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The information we've covered here is equally applicable to SessionVars;
 the only difference between them is the scope of their respective lifecycles.
\end_layout

\begin_layout Standard
Another common use of 
\family typewriter
RequestVar
\family default
 is to pass state around between different page views (requests).
 We start by defining a 
\family typewriter
RequestVar
\family default
 on an object so that it's accesible from all of the snippet methods that
 will read and write to it.
 It's also possible to define it on a class if all of the snippets that
 will access it are in that class.
 Then, in the parts of your code that will transition to a new page you
 use the overloaded versions of 
\family typewriter
SHtml.link
\family default
 or
\family typewriter
 S.redirectTo
\family default
 that take a function as a second argument to 
\begin_inset Quotes eld
\end_inset

inject
\begin_inset Quotes erd
\end_inset

 the value you want to pass via the 
\family typewriter
RequestVar
\family default
.
 This is similar to using a query parameter on the URL to pass data, but
 there are two important advantages:
\end_layout

\begin_layout Enumerate
You can pass any type of data via a 
\family typewriter
RequestVar
\family default
, as opposed to just string data in a query parameter.
\end_layout

\begin_layout Enumerate
You're really only passing a reference to the injector function, as opposed
 to the data itself.
 This can be important if you don't want the user to be able to tamper with
 the passed data.
 One example would be passing the cost of an item from a 
\begin_inset Quotes eld
\end_inset

view item
\begin_inset Quotes erd
\end_inset

 page to an 
\begin_inset Quotes eld
\end_inset

add to cart
\begin_inset Quotes erd
\end_inset

 page.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Passing-an-Account"

\end_inset

 shows how we pass an Account from a listing table to a specific Account
 edit page using 
\family typewriter
SHtml.link
\family default
, as well as how we could transition from an edit page to a view page using
 
\family typewriter
S.redirectTo
\family default
.
 Another example of passing is shown in Listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:Passing-Detached-Instances"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Passing an Account to View
\begin_inset CommandInset label
LatexCommand label
name "lst:Passing-an-Account"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class AccountOps {
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  object currentAccountVar extends RequestVar[Account](null)
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  def manage (xhtml : NodeSeq) ...
 {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    User.currentUser.map({user => 
\end_layout

\begin_layout Plain Layout

      user.accounts.flatMap({acct =>
\end_layout

\begin_layout Plain Layout

        bind("acct", chooseTemplate("account", "entry", xhtml),
\end_layout

\begin_layout Plain Layout

          ...
\end_layout

\begin_layout Plain Layout

          // The second argument injects the "acct" val back
\end_layout

\begin_layout Plain Layout

          // into the RequestVar
\end_layout

\begin_layout Plain Layout

          link("/editAcct", () => currentAccountVar(acct), Text("Edit"))
\end_layout

\begin_layout Plain Layout

      })
\end_layout

\begin_layout Plain Layout

    })
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  def edit (xhtml : NodeSeq) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    def doSave () {
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

      val acct = currentAccountVar.is
\end_layout

\begin_layout Plain Layout

      S.redirectTo("/view", () => currentAccountVar(acct))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One important thing to note is that the injector variable is called in the
 scope of the 
\emph on
following
\emph default
 request.
 This means that if you want the value returned by the function at the point
 where you call the link or redirectTo, you'll need to capture it in a val.
 Otherwise, the function will be called 
\emph on
after
\emph default
 the redirect or link, which may result in a different value than you expect.
 As you can see in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Passing-an-Account"

\end_inset

, we set up an acct val in our doSave method prior to redirecting.
 If we tried to do something like
\end_layout

\begin_layout LyX-Code
S.redirectTo("/view", () => currentAccountVar(currentAccountVar.is))
\end_layout

\begin_layout Standard
instead, we would get the default value of our RequestVar (null in this
 case).
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We've covered a lot of material and we still have a lot more to go.
 Hopefully this chapter provides a firm basis to start from when exploring
 the rest of the book.
\end_layout

\end_body
\end_document
