#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Advanced Lift Guts
\begin_inset CommandInset label
LatexCommand label
name "cha:Advanced-Lift-Guts"

\end_inset


\end_layout

\begin_layout Section
LiftResponse in Detail
\begin_inset CommandInset label
LatexCommand label
name "sec:LiftResponse-in-Detail"

\end_inset


\end_layout

\begin_layout Standard
Lift framework makes a lot of things really easy and it provides extremly
 useful abstractions as you may have already discovered.
 Responses to clients are also abstacted by LiftResponse trait.
 There are numerous response types and here is the simplified vieew of the
 class hierarchy:
\end_layout

\begin_layout Itemize
LiftResponse
\end_layout

\begin_deeper
\begin_layout Itemize
BasicResponse
\end_layout

\begin_deeper
\begin_layout Itemize
InMemoryResponse
\end_layout

\begin_layout Itemize
StreamingResponse
\end_layout

\end_deeper
\begin_layout Itemize
JSonResponse
\end_layout

\begin_layout Itemize
RedirectResponse
\end_layout

\begin_deeper
\begin_layout Itemize
RedirectWithState
\end_layout

\end_deeper
\begin_layout Itemize
ToResponse
\end_layout

\begin_deeper
\begin_layout Itemize
XhtmlRespomse
\end_layout

\begin_layout Itemize
XmlResponse
\end_layout

\begin_layout Itemize
XmlMimeResponse
\end_layout

\begin_layout Itemize
AtomResponse
\end_layout

\begin_layout Itemize
OpenSearchResponse
\end_layout

\begin_layout Itemize
AtomCreatedResponse
\end_layout

\begin_layout Itemize
AtomCategoryResponse
\end_layout

\begin_layout Itemize
AtomServiceResponse
\end_layout

\begin_layout Itemize
CreatedResponse
\end_layout

\end_deeper
\begin_layout Itemize
OkResponse
\end_layout

\begin_layout Itemize
PermRedirectResponse
\end_layout

\begin_layout Itemize
BadResponse
\end_layout

\begin_layout Itemize
UnauthorizedResponse
\end_layout

\begin_layout Itemize
UnauthorizedDigestResponse
\end_layout

\begin_layout Itemize
NotFoundResponse
\end_layout

\begin_layout Itemize
MethodNotAllowedResponse
\end_layout

\begin_layout Itemize
GoneResponse
\end_layout

\end_deeper
\begin_layout Standard
We won't get into details right now oh what exactly each and every class/object
 does, although their purpose is somehow intuitive.
 It is important to know that whenever you need to return a LiftResponse
 reference from one of your functions, for example LiftRules.dispatch you
 can you can use one of these classes.
 So ultimatelly Lift doesn;t really provide you the HttpServletResponse
 object instead all Lift responses are impersonated by a LiftResponse instance
 and it content (the actual payload, http headers, content-type, cookies
 etc.) is written internally by Lift to the container's output stream.
\end_layout

\begin_layout Section
Session Management 
\begin_inset CommandInset label
LatexCommand label
name "sec:Session-Management"

\end_inset


\end_layout

\begin_layout Standard
Lift is, in essence, a stateful framework and naturally state needs to be
 managed.
 You may already be familiar with HttpSession and and how a J(2)EE web container
 identifies an HttpSession; either by JSESSIONID cookie or by JSESSIONID
 URI sequence (in case of URL rewriting).
 Similarly, Lift uses a LiftSession reference which is not actually 
\begin_inset Quotes eld
\end_inset

persisted
\begin_inset Quotes erd
\end_inset

 in HttpSession.
 As a matter of fact Lift does not really use the HttpSession provided by
 the web container to maintain conversational state but rather uses a 
\begin_inset Quotes eld
\end_inset

bridge
\begin_inset Quotes erd
\end_inset

 between the HttpSession and the LiftSession.
 This 
\begin_inset Quotes eld
\end_inset

bridge
\begin_inset Quotes erd
\end_inset

 is impersonated by SessionToServletBridge class which implements 
\emph on
javax.servlet.http.HttpSessionBindingListener
\emph default
 and 
\emph on
javax.servlet.http.HttpSessionActivationListener
\emph default
.
 The way it works is:
\end_layout

\begin_layout Enumerate
When receiving an HTTP Request and there was no stateless disptach function
 to execute Lift does the statefull processing.
 But before doing that it checks to see if there is a LiftSession associated
 with this http sssion ID.
 This mapping is kept on a SessionMaster Scala actor.
 
\end_layout

\begin_layout Enumerate
If there is no LiftSession in SessionMaster actor, create it and add a SessionTo
ServletBridge attribute on HttpSession.
 This will make Lift to be aware when container terminates the HttpSession
 or when the http session is about to be passivated or activated.
\end_layout

\begin_layout Enumerate
When the container terminates the http session SessionToServletBridge sends
 a message to the SessionMaster actor to terminate the LiftSession.
 Basically the following is taking place:
\end_layout

\begin_deeper
\begin_layout Enumerate
Call LiftSession.onAboutToShutdownSession hooks
\end_layout

\begin_layout Enumerate
Sends ShutDown message to all Comet actors pertaining to this session
\end_layout

\begin_layout Enumerate
Cleanup internal LiftSession state
\end_layout

\begin_layout Enumerate
Call LiftSession.onShutdownSession hooks
\end_layout

\end_deeper
\begin_layout Standard
SessionMaster actor is also protected another watcher actor.
 In essense this watcher actor receives the Exit messages of the watched
 actors.
 When it receives an Exit message it will call the users' failure functions
 and restart the watched actor (Please see ActorWatcher.failureFuncs).
 
\end_layout

\begin_layout Standard
Even so Lift in essence is doing its own session management you still have
 the freedom to manually add attributes to the HttpSession object.
 Still we do not recommend this unless you really have to.
 If you want to keep your own session variables, you can use SessionVar's.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
SessionVar example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

object count extends SessionVar(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// later in your code you can increment the count by calling
\end_layout

\begin_layout Plain Layout

count(count + 1)
\end_layout

\begin_layout Plain Layout

// or obtain the value
\end_layout

\begin_layout Plain Layout

var theCountValue: Int = count
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you've noticed SessionVar-s are typesafe representation of http session
 attributes (actually they are kept in LiftSession and not directly in HttpSessi
on).
 There are implicit conversion functions to convert a SessionVar to its
 underlying type.
\end_layout

\begin_layout Standard
The next question would be 
\begin_inset Quotes eld
\end_inset

So we have internal session management, how do we cope with that in a clustered
 environment? ...
 how sessions are replicated?
\begin_inset Quotes erd
\end_inset

 ...
 well, in short we're are not.
 There is no intentions to use the web container's session replication as
 these technologies appears to be inferior to other solutions on the market.
 Relying on Java serialization brings a lot of performance concerns and
 alternative technologies have been investigated and they are still under
 investigation.
 Until there is a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 advocated session replication technology you can still cluster you application
 using 
\begin_inset Quotes eld
\end_inset

sticky session
\begin_inset Quotes erd
\end_inset

.
 Essentially this meas that all requests pertaining to a HTTP session must
 be processed by the same cluster node.
 This can be done by load balancers (even hardware load balancer) so they
 would dispatch the requests based on JSESSIONID cookie.
 Other approaches are that dispatching is done based on some URI or query
 parameters.
 For example a query parameter like serverid=1 is configured in the load
 balancer to always be dispatched to the node 1 of the cluster, and so on.
 There are some downsides for the sticky session approach.
 For instance you are logged in the application and do your stuff.
 Suddenly the node designated to your session crashes.
 At this moment essentially you lost your session.
 The next subsequent request would be automatically dispatched by the load
 balancer to another cluster node and depending how your application is
 built this may mean that you need to log in again or if part of the state
 was persisted in DB you may resume your work from some point avoiding re-login
 ...
 but this is application specific behavior that is beyond the scope of this
 discussion.
 The advantages of sticky sessions are related with application performance
 since in this model the state does not need to be replicated in all cluster
 nodes which for significant state information can be quite time/resources
 consuming.
\end_layout

\begin_layout Standard
* Additional topics 
\end_layout

\begin_layout Standard
* S.addAround and LoanWrapper 
\end_layout

\begin_layout Standard
* How S.attr works in conjunction with XML attributes on snippets, etc and
 with Rewriting
\end_layout

\begin_layout Standard
This is going to be super-helpful for the later chapters, like WebServices
 and Rewriting.
\end_layout

\end_body
\end_document
