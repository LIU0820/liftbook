#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Web Services
\end_layout

\begin_layout Section
Why Add an API to Your Web Application?
\end_layout

\begin_layout Standard
Many web applications today offer an API
\begin_inset Foot
status open

\begin_layout Plain Layout
Application Programming Interface
\end_layout

\end_inset

 that allows others to extend the functionality of the application.
 An API is a set of exposed functions that is meant to allow third parties
 to reuse elements of the application.
 There is a number of sites that catalog the available APIs, such as Programmabl
eWeb (see 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.programmableweb.com/
\end_layout

\end_inset

).
 An example of a site that has combined the GoogleMaps and Flickr APIs is
 FlickrVision.com
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://flickrvision.com/"
target "http://flickrvision.com/"

\end_inset


\end_layout

\end_inset

.
 FlickrVision allows users to visualize where in the world recent photos
 have been taken by combining the geolocation information embedded in the
 photos and the mapping system of GoogleMaps.
 This is just one example of an API mashup, and there are countless other
 examples.
\end_layout

\begin_layout Standard
We're going to focus on what it takes to offer a simple RESTful web api
 for PocketChange.
\end_layout

\begin_layout Section
A Little Bit about HTTP
\end_layout

\begin_layout Standard
As we build our web service, it will to be helpful to know a few things
 about HTTP
\begin_inset Foot
status open

\begin_layout Plain Layout
Hypertext Transfer Protocol
\end_layout

\end_inset

 requests and responses.
 If you're comfortable with the Request-Response cycle then feel free to
 jump to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:What-is-REST?"

\end_inset

 to get down to business.
\end_layout

\begin_layout Standard
A simplification of how the web works is that clients, typically web browsers,
 send HTTP Requests to servers, which respond with HTTP Responses.
 Let's take a look at an exchange between a client and a server.
\end_layout

\begin_layout Standard
We're going to send a GET request to the URI 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://demo.liftweb.net/
\end_layout

\end_inset

 using the 
\family typewriter
cURL
\family default
 utility.
 We'll enable dumping the HTTP protocol header information so that you can
 see all of the information associated with the request and response.
 The cURL utility sends the output shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:cURL-Output"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
cURL Request
\begin_inset CommandInset label
LatexCommand label
name "lst:cURL-Output"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

]> curl -v http://demo.liftweb.net/ 
\end_layout

\begin_layout Plain Layout

* About to connect() to demo.liftweb.net port 80 (#0) 
\end_layout

\begin_layout Plain Layout

*   Trying 64.27.11.183...
 connected 
\end_layout

\begin_layout Plain Layout

* Connected to demo.liftweb.net (64.27.11.183) port 80 (#0) 
\end_layout

\begin_layout Plain Layout

> GET / HTTP/1.1 
\end_layout

\begin_layout Plain Layout

> User-Agent: curl/7.19.0 (i386-apple-darwin9.5.0) libcurl/7.19.0 zlib/1.2.3 
\end_layout

\begin_layout Plain Layout

> Host: demo.liftweb.net 
\end_layout

\begin_layout Plain Layout

> Accept: */*
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And gets the corresponding response, shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:cURL-Response"

\end_inset

, from the server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
cURL Response
\begin_inset CommandInset label
LatexCommand label
name "lst:cURL-Response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

< HTTP/1.1 200 OK 
\end_layout

\begin_layout Plain Layout

< Server: nginx/0.6.32 
\end_layout

\begin_layout Plain Layout

< Date: Tue, 24 Mar 2009 20:52:55 GMT 
\end_layout

\begin_layout Plain Layout

< Content-Type: text/html 
\end_layout

\begin_layout Plain Layout

< Connection: keep-alive 
\end_layout

\begin_layout Plain Layout

< Expires: Mon, 26 Jul 1997 05:00:00 GMT 
\end_layout

\begin_layout Plain Layout

< Set-Cookie: JSESSIONID=5zrn24obipm5;Path=/ 
\end_layout

\begin_layout Plain Layout

< Content-Length: 8431 
\end_layout

\begin_layout Plain Layout

< Cache-Control: no-cache; private; no-store; 
\end_layout

\begin_layout Plain Layout

  must-revalidate; max-stale=0; post-check=0; pre-check=0; max-age=0 
\end_layout

\begin_layout Plain Layout

< Pragma: no-cache 
\end_layout

\begin_layout Plain Layout

< X-Lift-Version: 0.11-SNAPSHOT 
\end_layout

\begin_layout Plain Layout

<  
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?> 
\end_layout

\begin_layout Plain Layout

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
\end_layout

\begin_layout Plain Layout

 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
\end_layout

\begin_layout Plain Layout

<html xmlns:lift="http://liftweb.net" xmlns="http://www.w3.org/1999/xhtml">
\end_layout

\begin_layout Plain Layout

<head>....
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This seems pretty straightforward: we ask for a resource, and the server
 returns it to us.
 Take a look at the HTTP request.
 We'd like to point out the method called, in this case a 
\family typewriter

\begin_inset Quotes eld
\end_inset

GET
\begin_inset Quotes erd
\end_inset

, 
\family default
and the
\family typewriter
 
\family default
URI,
\family typewriter
 
\family default
which is 
\begin_inset Quotes eld
\end_inset

http://demo.liftweb.net/
\begin_inset Quotes erd
\end_inset

.
 Method calls and addresses are what make the web work.
 You can think of the web as a series of method calls on varying resources,
 where the URI (Uniform Resource Identifier) identifies the resource upon
 which the method will be called.
\end_layout

\begin_layout Standard
Methods are defined as part of the HTTP standard, and we'll use them in
 our API.
 In addition to 
\family typewriter
GET
\family default
, the other HTTP methods are 
\family typewriter
POST
\family default
, 
\family typewriter
DELETE
\family default
, 
\family typewriter
PUT
\family default
, 
\family typewriter
HEAD
\family default
, and
\family typewriter
 OPTIONS
\family default
.
 You may also see methods referred to as actions or verbs.
 In this chapter, we will focus on using 
\family typewriter
GET
\family default
 and 
\family typewriter
PUT
\family default
 for our API.
 
\end_layout

\begin_layout Standard
As do Requests, Responses come with a few important pieces of information.
 Of note are the Response Code and the Entity Body.
 In the above example, the Response Code is 
\begin_inset Quotes eld
\end_inset


\family typewriter
200 OK
\family default

\begin_inset Quotes erd
\end_inset

 and the Entity Body is the HTML content of the webpage, which is shown
 as the last two lines starting with 
\begin_inset Quotes eld
\end_inset


\family typewriter
<!DOCTYPE
\family default
.
\begin_inset Quotes erd
\end_inset

 We've truncated the HTML content here to save space.
\end_layout

\begin_layout Standard
This was a quick overview of HTTP, but if you'd like to learn more, take
 a look at the protocol definition found at
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.ietf.org/rfc/rfc2616.txt
\end_layout

\end_inset

.
 We wanted to point out a few of the interesting parts of the cycle before
 we got into building a REST API.
\end_layout

\begin_layout Section
Defining REST
\begin_inset CommandInset label
LatexCommand label
name "sec:What-is-REST?"

\end_inset


\end_layout

\begin_layout Standard
Roy Fielding defined REST in his dissertation and defined the main tenet
 of the architecture to be a uniform interface to resources.
 “Resources” refers to pieces of information that are named and have representat
ions.
 Examples include an image, a Twitter status, or a timely item such as a
 stock quote or the current temperature.
 The uniform interface is supported by a set of constraints that include
 the following: 
\end_layout

\begin_layout Itemize
Statelessness of communication: This is built on top of HTTP, which is also
 stateless.
 
\end_layout

\begin_layout Itemize
Client-server–style interaction: Again, just as the Web consists of browsers
 talking to servers, REST discusses machines or applications talking to
 servers in the same way.
 
\end_layout

\begin_layout Itemize
Support for caching: REST uses the caching headers of HTTP to support the
 caching of resources.
 
\end_layout

\begin_layout Standard
These features are shared by both the web and by RESTful services.
 REST adds additional constraints regarding interacting with resources:
\end_layout

\begin_layout Itemize
Naming: As we mentioned, a resource must be identified, and this is done
 using URLs.
 
\end_layout

\begin_layout Itemize
Descriptive actions: Using the HTTP actions, GET, PUT, and DELETE makes
 it obvious what action is being performed on the resource.
 
\end_layout

\begin_layout Itemize
URL addressability: URLs should allow for the addressing of representation
 of a resource.
 
\end_layout

\begin_layout Standard
Fielding’s goal was to define a method that allowed machine-to-machine communica
tion to mimic that of browser-to-server communication and to take advantage
 of HTTP as the underlying protocol.
 You can find Fielding’s dissertation at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
You’ll see how Lift allows you to create RESTful web services in the rest
 of this chapter.
 
\end_layout

\begin_layout Section
Comparing XML-RPC to REST Architectures
\end_layout

\begin_layout Standard
What, then, is the difference between a RESTful architecture and a traditional
 RPC
\begin_inset Foot
status open

\begin_layout Plain Layout
Remote Procedure Call
\end_layout

\end_inset

 architecture? 
\end_layout

\begin_layout Standard
An RPC application follows a more traditional software development pattern.
 It ignores most of the features offered by HTTP, such as the HTTP methods.
 Instead, the scoping and data to be used by the call are contained in the
 body of a POST request.
 XML-RPC works similarly to the web for 
\emph on
getting
\emph default
 resources, but breaks from the HTTP model for everything else by overloading
 the POST request.
 You will often see the term SOAP when referring to an XML-RPC setup, because
 SOAP permits the developer to define the action and the resource in the
 body of the request and ignore the HTTP methods.
\end_layout

\begin_layout Standard
RESTful architectures embrace HTTP.
 We're using the web; we may as well take advantage of it.
\end_layout

\begin_layout Section
A Simple API for PocketChange
\end_layout

\begin_layout Standard
We're going to start with a simple example, but we're going to skip some
 of the more complex steps of building a web service, such as authorization.
\end_layout

\begin_layout Standard
We're going to model two calls to the server: a GET request that responds
 with the details of an expense, and a PUT to add a new expense.The URLs
 will be:
\end_layout

\begin_layout Itemize
A GET request sent to URI: 
\end_layout

\begin_deeper
\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense/<expense_id>
\end_layout

\begin_layout Standard
where 
\family typewriter
expense_id
\family default
 is the Expense ID
\end_layout

\end_deeper
\begin_layout Itemize
A PUT request + an XML Body sent to URI:
\end_layout

\begin_deeper
\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense
\end_layout

\end_deeper
\begin_layout Standard
The URLs are almost the same and as we will show, we can pattern-match on
 the type of request in addition to the URI.
\end_layout

\begin_layout Standard
\align center
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note that a URL (Uniform Resource Locator) is a type of URI in which the
 URI also serves to locate the resource on the web.
 A URN (Uniform Resource Name) is another type of URI that provides a unique
 name to a resource without specifying an actual location, though it may
 look a lot like a URL.
 For more information on the distinctions among URIs, see 
\begin_inset CommandInset href
LatexCommand href
target "http://en.wikipedia.org/wiki/Uniform_Resource_Name"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pattern Matching for the URLs
\end_layout

\begin_layout Standard
Now that we've discussed our design, let's see the code that will handle
 the routing.
 In the package 
\family typewriter
com.pocketchangeapp.api
\family default
, we have an object named 
\family typewriter
RestAPI, which we've
\family default
 defined in 
\family typewriter
com/pocketchangeapp/api/RestAPI.scala
\family default
.
\end_layout

\begin_layout Standard
The block of code to handle the routing is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:REST-Method-Routing"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
REST Method Routing
\begin_inset CommandInset label
LatexCommand label
name "lst:REST-Method-Routing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

package com.pocketchangeapp.api
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
 standard imports...
\end_layout

\begin_layout Plain Layout

import net.liftweb.http.rest.XMLApiHelper
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object RestAPI extends XMLApiHelper {
\end_layout

\begin_layout Plain Layout

  def dispatch: LiftRules.DispatchPF = {     
\end_layout

\begin_layout Plain Layout

    case Req(List("api", "expense", eid), "", GetRequest) => 
\end_layout

\begin_layout Plain Layout

      () => showExpense(eid) 
\end_layout

\begin_layout Plain Layout

    case r @ Req(List("api", "expense", "", PutRequest) => 
\end_layout

\begin_layout Plain Layout

      () => addExpense(r)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Invalid API request - route to our error handler
\end_layout

\begin_layout Plain Layout

    case Req(List("api", _), "", _) => failure _ 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The server will now service 
\family typewriter
GET
\family default
 requests with 
\family typewriter
showExpense
\family default
 and will handle 
\family typewriter
PUT
\family default
 requests with the 
\family typewriter
addExpense
\family default
 method (which we'll define later in this chapter).
 One thing to note is we are pattern matching on the 
\family typewriter
Req
\family default
 object and in the 
\family typewriter
PUT
\family default
 request, we extract the 
\family typewriter
Req
\family default
 and pass it as a parameter to 
\family typewriter
addExpense
\family default
.
 This is because we're passing in an XML body with the information for the
 
\family typewriter
Expense
\family default
.
\end_layout

\begin_layout Standard
As we discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

, Lift uses dispatch rules to route requests.
 Because we want to intercept and reroute requests to certain URLs, we need
 to update the dispatch rules.
\end_layout

\begin_layout Standard
This is accomplished by adding the code shown in Listing to 
\family typewriter
Boot.scala
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Setting up REST Dispatch
\begin_inset CommandInset label
LatexCommand label
name "lst:Setting-up-REST"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import com.pocketchangeapp.api.RestAPI
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    LiftRules.dispatch.prepend(RestAPI.dispatch) 
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will cause Lift to intercept incoming requests to URIs beginning with
 
\family typewriter
/api/
\family default
 and to pass them along to the appropriate methods.
\end_layout

\begin_layout Section
API Service Code
\end_layout

\begin_layout Standard
Now that we're handling the API calls, we'll need to write the code to process
 and respond to requests.
 In 
\family typewriter
RestAPI.scala
\family default
, we'll add the methods shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:REST-Handler-Methods"

\end_inset

 to the 
\family typewriter
RestAPI
\family default
 object:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

REST Handler Methods
\begin_inset CommandInset label
LatexCommand label
name "lst:REST-Handler-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
// reacts to the GET Request
\end_layout

\begin_layout Plain Layout
def showExpense(eid: String): LiftResponse = { 
\end_layout

\begin_layout Plain Layout
  val e: Box[NodeSeq] = 
\end_layout

\begin_layout Plain Layout

    
\lang english
for(r <- Expense.find(By(Expense.id, eid.toLong))) yield { 
\end_layout

\begin_layout Plain Layout
     wrapXmlBody(
\end_layout

\begin_layout Plain Layout

       
\lang english
<operation id="show_expense" success="true">{e.toXML}</operation>) 
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout
  
\end_layout

\begin_layout Plain Layout
  e
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
private def getAccount(e: String, n: String): Account = {     
\end_layout

\begin_layout Plain Layout
  val u = User.find(By(User.email, e))         
\end_layout

\begin_layout Plain Layout
  val a = Account.findByName(u.open_!, n) match {       
\end_layout

\begin_layout Plain Layout
    case acct :: Nil => acct       
\end_layout

\begin_layout Plain Layout
    case _ => new Account     
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
  a   
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
  
\end_layout

\begin_layout Plain Layout
// reacts to the PUT Request   
\end_layout

\begin_layout Plain Layout
def addExpense(req: Req): LiftResponse = {     
\end_layout

\begin_layout Plain Layout
  var tempEmail = ""     
\end_layout

\begin_layout Plain Layout
  var tempAccountName = ""
\end_layout

\begin_layout Plain Layout
  var expense = new Expense     
\end_layout

\begin_layout Plain Layout
  req.xml match {       
\end_layout

\begin_layout Plain Layout
    case Full(<expense>{parameters @ _*}</expense>) => {         
\end_layout

\begin_layout Plain Layout
      for(parameter <- parameters){ 
\end_layout

\begin_layout Plain Layout
        parameter match {           
\end_layout

\begin_layout Plain Layout
          case <email>{email}</email> => tempEmail = email.text         
  
\end_layout

\begin_layout Plain Layout
          case <accountName>{name}</accountName> => tempAccountName = name.text
   
\end_layout

\begin_layout Plain Layout
          case <dateOf>{dateof}</dateOf> => 
\end_layout

\begin_layout Plain Layout
            expense.dateOf(new java.util.Date(dateof.text)     
\end_layout

\begin_layout Plain Layout
          case <amount>{value}</amount> => expense.amount(BigDecimal(value.text))
   
\end_layout

\begin_layout Plain Layout
          case <desc>{description}</desc> => expense.description(description.text)
   
\end_layout

\begin_layout Plain Layout
          case _ =>         
\end_layout

\begin_layout Plain Layout
        }       
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
      try {         
\end_layout

\begin_layout Plain Layout
        val currentAccount = getAccount(tempEmail, tempAccountName)    
     
\end_layout

\begin_layout Plain Layout
        expense.account(currentAccount.id.is)
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        val (entrySerial,entryBalance) = Expense.getLastExpenseData(currentAccoun
t,
\end_layout

\begin_layout Plain Layout
          expense.dateOf)
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        expense.account(currentAccount).serialNumber(entrySerial + 1)
\end_layout

\begin_layout Plain Layout
          .tags("api").currentBalance(entryBalance + expense.amount)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
        expense.validate match {           
\end_layout

\begin_layout Plain Layout
          case Nil =>             
\end_layout

\begin_layout Plain Layout
            Expense.updateEntries(entrySerial + 1, expense.amount.is)     
        
\end_layout

\begin_layout Plain Layout
            expense.save             
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
            val newBalance = currentAccount.balance.is + expense.amount.is
\end_layout

\begin_layout Plain Layout
            currentAccount.balance(newBalance).save 
\end_layout

\begin_layout Plain Layout
           
\end_layout

\begin_layout Plain Layout
            CreatedResponse(
\end_layout

\begin_layout Plain Layout
              wrapXmlBody(<operation id="add_expense" success="true"></operation
>),
\end_layout

\begin_layout Plain Layout
              "text/xml")           
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
          case _ =>             
\end_layout

\begin_layout Plain Layout
            CreatedResponse(wrapXmlBody(<operation id="add_expense"
\end_layout

\begin_layout Plain Layout
              success="false"></operation>), "text/xml")         
\end_layout

\begin_layout Plain Layout
        }       
\end_layout

\begin_layout Plain Layout
      }       
\end_layout

\begin_layout Plain Layout
      catch {         
\end_layout

\begin_layout Plain Layout
        case e => Log.error("Could not add expense", e); BadResponse()  
     
\end_layout

\begin_layout Plain Layout
      }     
\end_layout

\begin_layout Plain Layout
    }     
\end_layout

\begin_layout Plain Layout
    case _ => Log.error("Request was malformed"); BadResponse()     
\end_layout

\begin_layout Plain Layout
  }   
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Section
A Helper Method for the Expense Model Object
\end_layout

\begin_layout Standard
To make it easier to get the name of the Account we care about, we'll add
 a helper function to our 
\family typewriter
Expense
\family default
 model object, as shown in Listing :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Expense Entity REST Helper
\begin_inset CommandInset label
LatexCommand label
name "lst:Expense-Entity-REST"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
// look up the account name for the expense
\end_layout

\begin_layout Plain Layout
private def getAccountName(id: Long): String = {     
\end_layout

\begin_layout Plain Layout
  Account.find(By(Account.id, id)) match {       
\end_layout

\begin_layout Plain Layout
    case Empty => "No Account Name"       
\end_layout

\begin_layout Plain Layout
    case Full(a) => a.name.is     
\end_layout

\begin_layout Plain Layout
  }   
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
 
\end_layout

\begin_layout Plain Layout
// get a list of tags of the form <tag>tagname1</tag><tag>tagname2</tag>
\end_layout

\begin_layout Plain Layout
def showXMLTags: NodeSeq = tags.map(t => <tag>{t.name.is}</tag>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
// 
\end_layout

\begin_layout Plain Layout
def toXML: NodeSeq = {    
\end_layout

\begin_layout Plain Layout
  val id = "http://www.pocketchangeapp.com/api/expense/" + this.id    
\end_layout

\begin_layout Plain Layout
  val formatter = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
    
\end_layout

\begin_layout Plain Layout
  val edate = formatter.format(this.dateOf.is)
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
  <expense>       
\end_layout

\begin_layout Plain Layout
    <id>{id}</id>       
\end_layout

\begin_layout Plain Layout
    <accountname>{getAccountName(account.is)}</accountname>       
\end_layout

\begin_layout Plain Layout
    <date>{edate}</date>       
\end_layout

\begin_layout Plain Layout
    <description>{description.is}</description>       
\end_layout

\begin_layout Plain Layout
    <amount>{amount.is.toString}</amount>       
\end_layout

\begin_layout Plain Layout
    <tags>{showXMLTags}</tags>     
\end_layout

\begin_layout Plain Layout
  </expense>
\end_layout

\begin_layout Plain Layout
}  
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Request and Response Cycles for Our API
\end_layout

\begin_layout Standard
At the beginning of this chapter, we showed you a request and response conversat
ion for 
\family typewriter

\begin_inset Newline linebreak
\end_inset

http://demo.liftweb.net/
\family default
.
 Let’s see what that looks like for a request to our API; see Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Request-and-Response-GET"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Request and Response for GET for Our API
\begin_inset CommandInset label
LatexCommand label
name "lst:Request-and-Response-GET"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

Request:
\end_layout

\begin_layout Plain Layout

http://www.pocketchangeapp.com/api/expense/3 GET
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Response:
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?> 
\end_layout

\begin_layout Plain Layout

<pca_api operation="expense" success="true" >
\end_layout

\begin_layout Plain Layout

 <operation success="true" id="show_expense">
\end_layout

\begin_layout Plain Layout

  <expense> 
\end_layout

\begin_layout Plain Layout

   <id>http://www.pocketchangeapp.com/api/expense/3</id> 
\end_layout

\begin_layout Plain Layout

   <accountname>Home</accountname> 
\end_layout

\begin_layout Plain Layout

   <date>2009-03-26T00:00:00Z</date> 
\end_layout

\begin_layout Plain Layout

   <description>MacHeist Apps</description> 
\end_layout

\begin_layout Plain Layout

   <amount>35.00</amount> 
\end_layout

\begin_layout Plain Layout

   <tags> 
\end_layout

\begin_layout Plain Layout

    <tag>software</tag>
\end_layout

\begin_layout Plain Layout

    <tag>apps</tag>
\end_layout

\begin_layout Plain Layout

    <tag>mac</tag> 
\end_layout

\begin_layout Plain Layout

   </tags> 
\end_layout

\begin_layout Plain Layout

  </expense>
\end_layout

\begin_layout Plain Layout

 </operation>
\end_layout

\begin_layout Plain Layout

</pca_api> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Request-and-Response-PUT"

\end_inset

 shows the output for a PUT conversation:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Request and Response for PUT for Our API
\begin_inset CommandInset label
LatexCommand label
name "lst:Request-and-Response-PUT"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

Request:
\end_layout

\begin_layout Plain Layout

http://www.pocketchangeapp.com/api/expense - PUT - addEntry(request) + XML
 Body
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Request Body:
\end_layout

\begin_layout Plain Layout

<expense> 
\end_layout

\begin_layout Plain Layout

  <email>tyler.weir@pocketchangeapp.com</email> 
\end_layout

\begin_layout Plain Layout

  <accountName>Home</accountName> 
\end_layout

\begin_layout Plain Layout

  <dateOf>2009/03/26</dateOf> 
\end_layout

\begin_layout Plain Layout

  <amount>45.00</amount> 
\end_layout

\begin_layout Plain Layout

  <desc>I buy food</desc> 
\end_layout

\begin_layout Plain Layout

</expense>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Response:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HTTP/1.1 201 Created
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<pca_api>
\end_layout

\begin_layout Plain Layout

  <operation success="true" id="add_expense"></operation>
\end_layout

\begin_layout Plain Layout

</pca_api>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Extending the API to Return Atom Feeds
\end_layout

\begin_layout Standard
What if you’d like to return your data in a different format than XML? For
 this example, we’ll add support for Atom
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://tools.ietf.org/html/rfc4287"

\end_inset


\end_layout

\end_inset

.
 Atom is a simple publishing standard for content syndication.
 To change the data output format, you’ll have to do two things.
 First, define the helper or helpers that are common across output formats.
 After that, update the dispatch rules to allow users to request the alternate
 data formats.
\end_layout

\begin_layout Standard
In our case, we’ll first add toAtom to the model as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:The-toAtom-Method"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

The toAtom Method
\begin_inset CommandInset label
LatexCommand label
name "lst:The-toAtom-Method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def toAtom = {    
\end_layout

\begin_layout Plain Layout

  val id = "http://www.pocketchangeapp.com/api/expense/" + this.id    
\end_layout

\begin_layout Plain Layout

  val formatter = new  SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")    
\end_layout

\begin_layout Plain Layout

  val edate = formatter.format(this.dateOf.is)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  <entry xmlns="http://www.w3.org/2005/Atom">     
\end_layout

\begin_layout Plain Layout

    <expense>       
\end_layout

\begin_layout Plain Layout

      <id>{id}</id>       
\end_layout

\begin_layout Plain Layout

      <accountname>{getAccountName(account.is)}</accountname>       
\end_layout

\begin_layout Plain Layout

      <date>{edate}</date>       
\end_layout

\begin_layout Plain Layout

      <description>{description.is}</description>       
\end_layout

\begin_layout Plain Layout

      <amount>{amount.is.toString}</amount>       
\end_layout

\begin_layout Plain Layout

      <tags>{showXMLTags}</tags>      
\end_layout

\begin_layout Plain Layout

    </expense>     
\end_layout

\begin_layout Plain Layout

  </entry>   
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And we'll have to modify the dispatch rules to add a format selection in
 the URI.
 We'll leave plain XML as the default response, and we'll add a way to select
 XML or Atom.
\end_layout

\begin_layout Standard
The URIs for GET will now be as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:New-Format-Selection"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

New Format Selection URLs
\begin_inset CommandInset label
LatexCommand label
name "lst:New-Format-Selection"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

http://www.pocketchangeapp.com/api/expense/<eid>
\end_layout

\begin_layout Plain Layout

http://www.pocketchangeapp.com/api/expense/<eid>/xml
\end_layout

\begin_layout Plain Layout

http://www.pocketchangeapp.com/api/expense/<eid>/atom
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the additions to the dispatch are shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:The-Modified-Dispatch"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

The Modified Dispatch Function
\begin_inset CommandInset label
LatexCommand label
name "lst:The-Modified-Dispatch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

object RestAPI extends XMLApiHelper {
\end_layout

\begin_layout Plain Layout

  def dispatch: LiftRules.DispatchPF = {     
\end_layout

\begin_layout Plain Layout

    case Req(List("api", "expense", eid), "", GetRequest) => 
\end_layout

\begin_layout Plain Layout

      () => showExpenseXml(eid) // old
\end_layout

\begin_layout Plain Layout

    case Req(List("api", "expense", eid, 
"

xml
"

), "", GetRequest) => 
\end_layout

\begin_layout Plain Layout

      () => showExpenseXml(eid) // new
\end_layout

\begin_layout Plain Layout

    case Req(List("api", "expense", eid, 
"

atom
"

), "", GetRequest) => 
\end_layout

\begin_layout Plain Layout

      () => showExpenseAtom(eid) // new
\end_layout

\begin_layout Plain Layout

    case r @ Req(List("api", "expense", eid), "", PutRequest) => 
\end_layout

\begin_layout Plain Layout

      () => addExpense(eid, r)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Invalid API request - route to our error handler
\end_layout

\begin_layout Plain Layout

    case Req(List("api", _), "", _) => failure _ 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, we'll add 
\family typewriter
showExpenseAtom
\family default
, and rename 
\family typewriter
showExpense
\family default
 to 
\family typewriter
showExpenseXml
\family default
, as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:New-Show-Methods"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

New Show Methods
\begin_inset CommandInset label
LatexCommand label
name "lst:New-Show-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def showExpenseXml(eid: String): LiftResponse = {     
\end_layout

\begin_layout Plain Layout

  val e: Box[NodeSeq] = for(e <- Expense.find(By(Expense.id, eid.toLong)))
      
\end_layout

\begin_layout Plain Layout

    yield {       
\end_layout

\begin_layout Plain Layout

      XmlResponse(
\end_layout

\begin_layout Plain Layout

        <operation id="show_expense_xml" success="true">{r.toXML}</operation>)
     
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  e    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def showExpenseAtom(eid: String): AtomResponse = {     
\end_layout

\begin_layout Plain Layout

  val e: Box[Node] = for(e <- Expense.find(By(Expense.id, eid.toLong))) yield
 {       
\end_layout

\begin_layout Plain Layout

    e.toAtom
\end_layout

\begin_layout Plain Layout

  }     
\end_layout

\begin_layout Plain Layout

  AtomResponse(e.open_!)   
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's take a look at a request and response for an Atom-ized entry, as shown
 in Listing .
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Atom Request and Response
\begin_inset CommandInset label
LatexCommand label
name "lst:Atom-Request-and"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

Request:
\end_layout

\begin_layout Plain Layout

GET http://localhost:8080/api/expense/10/atom
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Response:
\end_layout

\begin_layout Plain Layout

Expires    Thu, 01 Jan 1970 00:00:00 GMT 
\end_layout

\begin_layout Plain Layout

Set-Cookie    JSESSIONID=1bq219bmoevv1;Path=/ 
\end_layout

\begin_layout Plain Layout

Content-Length    353 
\end_layout

\begin_layout Plain Layout

Content-Type    application/atom+xml 
\end_layout

\begin_layout Plain Layout

X-Lift-Version    
\end_layout

\begin_layout Plain Layout

0.11-SNAPSHOT Server    
\end_layout

\begin_layout Plain Layout

Jetty(6.1.15.rc3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<entry xmlns="http://www.w3.org/2005/Atom">     
\end_layout

\begin_layout Plain Layout

 <expense>       
\end_layout

\begin_layout Plain Layout

  <id>http://www.pocketchangeapp.com/api/expense/10</id>       
\end_layout

\begin_layout Plain Layout

  <accountname>Home</accountname>       
\end_layout

\begin_layout Plain Layout

  <date>2009-03-26T00:00:00Z</date>       
\end_layout

\begin_layout Plain Layout

  <description>I buy food</description>       
\end_layout

\begin_layout Plain Layout

  <amount>45.00</amount>       
\end_layout

\begin_layout Plain Layout

  <tags>         
\end_layout

\begin_layout Plain Layout

   <tag>api</tag>       
\end_layout

\begin_layout Plain Layout

  </tags>      
\end_layout

\begin_layout Plain Layout

 </expense>     
\end_layout

\begin_layout Plain Layout

</entry>  
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this chapter, we outlined a RESTful API for a web application and showed
 how to implement one using Lift.
 We then extended that API to return Atom in addition to XML.
 If you want to expand the API beyond what we’ve done here, some logical
 extensions would be a full authentication layer or transforming the data
 to another format, such as JSON.
 
\end_layout

\end_body
\end_document
