#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Web Services
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
This chapter is still under active development.
 The contents will change.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Todo:
\end_layout

\begin_layout Plain Layout
- finish
\end_layout

\end_inset


\end_layout

\begin_layout Section
Why add an API to your Web Application?
\end_layout

\begin_layout Standard
Many Web Applications now offer an API
\begin_inset Foot
status open

\begin_layout Plain Layout
Application Programming Interface
\end_layout

\end_inset

 that allows others to extend the functionality of the site.
 Building an application that adds to an existing one is usually called
 a Mash-up.
 One famous mash-up is FlickrVision.com/
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://flickrvision.com/"
target "http://flickrvision.com/"

\end_inset


\end_layout

\end_inset

 which combines GoogleMaps and Flickr that allows users to visualize where
 in the world photos are being uploaded.
 
\end_layout

\begin_layout Standard
Typically, when discussing Web Services, two types of services discussed,
 those that follow XML-RPC and those that are RESTful.
 We'll focus on REST and show you how you can easily add an API to your
 application.
\end_layout

\begin_layout Section
Plumbing Details
\end_layout

\begin_layout Standard
In building our web service it's going to help to know a few things about
 HTTP requests and responses.
 If you're comfortable with the Request-Response cycle and their details
 then feel free to jump to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:What-is-REST?"

\end_inset

 and get down to business.
\end_layout

\begin_layout Standard
A simplification of how the web works is clients send HTTP requests servers,
 which respond with HTTP Responses.
 Let's take a look at an exchange between a client and a server.
\end_layout

\begin_layout Standard
We're going to send a GET request to the URI http://demo.liftweb.net/ using
 the cURL utility.
 We can dump the header information and we get the following request:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
\begin_inset Caption

\begin_layout Plain Layout
GET Request
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
]> curl -v http://demo.liftweb.net/ 
\end_layout

\begin_layout LyX-Code
* About to connect() to demo.liftweb.net port 80 (#0) 
\end_layout

\begin_layout LyX-Code
*   Trying 64.27.11.183...
 connected 
\end_layout

\begin_layout LyX-Code
* Connected to demo.liftweb.net (64.27.11.183) port 80 (#0) 
\end_layout

\begin_layout LyX-Code
> GET / HTTP/1.1 
\end_layout

\begin_layout LyX-Code
> User-Agent: curl/7.19.0 (i386-apple-darwin9.5.0) libcurl/7.19.0 zlib/1.2.3 
\end_layout

\begin_layout LyX-Code
> Host: demo.liftweb.net 
\end_layout

\begin_layout LyX-Code
> Accept: */*
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And then the corresponding response from the server follows:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
\begin_inset Caption

\begin_layout Plain Layout
GET Response
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
< HTTP/1.1 200 OK 
\end_layout

\begin_layout LyX-Code
< Server: nginx/0.6.32 
\end_layout

\begin_layout LyX-Code
< Date: Tue, 24 Mar 2009 20:52:55 GMT 
\end_layout

\begin_layout LyX-Code
< Content-Type: text/html 
\end_layout

\begin_layout LyX-Code
< Connection: keep-alive 
\end_layout

\begin_layout LyX-Code
< Expires: Mon, 26 Jul 1997 05:00:00 GMT 
\end_layout

\begin_layout LyX-Code
< Set-Cookie: JSESSIONID=5zrn24obipm5;Path=/ 
\end_layout

\begin_layout LyX-Code
< Content-Length: 8431 
\end_layout

\begin_layout LyX-Code
< Cache-Control: no-cache; private; no-store; must-revalidate; max-stale=0;
 post-check=0; pre-check=0; max-age=0 
\end_layout

\begin_layout LyX-Code
< Pragma: no-cache 
\end_layout

\begin_layout LyX-Code
< X-Lift-Version: 0.11-SNAPSHOT 
\end_layout

\begin_layout LyX-Code
<  
\end_layout

\begin_layout LyX-Code
<?xml version="1.0" encoding="UTF-8"?> 
\end_layout

\begin_layout LyX-Code
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/T
R/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns:lift="http://liftweb.net"
 xmlns="http://www.w3.org/1999/xhtml"><head>....
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parts of an HTTP request that we'd like to point on are the action,
 in this case a 
\family typewriter

\begin_inset Quotes eld
\end_inset

GET
\begin_inset Quotes erd
\end_inset

, 
\family default
and the
\family typewriter
 
\family default
URI
\family typewriter
 
\family default
which is 
\begin_inset Quotes eld
\end_inset

http://demo.liftweb.net/
\begin_inset Quotes erd
\end_inset

.
 Actions are defined as part of the protocol and we'll use them in our API.
 The other HTTP actions, which are sometimes called verbs, are POST, DELETE,
 PUT, HEAD, OPTIONS.
 In this chapter we will focus on using GET and PUT in the API.
 
\end_layout

\begin_layout Standard
You can probably guess from the naming that 
\family typewriter
a GET
\family default
 request gets a resource from the server and that a 
\family typewriter
PUT
\family default
 request puts a resource.
 These actions are operations that we would like to perform on the 
\family typewriter
URI
\family default
.
\end_layout

\begin_layout Standard
Responses come with a few important pieces of information, of note right
 now are the Response code and the Entity Body.
 In this case the Response Code is 
\begin_inset Quotes eld
\end_inset


\family typewriter
200 OK
\family default

\begin_inset Quotes erd
\end_inset

 and the Entity Body is the HTML content of the webpage, which is shown
 as the last two lines starting with 
\begin_inset Quotes eld
\end_inset


\family typewriter
<!DOCTYPE
\family default

\begin_inset Quotes erd
\end_inset

 and truncated.
\end_layout

\begin_layout Section
Comparing XML-RPC to REST architectures
\end_layout

\begin_layout Standard
So what is the difference between RESTful architectures and a traditional
 RPC
\begin_inset Foot
status open

\begin_layout Plain Layout
Remote Procedure Call
\end_layout

\end_inset

 architecture? 
\end_layout

\begin_layout Standard
An RPC appliction is more closely related to traditional development.
 It tends to ignore most of the features offered by HTTP such as the methods.
 Rather, the scoping and data for the request is contained in the body of
 the POST.
 XML-RPC acts like the web for getting things, but breaks from those tenets
 for everything else, by overloading the POST request.
\end_layout

\begin_layout Standard
RESTful architectures embrace HTTP and use it to their advantage.
 Since we're using that web, we may as well act like it.
\end_layout

\begin_layout Standard
RPC example:
\end_layout

\begin_layout Standard
REST example:
\end_layout

\begin_layout Section
What is REST?
\begin_inset CommandInset label
LatexCommand label
name "sec:What-is-REST?"

\end_inset


\end_layout

\begin_layout Standard
Wikipedia defines REST as:
\end_layout

\begin_layout Quotation
[...] a style of software architecture for distributed hypermedia systems such
 as the World Wide Web.
 As such, it is not strictly a method for building "web services".
 The terms "representational state transfer" and "REST" were introduced
 in 2000 in the doctoral dissertation of Roy Fielding
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
\end_layout

\end_inset

, one of the principal authors of the Hypertext Transfer Protocol (HTTP)
 specification.
 
\end_layout

\begin_layout Quotation
REST strictly refers to a collection of network architecture principles
 which outline how resources are defined and addressed.
 The term is often used in a looser sense to describe any simple interface
 which transmits domain-specific data over HTTP without an additional messaging
 layer such as SOAP or session tracking via HTTP cookies.
 These two meanings can conflict as well as overlap.
 It is possible to design a software system in accordance with Fielding's
 REST architectural style without using HTTP and without interacting with
 the World Wide Web.[2] It is also possible to design simple XML+HTTP interfaces
 which do not conform to REST principles, and instead follow a model of
 remote procedure call.
 The difference between the uses of the term "REST" therefore causes some
 confusion in technical discussions.
 
\end_layout

\begin_layout Quotation
Systems which follow Fielding's REST principles are often referred to as
 "RESTful".
\end_layout

\begin_layout Standard
----------------
\end_layout

\begin_layout Standard
Q.
 What action should I take?
\end_layout

\begin_layout Standard
A.
 HTTP verbs or actions.
\end_layout

\begin_layout Standard
The first question is how the client can convey its intentions to the server.
 How does the server know a certain request is a request to retrieve some
 data, instead of a request to delete that same data or to overwrite it
 with different data? Why should the server do this instead of doing that?
\end_layout

\begin_layout Standard
----------------
\end_layout

\begin_layout Standard
Q.
 What data shall I apply the action to?
\end_layout

\begin_layout Standard
A.
 Entity body
\end_layout

\begin_layout Standard
how the client tells the server which part of the data set to operate on.
 Given that the server understands that the client wants to (say) delete
 some data, how can it know which data the client wants to delete? Why should
 the server operate on this data instead of that data? 
\end_layout

\begin_layout Standard
REST relies on the action of the request to be defined by the HTTP action
 and the resources to be defined in the URI.
 For example, a request like 
\end_layout

\begin_layout Section
What is ROA REST?
\end_layout

\begin_layout Standard
What we care about for ROA REST:
\end_layout

\begin_layout Standard

\series bold
Concepts
\end_layout

\begin_layout Enumerate
Resources
\end_layout

\begin_layout Enumerate
Their names (URIs) 
\end_layout

\begin_layout Enumerate
Their representations 
\end_layout

\begin_layout Enumerate
The links between them 
\end_layout

\begin_layout Standard

\series bold
And Properties: 
\end_layout

\begin_layout Enumerate
Addressability 
\end_layout

\begin_layout Enumerate
Statelessness 
\end_layout

\begin_layout Enumerate
Connectedness 
\end_layout

\begin_layout Enumerate
A uniform interface 
\end_layout

\begin_layout Section
A simple API for PocketChange
\end_layout

\begin_layout Standard
We're going to start out with a simple example.
 We'd like to skip some of the more complex steps of a web service at the
 start, in particular, authorization.
 We'll add it later, but for right now, we'd like to illustrate how to get
 stuff out of the server.
 
\end_layout

\begin_layout Standard
We'd going to model two calls to the server, a GET request that responds
 with the transaction details and a PUT to add an expense.
 
\end_layout

\begin_layout Standard
The URLs will be:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
A GET request sent to URI: 
\end_layout

\begin_layout LyX-Code
  http://www.pocketchangeapp.com/api/expense/<expense_id> where expense_id
 is the Expense Id
\end_layout

\begin_layout LyX-Code
A PUT request + an XML Body sent to URI:
\end_layout

\begin_layout LyX-Code
  http://www.pocketchangeapp.com/api/expense/<expense_id> again expense_id
 is the Expense Id
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This set-up will allow 3rd party applications, such as widgets or AIR applicatio
ns interact with our server programmatically, like the multitude of dedicated
 clients for Twitter.
 The URLs are the same, but as we will show, we can pattern-match on the
 type of request.
 In this case, we act upon a GET and a PUT differently.
\end_layout

\begin_layout Section
Pattern matching for the API URLs
\end_layout

\begin_layout Standard
Now that we've discussed our design, let's see the code that will handle
 the routing.
 In the package com.pocketchangeapp.api, we have a cl named RestAPI living
 in RestAPI.scala.
\end_layout

\begin_layout Standard
The block of code to handle the routing follows:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object RestAPI extends XMLApiHelper {
\end_layout

\begin_layout LyX-Code
  def dispatch: LiftRules.DispatchPF = {     
\end_layout

\begin_layout LyX-Code
    case Req("api" :: "expense" :: eid :: Nil, "", GetRequest) => () =>
 showExpense(eid) 
\end_layout

\begin_layout LyX-Code
    case r @ Req("api" :: "expense" :: eid :: Nil, "", PutRequest) => ()
 => addExpense(eid, r)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    // Invalid API request - route to our error handler
\end_layout

\begin_layout LyX-Code
    case Req("api" :: x :: Nil, "", _) => failure _ 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The server to now service GET requests with showAccountBalance and PUT requests
 with addExpense.
 One thing to note is we are pattern matching on the Req object and in the
 PUT request, we extract the Req and pass it as a parameter to addExpense.
 This is because we're passing in an XML body with the information for the
 Exspense.
\end_layout

\begin_layout Standard
As we discussed in chapter ??? Lift uses dispatch rules to route requests.
 Since we'd like to sit on /api/ and handle all of the requests we're going
 to need to update the dispatch rules.
\end_layout

\begin_layout Standard
This is accomplished by adding the following code into Boot.scala:
\end_layout

\begin_layout Standard
Boot.scala code
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
class Boot {
\end_layout

\begin_layout LyX-Code
  def boot {
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
    LiftRules.dispatch.prepend(RestAPI.dispatch) 
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Section X.6 we defined the dispatch rule specific to our API.
 Adding them then injects them into the Lift request pipeline and we'll
 be able to handle the /api/ calls.
\end_layout

\begin_layout Section
API Service Code
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
// reacts to the GET Request
\end_layout

\begin_layout LyX-Code
def showExpense(eid: String): LiftResponse = { 
\end_layout

\begin_layout LyX-Code
  val e: Box[NodeSeq] = for(r <- Expense.find(By(Expense.id, eid.toLong)))
 yield { 
\end_layout

\begin_layout LyX-Code
     wrapXmlBody(<operation id="show_expense" success="true">{e.toXML}</operation
>) 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  e
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// reacts to the PUT Request
\end_layout

\begin_layout LyX-Code
def addExpense(eid: String, req: Req): LiftResponse = { 
\end_layout

\begin_layout LyX-Code
  var expense = new Expense 
\end_layout

\begin_layout LyX-Code
  req.xml match { 
\end_layout

\begin_layout LyX-Code
    case Full(<rsvp>{parameters @ _*}</rsvp>) => { 
\end_layout

\begin_layout LyX-Code
      for(parameter <- parameters){ parameter match { 
\end_layout

\begin_layout LyX-Code
        case <udid>{udid}</udid> => expense.udid(udid) 
\end_layout

\begin_layout LyX-Code
        case <dateOf>{dateof}</dateOf> => expense.dateOf(millis) 
\end_layout

\begin_layout LyX-Code
        case <email>{email}</email> => expense.email(email) 
\end_layout

\begin_layout LyX-Code
        case _ => 
\end_layout

\begin_layout LyX-Code
      } 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
    try { 
\end_layout

\begin_layout LyX-Code
      if (expense.validate) { 
\end_layout

\begin_layout LyX-Code
        expense.save 
\end_layout

\begin_layout LyX-Code
        CreatedResponse(wrapXmlBody(<operation id="add_expense" success="true"><
/operation>), "text/xml") 
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      else { 
\end_layout

\begin_layout LyX-Code
        CreatedResponse(wrapXmlBody(<operation id="add_expense" success="false">
</operation>), "text/xml") 
\end_layout

\begin_layout LyX-Code
      } 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
    catch { 
\end_layout

\begin_layout LyX-Code
      case e => Log.error("Could not add expense", e); BadResponse() 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  case _ => Log.error("Request was malformed"); BadResponse() 
\end_layout

\begin_layout LyX-Code
  }  
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Helper method for the Expense Model Object
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
// look up the account name for the expense
\end_layout

\begin_layout LyX-Code
private def getAccountName(id: Long): String = {     
\end_layout

\begin_layout LyX-Code
  Account.find(By(Account.id, id)) match {       
\end_layout

\begin_layout LyX-Code
    case Empty => "No Account Name"       
\end_layout

\begin_layout LyX-Code
    case Full(a) => a.name.is     
\end_layout

\begin_layout LyX-Code
  }   
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
// get a list of tags of the form <tag>tagname1</tag><tag>tagname2</tag>
\end_layout

\begin_layout LyX-Code
def showXMLTags: NodeSeq = tags.map(t => <tag>{t.name.is}</tag>)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// 
\end_layout

\begin_layout LyX-Code
def toXML: NodeSeq = {    
\end_layout

\begin_layout LyX-Code
  val id = "http://www.pocketchangeapp.com/api/expense/" + this.id    
\end_layout

\begin_layout LyX-Code
  val formatter = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
    
\end_layout

\begin_layout LyX-Code
  val edate = formatter.format(this.dateOf.is)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
  <expense>       
\end_layout

\begin_layout LyX-Code
    <id>{id}</id>       
\end_layout

\begin_layout LyX-Code
    <accountname>{getAccountName(account.is)}</accountname>       
\end_layout

\begin_layout LyX-Code
    <date>{edate}</date>       
\end_layout

\begin_layout LyX-Code
    <description>{description.is}</description>       
\end_layout

\begin_layout LyX-Code
    <amount>{amount.is.toString}</amount>       
\end_layout

\begin_layout LyX-Code
    <tags>{showXMLTags}</tags>     
\end_layout

\begin_layout LyX-Code
  </expense>
\end_layout

\begin_layout LyX-Code
}  
\end_layout

\end_inset


\end_layout

\begin_layout Section
Request and Response Cycle for an API GET 
\end_layout

\begin_layout Standard
TODO: actual model members
\end_layout

\begin_layout Standard
Request:
\end_layout

\begin_layout LyX-Code
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
http://www.pocketchangeapp.com/api/expense/<eid> - GET - showExpense(eid)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Response: 
\end_layout

\begin_layout LyX-Code
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
<?xml version="1.0" encoding="UTF-8"?> 
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Request and Response Cycle for an API PUT
\end_layout

\begin_layout Standard
TODO: actual model members
\end_layout

\begin_layout Standard
Request:
\end_layout

\begin_layout LyX-Code
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
http://www.pocketchangeapp.com/api/expense/<eid> - PUT - addEntry(acccount_id,
 request) + XML Body
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Request Body: 
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<entry> 
\end_layout

\begin_layout LyX-Code
  <udid>1234</udid> 
\end_layout

\begin_layout LyX-Code
  <dateOf>Fri Feb 20 08:37:16 EST 2009</dateOf> 
\end_layout

\begin_layout LyX-Code
  <email>tyler.weir@gmail.com</email> 
\end_layout

\begin_layout LyX-Code
</entry> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Response:
\end_layout

\begin_layout LyX-Code
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
<?xml version="1.0" encoding="UTF-8"?> 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Extending the API to return Atom and JSON
\end_layout

\begin_layout Standard
If you'd like to return your data in a different format, you'll have to
 do two things.
 First define the helper or helpers, we'll add 
\family typewriter
toJSON
\family default
 and 
\family typewriter
toAtom
\family default
 as a sample.
 Second, update the dispatch rules to allow users to request the alternate
 data formats.
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
def toAtom = {    
\end_layout

\begin_layout LyX-Code
  val id = "http://www.pocketchangeapp.com/api/expense/" + this.id    
\end_layout

\begin_layout LyX-Code
  val formatter = new  SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")    
\end_layout

\begin_layout LyX-Code
  val edate = formatter.format(this.dateOf.is)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  <entry xmlns="http://www.w3.org/2005/Atom">     
\end_layout

\begin_layout LyX-Code
    <expense>       
\end_layout

\begin_layout LyX-Code
      <id>{id}</id>       
\end_layout

\begin_layout LyX-Code
      <accountname>{getAccountName(account.is)}</accountname>       
\end_layout

\begin_layout LyX-Code
      <date>{edate}</date>       
\end_layout

\begin_layout LyX-Code
      <description>{description.is}</description>       
\end_layout

\begin_layout LyX-Code
      <amount>{amount.is.toString}</amount>       
\end_layout

\begin_layout LyX-Code
      <tags>{showXMLTags}</tags>      
\end_layout

\begin_layout LyX-Code
    </expense>     
\end_layout

\begin_layout LyX-Code
  </entry>   
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def toJSON = {    
\end_layout

\begin_layout LyX-Code
  val id = "http://www.pocketchangeapp.com/api/expense/" + this.id    
\end_layout

\begin_layout LyX-Code
  val formatter = new  SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")    
\end_layout

\begin_layout LyX-Code
  val edate = formatter.format(this.dateOf.is)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  "{'expense':{ 'id':'" + id + "','accountname':'" + getAccountName(account.is)
 + "'," +    "'date':'" + edate + "'," +    "'description':'" + description.is
 +     "'," +    "'amount':'" + amount.is.toString + "'," +    "'tags': {["
 + showJSONTags + "]}"  
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And we'll have to modify the dispatch rules to add a format selection in
 the URI.
 We'll leave plain XML as the default response, and we'll add a way to select
 JSON, XML or Atom.
\end_layout

\begin_layout Standard
The URIs for GET will now be:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense/<eid>
\end_layout

\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense/<eid>/xml
\end_layout

\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense/<eid>/json
\end_layout

\begin_layout LyX-Code
http://www.pocketchangeapp.com/api/expense/<eid>/atom
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the additions to the dispatch are as follows:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
object RestAPI extends XMLApiHelper {
\end_layout

\begin_layout LyX-Code
  def dispatch: LiftRules.DispatchPF = {     
\end_layout

\begin_layout LyX-Code
    case Req("api" :: "expense" :: eid :: Nil, "", GetRequest) => () =>
 showExpenseXml(eid) // old
\end_layout

\begin_layout LyX-Code
    case Req("api" :: "expense" :: eid :: 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

 :: Nil, "", GetRequest) => () => showExpenseXml(eid) // new
\end_layout

\begin_layout LyX-Code
    case Req("api" :: "expense" :: eid :: 
\begin_inset Quotes eld
\end_inset

json
\begin_inset Quotes erd
\end_inset

 :: Nil, "", GetRequest) => () => showExpenseJson(eid) // new
\end_layout

\begin_layout LyX-Code
    case Req("api" :: "expense" :: eid :: 
\begin_inset Quotes eld
\end_inset

atom
\begin_inset Quotes erd
\end_inset

 :: Nil, "", GetRequest) => () => showExpenseAtom(eid) // new
\end_layout

\begin_layout LyX-Code
    case r @ Req("api" :: "expense" :: eid :: Nil, "", PutRequest) => ()
 => addExpense(eid, r)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    // Invalid API request - route to our error handler
\end_layout

\begin_layout LyX-Code
    case Req("api" :: x :: Nil, "", _) => failure _ 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Finally, we'll add the show* functions:
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
def showExpenseXml(eid: String): LiftResponse = {     
\end_layout

\begin_layout LyX-Code
  val e: Box[NodeSeq] = for(e <- Expense.find(By(Expense.id, eid.toLong)))
      
\end_layout

\begin_layout LyX-Code
    yield {       
\end_layout

\begin_layout LyX-Code
      XmlResponse(<operation id="show_expense_xml" success="true">{r.toXML}</oper
ation>)     
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  e    
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def showExpenseAtom(eid: String): LiftResponse = {     
\end_layout

\begin_layout LyX-Code
  val e: Box[NodeSeq] = for(e <- Expense.find(By(Expense.id, eid.toLong)))
      
\end_layout

\begin_layout LyX-Code
    yield {       
\end_layout

\begin_layout LyX-Code
      AtomResponse(<operation id="show_expense_atom" success="true">{r.toAtom}</o
peration>)     
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  e    
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def showExpenseJson(eid: String): LiftResponse = {     
\end_layout

\begin_layout LyX-Code
  val e: Box[NodeSeq] = for(e <- Expense.find(By(Expense.id, eid.toLong)))
      
\end_layout

\begin_layout LyX-Code
    yield {       
\end_layout

\begin_layout LyX-Code
      JsonResponse(<operation id="show_expense_json" success="true">{r.toJSON}</o
peration>)     
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  e    
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\end_inset


\end_layout

\begin_layout Section
Chapter Summary
\end_layout

\begin_layout Standard
We did some awesome stuff and built a simple REST API.
 Some logical extensions would be a full authentication layer or transforming
 the data to a different format.
\end_layout

\end_body
\end_document
