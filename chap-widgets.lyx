#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Widgets
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In essence a Lift widget is a class that constructs XHTML fragmets built
 based on dynamic information that we can easily integrate in our pages.
 But it is not only about XHTML but also the JavaScript code in order to
 make the widget very dynamic and the stylesheet in order to theme the widget.
 Many web frameworks out there come with a rich set of artifacts, sometimes
 called components, sometimes widgets or perhaps something else.
 These generates lots of attraction because these re-usable entities can
 be easily integrated in your applications.
 Of course the term 
\begin_inset Quotes eld
\end_inset

easily
\begin_inset Quotes erd
\end_inset

 is used loosely here as you maybe very well aware of the pains you had
 to endure to develop your own widgets in one framework or another.
 Perhaps too excessive use of XML (see JSF 1.1, 1.2), too many specific interfaces
 to implement so that the framework can do the necessary wiring and so on.
 With Lift, things are a quite different as after lots of discussions we
 adopted a more loosely approach.
 There is no trait that you need to implement and no XML descriptors because
 the main idea is to make it as simple as possible for the users to create
 widgets.
 In fact Lift's design facilitates this a lot by using snippets and JavaScript
 abstractions.
 Of course Scala's support for embedded XML.
\end_layout

\begin_layout Section
Existent Lift widgets
\end_layout

\begin_layout Standard
Lift framework comes with a set of widgets existent in the lift-widgets
 sub-project.
 This list of widget is expect to grow in time providing a rich set of widgets
 that you can just use in your application.
 This also means that this is not a complete list of Lift widgets as by
 the time you read this book more widgets might be available.We also encourge
 you to write your own widgets but we'll see in a bit how you can create
 your own widget, or better yet what is the approach that we chose for building
 Lift widgets.
\end_layout

\begin_layout Subsection
TableSorter widget
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/tablesorter.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TableSorter widget
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table sorter widget is based on http://tablesorter.com/docs/ script.
 You can use it to make your table more flexible as you are able to sort
 the elements by each column.
 First you need tocall 
\family typewriter
TableSorter.init 
\family default
function in your Boot to make Lift aware about the path of the resources
 used by this widget.
 Then, you can have your snippet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
TableSorter example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

Template example:
\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

	<lift:TableSorterDemo/>
\end_layout

\begin_layout Plain Layout

    <table id=
\begin_inset Quotes erd
\end_inset

table-id
\begin_inset Quotes erd
\end_inset

 class=
\begin_inset Quotes erd
\end_inset

tablesorter
\begin_inset Quotes erd
\end_inset

> ...
 </table>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

class TableSorterDemo {
\end_layout

\begin_layout Plain Layout

 def render(xhtml: NodeSeq): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    TableSorter("table-id")
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In your page somewhere you need to have a regular HTML Table having 
\begin_inset Quotes eld
\end_inset

table-id
\begin_inset Quotes erd
\end_inset

 id and 
\begin_inset Quotes eld
\end_inset

tablesorter
\begin_inset Quotes erd
\end_inset

 class.
 Such as 
\end_layout

\begin_layout Standard

\family typewriter
<table id="myTable" class="tablesorter">...</table>
\end_layout

\begin_layout Subsection
Calendar widgets
\end_layout

\begin_layout Standard
There are three calendar widgets: Month-View, Week-View and Day-View built
 somehow similar with what Microsoft Outlook provides or Google Calendar.They
 provide basic functionality so you maybe able to extend or easily customize
 based on your application needs.
\end_layout

\begin_layout Paragraph
Calendar Month-View
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/month-view.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Calendar Month-View
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This widget allows you to create month view calendars in your web page,
 manage your calendar events etc.
\end_layout

\begin_layout Standard
How to use it:
\end_layout

\begin_layout Enumerate
In you Boot call 
\family typewriter
CalendarMonthView init
\family default
; This will do necessary initialization mainly telling Lift's 
\family typewriter
ResourceServer
\family default
 about the paths to JavaScripts and stylesheets needed by this widget as
 these dependencies are embedded in the same jar file.
\end_layout

\begin_layout Enumerate
Here is a snippet example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Calendar Month-View example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

The template markup:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

    <h2>Calendar Month View Demo</h2>
\end_layout

\begin_layout Plain Layout

    <lift:CalendarMonthViewDemo.render> 
\end_layout

\begin_layout Plain Layout

   		<cal:widget/>
\end_layout

\begin_layout Plain Layout

    </lift:CalendarMonthViewDemo.render>
\end_layout

\begin_layout Plain Layout

</lift:surround> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class CalendarMonthViewDemo {
\end_layout

\begin_layout Plain Layout

  def render(html: Group) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

    val c = Calendar getInstance;
\end_layout

\begin_layout Plain Layout

    c.set(MONTH, 0)     
\end_layout

\begin_layout Plain Layout

	bind("cal", html,
\end_layout

\begin_layout Plain Layout

         "widget" -> CalendarMonthView(c, makeCals, itemClick, dayClick,
 weekClick)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  import JE._
\end_layout

\begin_layout Plain Layout

  import JsCmds._
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // These are the JavaScript functions that will be executed when you click
 a calendar item,
\end_layout

\begin_layout Plain Layout

  // a cell header or the week number.
 You can take any actions you desire here.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* The JS parameters you are provided with in your callback function are:
 the element that 
\end_layout

\begin_layout Plain Layout

   * you clicked and the id of the clicked calendar item
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def itemClick = Full(AnonFunc("elem, param", JsRaw("alert(param + ' -
 ' + elem.nodeName)")))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* The JS parameters you are provided with in your callback function are:
 the element that 
\end_layout

\begin_layout Plain Layout

   * you clicked and the date as a string of the form yyyy/MM/DD
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def dayClick = Full(AnonFunc("elem, param", JsRaw("alert(param + ' - '
 + elem.nodeName)")))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* The JS parameters you are provided to your JS callback function are:
 the element that 
\end_layout

\begin_layout Plain Layout

   * you clicked and the week of year.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def weekClick = Full(AnonFunc("elem, param", JsRaw("alert(param + ' -
 ' + elem.nodeName)")))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\family typewriter
makeCals
\family default
 function just returns a 
\family typewriter
List[CalendarItem]
\family default
.
 The CalendarItem abstacts that information for calendar elements that will
 be rendered in the widgets.
 There are three mandatory parameters: the calendar ID, the start date and
 the type of the calendar.
 The rest are optional parameter as they re expressed as repeted higher
 order function parameters to the optional function.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CalendarItem example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

val item3 = CalendarItem("4", c3, CalendarType.MEETING) optional (
\end_layout

\begin_layout Plain Layout

        _ end(c3),
\end_layout

\begin_layout Plain Layout

        _ subject("Other month"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also pass a 
\family typewriter
MonthViewMeta
\family default
 to the 
\family typewriter
CalendarMonthView
\family default
 object.
 Here we can specify the first day of week that should be rendered (Sunday,
 Monday etc.) and the Locale that will be used for internationalization.
\end_layout

\begin_layout Standard
The widget is rendring its JavaScript dependencies as well as the default
 stylesheet rendered with the 
\family typewriter
/classpath/calendars/monthview/style.css
\family default
 path.
 The widget itsself is rendering the <head/> element that will be merged
 into the top head element by Lift.
 To use your own stylesheet you can create this path in WEB-INF/classes
 folder as it will be first searched here.
 Hence you can overwrite the default stylesheet with your own one so you
 can easily change the theme.
\end_layout

\begin_layout Paragraph
Calendar Week-View
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/week-view.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Calendar Week-View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same paradigms applied for month view are also applied for week view.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 
\begin_inset Caption

\begin_layout Plain Layout
Week View example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class CalendarWeekViewDemo {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def render(html: Group) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

	val c = Calendar getInstance;
\end_layout

\begin_layout Plain Layout

	c.set(DAY_OF_MONTH, 17)
\end_layout

\begin_layout Plain Layout

	c.set(MONTH, 4)
\end_layout

\begin_layout Plain Layout

    bind("cal", html,
\end_layout

\begin_layout Plain Layout

         "widget" -> CalendarWeekView(c, WeekViewMeta(MONDAY, Locale.getDefault()
), list, itemClick))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Same as Month View We need to initialize the WeekView component in Boot
 by calling 
\family typewriter
CalendarWeekView init
\family default
;.
 In this case we're using CalendarViewMeta object to create the actual component.
 We are passing as arguments a Calendar object that tells the widget which
 week of year it needs to render.
 Basically it renders the week that contains the date specified by the Calendar
 object.
 Then we are passing a WeekViewMeta containin information about first day
 of week (Monday,Sunday etc.) and the Locale that is used for internationalizatio
n.
 The 
\family typewriter
list
\family default
 parameter is a List[CalendarItem] which of course contains that calendar
 items that will be rendered by this widget.
 The 
\family typewriter
itemClick
\family default
 isthe JavaScript function that willbe called when you click on the calendar
 item itself.
\end_layout

\begin_layout Paragraph
Calendar Day-View
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/day-view.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Calendar Day-View 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
CalendarDayView widget renders the calendars that start in the same day.
 The usage is very similar with CalendarWeekView widget:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CalendarDayView example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class CalendarDayViewDemo {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def render(html: Group) : NodeSeq = {    val c = Calendar getInstance;
\end_layout

\begin_layout Plain Layout

    c.set(DAY_OF_MONTH, 17)
\end_layout

\begin_layout Plain Layout

    c.set(MONTH, 4)
\end_layout

\begin_layout Plain Layout

    bind("cal", html,
\end_layout

\begin_layout Plain Layout

         "widget" -> CalendarDayView(c, DayViewMeta(Locale.getDefault()),
 list, itemClick)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parameters have pretty much the same meaning as for CalendarWeekView
 except that the Calndar object pass represents the day that we want to
 render and we are now passing a DayViewMeta containing the Locale for internati
onalization purposes.
 
\end_layout

\begin_layout Subsection
RSS Feed widget
\end_layout

\begin_layout Standard
The name of the widget pretty much expresses what the widget does.
 It renders RSS feeds.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/rssfeed.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
RSSFeed widget
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This widget does not need initialization in Boot since it has no dependencies
 JS, CSS, images etc.
 In your snippet you can just have:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
RSSFeed example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

The template:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">     
\end_layout

\begin_layout Plain Layout

	<lift:RSSFeedDemo.render/>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class RSSFeedDemo {
\end_layout

\begin_layout Plain Layout

  def render(xhtml: NodeSeq): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    <xml:group>
\end_layout

\begin_layout Plain Layout

      {RSSFeed("http://www.praytothemachine.com/evil/index.php/feed/")}
\end_layout

\begin_layout Plain Layout

    </xml:group>
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Gravatar widget
\end_layout

\begin_layout Standard
Gravatars are 
\series bold
g
\series default
lobally 
\series bold
r
\series default
ecognized 
\series bold
avatars
\series default
.
 Please see http://gravatar.com.
 You can add you picture here and you ravarat will be displayed in sites
 that interact with gravatar.
 Now you can build a Lift application that is able to fetch your avatar
 and render it on your page.
 Here is a snippet code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Gravatar example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class GravatarDemo {
\end_layout

\begin_layout Plain Layout

  def render(xhtml: NodeSeq) :NodeSeq = {
\end_layout

\begin_layout Plain Layout

   Gravatar("marius.danciu@gmail.com")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will rendere a 
\family typewriter
<div>
\family default
 element containin the avatar picture.
\end_layout

\begin_layout Subsection
TreeView widget
\end_layout

\begin_layout Standard
Tree widgets renders a tree like structure using TreeView JQuery plugin
 (http://docs.jquery.com/Plugins/Treeview) for managing the tree structure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/treeview.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TreeView widget
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To use this widget you need to callin your Boot 
\family typewriter
TreeView.init
\family default
 function as this widgets has javascript, CSS and images dependencies.
 Then your snippet can look something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
TreeView example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

The markup:
\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content"> 
\end_layout

\begin_layout Plain Layout

   <lift:TreeViewDemo.render />
\end_layout

\begin_layout Plain Layout

   <ul id="example" class="filetree">...</ul>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

class TreeViewDemo {
\end_layout

\begin_layout Plain Layout

  def render(xhtml: Group): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    TreeView("example", JsObj(("animated" -> 90)))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the TreeView call we are providing the ID of the <ul> element and a JSON
 structure containing configuration attributes the TreeView JQuery plugin
 supports.
 In this case we are using an animation effect with 90 milliseconds delay.
 The example above renders basically transforms a static <ul> ..
 <li> structure in the tree view where you can expand/colapse nodes etc.
\end_layout

\begin_layout Standard
The TreeView widget also supporst loading the tree asynchronously and even
 loading individual nodes asynchronously.
 The differences from then above example are:
\end_layout

\begin_layout Enumerate
The <ul> element is an empty element acting as a real-estate where the fetched
 tree will be placed.
 The tree of course if fetched using Ajax
\end_layout

\begin_layout Enumerate
The TreeView call looks like 
\family typewriter
TreeView("async", JsObj(("animated" -> 20)), loadTree _, loadNode _) 
\family default
where 
\family typewriter
loadTree
\family default
 and 
\family typewriter
loadNode
\family default
 are functions that return a List[Tree].
 
\family typewriter
loadTree
\family default
 is used for loading the initial tree and 
\family typewriter
loadNode
\family default
 used for loading individual nodes.
 The functions provided needs to conform with:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
() => List[Tree]
\family default
 for loading the entire tree
\end_layout

\begin_layout Enumerate

\family typewriter
(String) => List[Tree])
\family default
 for loading a specific node.
 The node ID is passed to your function so you can distinguish which node
 you need to load
\end_layout

\end_deeper
\begin_layout Enumerate
The Tree class is declared as:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Tree(text:String, // The node text
\end_layout

\begin_layout Plain Layout

				id: Box[String], // The node ID
\end_layout

\begin_layout Plain Layout

				classes: Box[String], // The CSS classes applied to this node
\end_layout

\begin_layout Plain Layout

				expanded: Boolean, // The node is expanded or not
\end_layout

\begin_layout Plain Layout

				hasChildren: Boolean, // Indicates if this node has children of not.
\end_layout

\begin_layout Plain Layout

				children: List[Tree]) // The node's children
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
There is also a companion module providing different overloaded apply functions.
 As you've noticed we have a List of Tree which can be empty (Nil) but we
 also have a hasChildren flag.
 The reason is that hasChildren semantic is beyond the scope of an empty
 Tree list.
 For instance for Ajax nodes we can have 
\family typewriter
hasChildren = true
\family default
 but the actual children list will be fetched dynamically using Ajax call.
 Here is an example of building a tree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Tree example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Tree("1.
 Pre Lunch (120 min)", "folder", false, false,
\end_layout

\begin_layout Plain Layout

         Tree("1.1 The State of the Powerdome (30 min)", "file") ::
\end_layout

\begin_layout Plain Layout

         Tree("1.2 The Future of jQuery (30 min)", "file") ::
\end_layout

\begin_layout Plain Layout

         Tree("1.2 jQuery UI - A step to richnessy (60 min)", "file") ::
\end_layout

\begin_layout Plain Layout

         Nil)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sparklines widget
\end_layout

\begin_layout Standard
The sparklines widget is baed on http://www.willarson.com/code/sparklines/sparklin
es.html script.
 It renders charts using HTML canvas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/sparklines.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sparklines widget
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similarly with other widgets you need to initialize the widget in Boot by
 calling 
\family typewriter
Sparklines.init
\family default
.
 Here is a snippet code example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Sparklines example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

The template example:
\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

	<lift:SparklinesDemo.renderOnLoad />
\end_layout

\begin_layout Plain Layout

	<canvas id="bar" style="width: 500px; height: 200px;"></canvas>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

class SparklinesDemo {
\end_layout

\begin_layout Plain Layout

  def renderOnLoad(html: NodeSeq): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    val data = JsArray(100,500,300,200,400,500,400,400,100,200, 345, 412,
 111, 234, 490);
\end_layout

\begin_layout Plain Layout

    val opts = JsObj(("percentage_lines" -> JsArray(0.5, 0.75)),
\end_layout

\begin_layout Plain Layout

                     ("fill_between_percentage_lines" -> true),
\end_layout

\begin_layout Plain Layout

                     ("extend_markings" -> false));
\end_layout

\begin_layout Plain Layout

    Sparklines.onLoad("bar", SparklineStyle.BAR, data, opts);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all in the template we are including our SparklinesDemo snippet
 and then add a canvas element.
 This element will contain the actual chart.
 In our little snippet we have the chart data as a JsArray (that abstracts
 a JavaScript array) then the JSON object containing configuration options
 that the sparklines script will use.
 Then calling Sparklines.onLoad will render a JavaScript function that when
 DOM document is ready for processing will render the actual chart.
\end_layout

\begin_layout Section
How to build a widget
\end_layout

\begin_layout Standard
As explained before there is no magic formula as with Lift & Scala there
 are so many ways of building widgets.
 But here are some guidelines that we use for building widgets in Lift:
\end_layout

\begin_layout Enumerate
Assume that you want to package the widget in a single .jar file.
 Also the widget's resources (scripts, stylesheets, images) are incorporated
 in the same jar file.
\end_layout

\begin_layout Enumerate
Because the resources are embedded in your jar you need to help lift find
 them when the browser is requesting them.
 Here the init function that we call in the application Boot comes into
 picture.
 Here i an example of init function:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 import _root_.net.liftweb.http.ResourceServer
\end_layout

\begin_layout Plain Layout

 def init() {     
\end_layout

\begin_layout Plain Layout

    ResourceServer.allow{
\end_layout

\begin_layout Plain Layout

      case "sparklines" :: _ => true     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
This tells Lift that it is OK to load the resources from /classpath/sparklines
 folder.
 Actually 
\family typewriter
classpath
\family default
 is given by 
\family typewriter
LiftRules.resourceServerPath
\family default
 variable that of course you can change.
\end_layout

\begin_layout Enumerate
Now you can build your own classes/object containing various functions.
 These functions usually return the actual widget markup rendered based
 on the information that user provides but it also can render <head> elements.
 Not to worry because Lift will automatically merge any <head> element found
 in HTML body into the top level head.
 This is a very handy feature.
 For instance Sparkilines.onLoad function would render:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 <head>
\end_layout

\begin_layout Plain Layout

   <script type="text/javascript" src="/classpath/sparklines/sparklines.min.js"/>
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

 </head>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the path we used: /classpath/sparklines.
 It is recommended to not hardcode /classpath there instead use 
\family typewriter
LiftRules.resourceServerPath 
\family default
variable.
\end_layout

\end_deeper
\begin_layout Enumerate
After you defined your functions you can simply use them from regular snippets,
 just as we did for the widgets presented above.
\end_layout

\begin_layout Standard
That is pretty much it as far as Lift widgets go.
 As you can see we did not really have to build a rich design (or over-design
 it) because Lift framework itself facilitates lots of things for us.
\end_layout

\end_body
\end_document
