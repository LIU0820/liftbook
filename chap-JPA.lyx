#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
JPA Integration
\begin_inset CommandInset label
LatexCommand label
name "cha:JPA-Integration"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
This chapter is still under active development.
 The contents will change.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Java Persistence API
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/javaee/overview/faq/persistence.jsp
\end_layout

\end_inset


\end_layout

\end_inset

, or JPA
\begin_inset Index
status collapsed

\begin_layout Plain Layout
JPA
\end_layout

\end_inset

 for short, is the evolution of a number of frameworks in Java to provide
 a simple database access layer for plain java objects (and, transitively,
 Scala objects).
 JPA was developed as part of the EJB3 specification, with the goal of simplifyi
ng the persistence model.
 Prior versions had used the Container Managed Persistence (CMP
\begin_inset Index
status collapsed

\begin_layout Plain Layout
CMP
\end_layout

\end_inset

) framework, which required many boilerplate artifacts in the form of interfaces
 and XML descriptors.
 As part of the overarching theme of EJB3 to simplify and use configuration
 by convention, JPA uses annotations
\begin_inset Index
status collapsed

\begin_layout Plain Layout
annotations
\end_layout

\end_inset

 heavily, while allowing for targetted overrides of behavior via XML descriptors.
 JPA also does away with many of the interfaces used in CMP and provides
 a single EntityManager
\begin_inset Index
status collapsed

\begin_layout Plain Layout
EntityManager
\end_layout

\end_inset

 object for all persistence operations.
 An additional benefit is that JPA was designed so that it could be used
 both inside and outside of the Enterprise container, and several projects
 (Hibernate
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Hibernate
\end_layout

\end_inset

, TopLink
\begin_inset Index
status collapsed

\begin_layout Plain Layout
TopLink
\end_layout

\end_inset

, JPOX
\begin_inset Index
status collapsed

\begin_layout Plain Layout
JPOX
\end_layout

\end_inset

, etc) provide standalone implementations of EntityManager.
\end_layout

\begin_layout Standard
As we've seen in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:mapper_and_record"

\end_inset

, Lift already comes with a very capable database abstraction layer, so
 why would we want to use something else? There are a number of reasons:
\end_layout

\begin_layout Enumerate
JPA is easily accessible from both Java and Scala.
 If you are using Lift to complement part of a project that also contains
 Java components, JPA allows you to use a common database layer between
 both and avoid duplication of effort.
 It also means that if you have an existing project based on JPA, you can
 easily integrate it into Lift
\end_layout

\begin_layout Enumerate
JPA gives you more flexibility with complex and/or large schemas.
 While Lift's Record
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: is it Record or Mapper?
\end_layout

\end_inset

provides most of the functionality you would need, JPA provides additional
 lifecycle methods and mapping controls when you have complex needs
\end_layout

\begin_layout Enumerate
JPA can provide additional performance improvements via second-level object
 caching.
 It's possible to roll your own in Lift, but JPA allows you to cache frequently-
accessed objects in memory so that you avoid hitting the database entirely
\end_layout

\begin_layout Enumerate
\begin_inset Note Note
status open

\begin_layout Plain Layout
May need to remove this if it's not true by printing
\end_layout

\end_inset

JPA and Lift's Record are not mutually exclusive.
 You can use an adapter to allow Record to utilize JPA as the underlying
 provider, thus gaining the best of both worlds.
\end_layout

\begin_layout Section
Introduction to JPA
\end_layout

\begin_layout Standard
In order to provide a concrete example to build on while learning how to
 integrate JPA, we'll be building a small Lift app to manage a library of
 books.
 The completed example is available under the Lift Git
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Git
\end_layout

\end_inset

 repository in the sites directory, and is called 
\begin_inset Quotes eld
\end_inset

JPADemo
\begin_inset Quotes erd
\end_inset

.
 Basic coverage of the JPA operations is in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JPA-Examples"

\end_inset

; if you want more detail on JPA, particularly with advanced topics like
 locking and hinting, there are several very good tutorials to be found
 online
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/developer/technicalArticles/J2EE/jpa/
\end_layout

\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.jpox.org/docs/1_2/tutorials/jpa_tutorial.html
\end_layout

\end_inset


\end_layout

\end_inset

.
 Our first step is to set up a master project
\begin_inset Index
status collapsed

\begin_layout Plain Layout
master project
\end_layout

\end_inset

 for Maven
\begin_inset Note Note
status open

\begin_layout Plain Layout
Will the Maven chapter have a section on master/module projects?
\end_layout

\end_inset

.
 This project will have two modules under it, one for the JPA library and
 one for the Lift application.
 The only thing we actually need for the master project is the pom.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
pom.xml
\end_layout

\end_inset

.
 The complete pom.xml is shown in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:JPA-Master-pom.xml"

\end_inset

.
 Note that the dependencies specifically exclude the Hibernate JTA dependence
 so that we can use the geronimo-specs version of JTA.
 If you don't do that then you'll have to manually download and install
 the Sun versions from their website.
\end_layout

\begin_layout Standard
The master pom.xml sets up some basic dependencies and plugin configurations
 which the modules will inherit.
 Our next step will be to create the JPA module using an archetype
\begin_inset Index
status collapsed

\begin_layout Plain Layout
archetype
\end_layout

\end_inset

 for Maven to create the scaffolding of our project
\begin_inset Note Note
status open

\begin_layout Plain Layout
I need to get the JPA archetype set up
\end_layout

\end_inset

.
 From your master project directory, use the 
\family typewriter
mvn archetype:generate
\family default
 command, select the 
\begin_inset Quotes eld
\end_inset

Scala JPA
\begin_inset Quotes erd
\end_inset

 archetype and when prompted use com.foo.jpaweb for the group ID, JPADemo-spa
 for the artifact ID, and com.foo.jpaweb.model for the package.
 You should now have a JPADemo-spa module that we can explore.
\end_layout

\begin_layout Subsection
Entity Classes
\begin_inset Index
status collapsed

\begin_layout Plain Layout
entity class
\end_layout

\end_inset

 in Scala
\end_layout

\begin_layout Standard
The main components of a JPA library are the entity classes that comprise
 your data model.
 For our example application we need two primary entities: Author and Book.
 Let's take a look at the Author class first, shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:Author.scala"

\end_inset

.
 The listing shows our import of the entire javax.persistence package as
 well as several annotations on a basic class.
 For those of you coming from the Java world in JPA, the annotations should
 look very familiar.
 The major difference between Java and Scala annotations is that each parameter
 in a Scala annotation is considered a val, which explains the presence
 of the val keyword in lines 11, 14 and 17-18.
 In line 18 you may also note that we must specify the target entity class;
 although Scala uses generics, the generic types aren't visible from Java
\begin_inset Note Note
status open

\begin_layout Plain Layout
I think this changes in 2.8
\end_layout

\end_inset

, so the Java JPA libraries can't deduce the correct type.
 You may also notice that on line 19 we need to use the Java collections
 classes for Set, List, etc.
 With a little bit of implicit conversion magic (to be shown later), this
 has very little impact on our code.
 On final item item to note is that the Scala compiler currently does not
 support nested annotations 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://lampsvn.epfl.ch/trac/scala/ticket/294
\end_layout

\end_inset


\end_layout

\end_inset

, so where we would normally use them (join tables, named queries, etc),
 we will have to use the orm.xml descriptor, which we cover next.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Using-the-orm.xml"

\end_inset

Using the orm.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
orm.xml
\end_layout

\end_inset

 descriptor
\end_layout

\begin_layout Standard
As we stated in the last section, there are some instances where the Scala
 compiler doesn't fully cover the JPA annotations (nested annotations in
 particular).
 Some would also argue that queries and other ancillary data (table names,
 column names, etc) should be separate from code.
 Because of that, JPA allows you to specify an external mapping descriptor
 to define and/or override the mappings for your entity classes
\begin_inset Index
status collapsed

\begin_layout Plain Layout
entity classes
\end_layout

\end_inset

.
 The basic orm.xml file starts with the DTD type declaration, as shown in
 listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:orm.xml"

\end_inset

.
 Following the preamble, we can define a package that will apply to all
 subsequent entries so that we don't need to use the fully-qualified name
 for each class.
 In our example, we would like to define some named queries for each class.
 Putting them in the orm.xml allows us to modify them without requiring a
 recompile.
 The complete XML Schema Definition can be found at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/xml/ns/persistence/orm_1_0.xsd
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In this case we have used the orm.xml file to augment our entity classes.
 If, however, we would like to override the configuration, we may use that
 as well on a case-by-case basis.
 Suppose we wished to change the column name for the Author's name property.
 We can add (per the XSD) a section to the Author entity element as shown
 in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:JPA-Author-override"

\end_inset

.
 The 
\family typewriter
attribute-override
\family default
 element lets us change anything that we would normally specify on the 
\family typewriter
@Column
\family default
 annotation.
 This gives us an extremely powerful method for controlling our schema mapping
 outside of the source code.
 We can also add named queries
\begin_inset Index
status collapsed

\begin_layout Plain Layout
named queries
\end_layout

\end_inset

 in the orm.xml so that we have a central location for defining or altering
 the queries.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:JPA-Author-override"

\end_inset

Author override
\end_layout

\end_inset

  <entity class="Author">
\end_layout

\begin_layout Plain Layout

    <named-query name="findAllAuthors">
\end_layout

\begin_layout Plain Layout

      <query><![CDATA[from Author a order by a.name]]></query>
\end_layout

\begin_layout Plain Layout

    </named-query>
\end_layout

\begin_layout Plain Layout

    <attribute-override name="name">
\end_layout

\begin_layout Plain Layout

      <column name="author_name" length="30" />
\end_layout

\begin_layout Plain Layout

    </attribute-override>
\end_layout

\begin_layout Plain Layout

  </entity>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object attachment and detachment
\end_layout

\begin_layout Standard
JPA operates with entities in one of two modes: attached and detached.
 An attached object is one that is under the direct control of a live JPA
 session.
 That means that the JPA provider monitors the state of the object and writes
 it to the database at the appropriate time.
 Objects can be attached either explicitly via the 
\family typewriter
persist
\family default
 and 
\family typewriter
merge
\family default
 methods (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Persisting,-merging-and-removing"

\end_inset

), or implicitly via query results, the 
\family typewriter
getReference
\family default
 method or the 
\family typewriter
find
\family default
 method.
 As soon as the session ends, any formerly attached objects are now considered
 detached.
 You can still operate on them as normal objects but any changes are not
 directly applied to the database.
 If you have a detached object, you can re-attach it to your current session
 with the 
\family typewriter
merge
\family default
 method; any changes since the object was detached, as well as any subsequent
 changes to the attached object, will be applied to the database at the
 appropriate time.
 The concept of object attachment is particularly useful in Lift because
 it allows us to generate or query for an object in one request cycle and
 then make modifications and merge in a different cycle.
\end_layout

\begin_layout Subsection
Support for user types
\end_layout

\begin_layout Standard
JPA can handle any Java primitive type, their corresponding Object versions
 (java.lang.Long, java.lang.Integer, etc), and any entity classes comprised
 of these types 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It can technically handle more; see the JPA spec, section 2.1.1 for details
\end_layout

\end_inset

.
 Occasionally, though, you may have a requirement for a type that doesn't
 fit directly with those specifications.
 One example in particular would be Scala's enumerations
\begin_inset Index
status collapsed

\begin_layout Plain Layout
enumerations
\end_layout

\end_inset

.
 Unfortunately, the JPA spec currently doesn't have a means to handle this
 directly, although the various JPA providers such as Toplink and Hibernate
 provide mechanisms for resolving custom user types.
 JPA does provide direct support for 
\emph on
Java
\emph default
 enumerations, but that doesn't help us here since Scala enumerations aren't
 an extension of Java enumerations.
 In this example, we'll be using Hibernate's UserType to support an enumeration
 for the Genre of a Book.
\end_layout

\begin_layout Standard
We begin by implementing a few helper classes besides the Genre enumeration
 itself.
 First, we define an Enumv trait, shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:Enumv-Trait"

\end_inset

.
 Its main purpose is to provide a 
\family typewriter
valueOf
\family default
 method that we can use to resolve the enumerations database value to the
 actual enumeration.
 We also add some extra methods so that we can encapsulate a description
 along with the database value.
 Scala enumerations can use either Ints or Strings for the identity of the
 enumeration value (unique to each val), and in this case we've chosen Strings.
 By adding a map for the description (since Scala enumeration values must
 extend the Enumeration#Value class and therefore can't carry the additional
 string) we allow for the additional info.
 We could extend this concept to make the Map carry additional data, but
 for our purposes this is sufficient.
 
\end_layout

\begin_layout Standard
In order to actually convert the Enumeration class into the proper database
 type (String, Int, etc), we need to implement the Hibernate UserType interface,
 shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:EnumvType"

\end_inset

.
 We can see on line 18 that we will be using a varchar column for the enumeratio
n value.
 Since this is based on the Scala Enumeration's Value method, we could technical
ly use either Integer or character types here.
 We override the 
\family typewriter
sqlTypes
\family default
 and 
\family typewriter
returnedClass
\family default
 methods to match our preferred type, and set the 
\family typewriter
equals
\family default
 and 
\family typewriter
hashCode
\family default
 methods accordingly.
 Note that in Scala, the 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 operator on objects delegates to the 
\family typewriter
equals
\family default
 method, so we're not testing reference equality here.
 The actual resolution of database column value to Enumeration is done in
 the 
\family typewriter
nullSafeGet
\family default
 method; if we decided, for instance, that the null value should be returned
 as unknown, we could do this here with some minor modifications to the
 Enumv class (defining the unknown value, for one).The rest of the methods
 are set appropriately for an immutable object (Enumeration).
 The great thing about the EnumvType class, is that it can easily be used
 for a variety of types due to the 
\begin_inset Quotes eld
\end_inset

et
\begin_inset Quotes erd
\end_inset

 constructor argument; as long as we mix in the Enumv trait to our Enumeration
 objects, we get persistence essentially for free.
 If we determined instead that we want to use Integer enumeration IDs, we
 need to make minor modifications to the EnumvType to make sure arguments
 match and we're set.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,firstline=3,float,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Genre-and-GenreType"

\end_inset

Genre and GenreType
\end_layout

\end_inset

package com.foo.jpaweb.model
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Genre extends Enumeration with Enumv {
\end_layout

\begin_layout Plain Layout

  val Mystery = Value("Mystery", "Mystery")
\end_layout

\begin_layout Plain Layout

  val Science = Value("Science", "Science")
\end_layout

\begin_layout Plain Layout

  val Theater = Value("Theater", "Drama literature")
\end_layout

\begin_layout Plain Layout

  // more values here...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class GenreType extends EnumvType(Genre) {}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, the Genre object and the associated GenreType is shown in listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Genre-and-GenreType"

\end_inset

.
 You can see that we create a singleton Genre object with specific member
 values for each enumeration value.
 The GenreType class is trivial now that we have the EnumvType class defined.
 To use the Genre type in our entity classes, we simply need to add the
 proper 
\family typewriter
var
\family default
 and annotate it with the @Type annotation, as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Using-the-@Type"

\end_inset

.
 We need to specify the type of the var due to the fact that the actual
 enumeration values are of the type Enumeration.Val, which doesn't match
 our valueOf method in the Enumv trait.
 We also want to make sure we set the enumeration to some reasonable default;
 in our example we have an 
\emph on
unknown
\emph default
 value to cover that case.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Using-the-@Type"

\end_inset

Using the @Type annotation
\end_layout

\end_inset

  @Type{val `type` = "com.foo.jpaweb.model.GenreType"}
\end_layout

\begin_layout Plain Layout

  var genre : Genre.Value = Genre.unknown
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now that we have our objects defined, let's start using them.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Obtaining-an-EM"

\end_inset

Obtaining a Per-Session EntityManager
\end_layout

\begin_layout Standard
Ideally, we would like our JPA access to be as seamless as possible, particularl
y when it comes to object lifecycle.
 In JPA, objects can be attached to a current persistence session, or they
 can be detached from a JPA session.
 This gives us a lot of flexibility (which we'll use later) in dealing with
 the objects themselves, but it also means that we need to be careful when
 we're accessing object properties.
 JPA can use lazy retrieval for instance properties; in particular, this
 is the default behavior for collection-based properties.
 What this means is that if we're working on a detached object and we attempt
 to access a collection contained in the instance, we're going to get an
 exception that the session that the object was loaded in is no longer live.
 What we're really like to do is have some hooks into Lift's request cycle
 that allows us to set up a session when the request starts and properly
 close it down when the request ends.
 We still have to be careful with objects that have been passed into our
 request (from form callbacks, for instance), but in general this will guarantee
 us that once we've loaded an object in our snippet code we have full access
 to all properties at any point within our snippets.
\end_layout

\begin_layout Standard
Fortunately for us, Lift provides just such a mechanism.
 In fact, Lift supports several related mechanisms for lifecycle management
\begin_inset Foot
status open

\begin_layout Plain Layout
Notably, S.addAround with the LoanWrapper
\end_layout

\end_inset

, but for now we're going to focus on just one: the RequestVar
\begin_inset Index
status collapsed

\begin_layout Plain Layout
RequestVar
\end_layout

\end_inset

.
 A RequestVar represents a variable associated with the lifetime of the
 request.
 This is in contrast to SessionVar, which defines a variable for the lifetime
 of the user's session.
 RequestVar gives us several niceties over handling request parameters ourselves
, including type safety and a default value.
 We go into more detail on Request- and SessionVars in section 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: cross-ref
\end_layout

\end_inset

, but for now we're going to concentrate on the methods needed to do lifecycle
 management.
\end_layout

\begin_layout Standard
The initial setup of the entity manager is done through the RequestVar's
 constructor.
 We define a RequestVar as an object (as opposed to a class) as shown in
 listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Setting-up-EM"

\end_inset

 (the full listing is in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:ScalaEntityManager"

\end_inset

).
 In our example we're using an abstraction of the EntityManager (and Query)
 interfaces as a template for our concrete implementation; we'll cover these
 in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:ScalaEntityManager-and-ScalaQuery"

\end_inset

.
 As you can see, we've defined two methods to handle the opening and closing
 of the EntityManager and we delegate to our impl for the actual setup.
 We utilize the constructor of the RequestVar to call the openEM() method,
 and we override the cleanupFunc method to call the closeEM() method.
 Note that the RequestVar is lazy, so the EntityManager won't be opened
 until it's actually requested.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,firstline=1,float,lastline=8,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Setting-up-EM"

\end_inset

Setting up an EntityManager via RequestVar
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

abstract class ScalaEntityManager(val persistanceName: String) {
\end_layout

\begin_layout Plain Layout

  // The concrete impl should provide these methods 
\end_layout

\begin_layout Plain Layout

  protected def openEM () : EntityManager 
\end_layout

\begin_layout Plain Layout

  protected def closeEM (em : EntityManager)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private object emVar extends RequestVar(openEM()) {
\end_layout

\begin_layout Plain Layout

    override def cleanupFunc : Box[() => Unit]= Full(() => closeEM(this.is))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now that we've defined the mechanism for setting up and tearing down our
 EM, we need to actually obtain an EM.
 There are essentially two ways to do this
\end_layout

\begin_layout Enumerate
Construct the EntityManagerFactory
\begin_inset Index
status collapsed

\begin_layout Plain Layout
EntityManagerFactory
\end_layout

\end_inset

 directly
\end_layout

\begin_layout Enumerate
Obtain an EntityManager via JNDI
\begin_inset Index
status collapsed

\begin_layout Plain Layout
JNDI
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of these two, JNDI offers a cleaner approach from the standpoint of deployment.
 Using JNDI acts as a form of IoC
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Inversion of Control
\end_layout

\end_inset

 (Inversion of Control) to allow us to separate out the selection of the
 persistence module; it's also more in line with JEE standards and allows
 us to more easily move our app between full-blown (JBoss, GlassFish, etc)
 and lightweight (Jetty, Tomcat) containers.
 
\end_layout

\begin_layout Subsection
Creating a factory directly
\end_layout

\begin_layout Standard
Creating a factory directly is fairly simple, and is the use case for apps
 that will run under the Java SE without access to the JEE facilicities.
 As shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:Creating-the-EM-directly"

\end_inset

, we first set up the EntityManagerFactory by a call to the static javax.persiste
nce.Persistence.createFactory(...) method.
 Once we have the factory, we define our openEM method to use the factory's
 createEntityManager() method to obtain the EM, and then we start a transaction.
 We're going to cover transactions in more detail a little later in this
 chapter; for now, just understand that in this particular configuration
 we have to begin and commit the transaction 
\emph on
within
\emph default
 the lifecycle of the EM.
 We also define our closeEM method as essentially the mirror of openEM.
\end_layout

\begin_layout Subsection
Using JNDI
\end_layout

\begin_layout Standard
The standard binding for persistence modules in JNDI is 
\family typewriter
java:comp/env/persistence/<module name>
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://database.in2p3.fr/doc/oracle/Oracle_Application_Server_10_Release_3/web.1013
/b28221/servjndi010.htm
\end_layout

\end_inset


\end_layout

\end_inset

.
 We'll cover how to set up JNDI on lightweight containers like Tomcat and
 Jetty in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Setting-up-JNDI-jetty"

\end_inset

, but for now we'll concentrate on the client side of things.
 We define our openEM method using the javax.naming.InitialContext class to
 obtain the EM from JNDI, as shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:EM-Via-JNDI"

\end_inset

.
 You can also see that we start a transaction (also via JNDI) just prior
 to looking up the EntityManager.
 When we use JNDI (really, JTA) for obtaining our transactions, notice that
 we open begin and end the transaction outsid of the EM's lifecycle.
 In a production application you would want to put these steps into a try/catch
 or use LiftRules.browserResponseToException
\begin_inset Index
status collapsed

\begin_layout Plain Layout
browserResponseToException
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
LiftRules
\end_layout

\end_inset

 (covered in section 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: cross-ref
\end_layout

\end_inset

) to make sure that the user doesn't get a stack trace if something goes
 wrong.
 You can also see in the listing that we've defined our closeEM method.
 We simply close the EM and then either commit or rollback the transaction
 depending on its state.
\end_layout

\begin_layout Standard
However you obtain the EM, the general principles of how you use the EM
 are the same.
 All of the entity operations work exactly the same way in either case and
 the EntityManager takes care of the underlying details, such as how to
 set rollback on the current transaction.
 This allows your code to stay portable; if you want to use the simpler
 user-managed factory you can start with that and when you change your mind
 later it requires only minor modifications to a single class.
\end_layout

\begin_layout Subsection
Transactions
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Transactions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We're not going to go into too much detail here; there are better documents
 available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/developer/EJTechTips/2005/tt0125.html
\end_layout

\end_inset


\end_layout

\end_inset

 if you want to go into depth on how JTA or general transactions work.
 Essentially, a transaction is a set of operations that are performed atomically
; that is, they either all complete successfully or none of them do.
 The classic example is transferring funds between two bank accounts: you
 subtract the amount from one account and add it to the other.
 If the addition fails and you're not operating in the context of a transaction,
 the client has lost money!
\end_layout

\begin_layout Standard
In JPA, transactions are required.
 If you don't perform your operations within the scope of a transaction
 you will either get an exception (if you're using JTA), or you will spend
 many hours trying to figure out why nothing is being saved to the database.
 There are two ways of handling transactions under JPA: resource local and
 JTA.
 Resource local transactions are what you use if you are managing the EM
 factory yourself (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Creating-the-EM-directly"

\end_inset

).
 Similarly, JTA is what you use when you obtain your EM via JNDI.
 Choosing between the two is as simple as setting a property in your persistence.
xml file (and changing the code to open and close the EM).
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Setting-the-transaction-type"

\end_inset

 shows examples of setting the 
\family typewriter
transaction-type
\family default
 attribute to 
\family typewriter
RESOURCE_LOCAL
\family default
 and to JTA.
 If you want to use JTA, you can also omit the 
\family typewriter
transaction-type
\family default
 attribute since JTA is the default.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Setting-the-transaction-type"

\end_inset

Setting the transaction type
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<persistence-unit name="jpaweb" transaction-type="RESOURCE_LOCAL">
\end_layout

\begin_layout Plain Layout

  <non-jta-datasource>myDS</non-jta-datasource>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<persistence-unit name="jpaweb" transaction-type="JTA">
\end_layout

\begin_layout Plain Layout

  <non-jta-datasource>myDS</jta-datasource>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You must make sure that your EM setup code matches what you have in your
 persistence.xml.
 Additionally, the database connection must match; with JTA, you 
\emph on
must
\emph default
 use a 
\family typewriter
jta-data-source
\family default
 (obtained via JNDI) for your database connection.
 For resource-local, you can either use a 
\family typewriter
non-jta-datasource
\family default
 element or you can set the provider properties, as shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:Setting-resource-local-properties"

\end_inset

.
 In this particular example we're setting the properties for Hibernate,
 but similar properties exist for TopLink
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.oracle.com/technology/products/ias/toplink/JPA/essentials/toplink-jpa-e
xtensions.html
\end_layout

\end_inset


\end_layout

\end_inset

, JPOX
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.jpox.org/docs/1_2/persistence_unit.html
\end_layout

\end_inset


\end_layout

\end_inset

, and others.
\end_layout

\begin_layout Standard
In our opinion, using JTA to manage your transactions is well worth the
 extra effort.
 If you'll be deploying into a JEE container, such as JBoss or GlassFish,
 then you get JTA support almost for free since JTA is part of the JEE spec.
 Even if you want to deploy your application on a lightweight container
 like Jetty, the extra effort to set up JNDI and JTA in Jetty is small relative
 to the effort involved in coding and testing your app.
 As we've discussed before, you also get the benefit of separation of configurat
ion when you use JNDI.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,float,language=XML,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Setting-resource-local-properties"

\end_inset

Setting resource-local properties for Hibernate
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<persistence>
\end_layout

\begin_layout Plain Layout

   <persistence-unit name="jpaweb" transaction-type="RESOURCE_LOCAL">
\end_layout

\begin_layout Plain Layout

      <properties>
\end_layout

\begin_layout Plain Layout

         <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLD
ialect"/>
\end_layout

\begin_layout Plain Layout

         <property name="hibernate.connection.driver_class" value="org.postgresql.Dr
iver"/>
\end_layout

\begin_layout Plain Layout

         <property name="hibernate.connection.username" value="somUser"/>
\end_layout

\begin_layout Plain Layout

         <property name="hibernate.connection.password" value="somePass"/>
\end_layout

\begin_layout Plain Layout

         <property name="hibernate.connection.url" value="jdbc:postgresql:jpaweb"/
>
\end_layout

\begin_layout Plain Layout

      </properties>
\end_layout

\begin_layout Plain Layout

   </persistence-unit>
\end_layout

\begin_layout Plain Layout

</persistence>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One final note in regard to transactions is how they're affected by Exceptions.
 Per the spec, any exceptions thrown during the scope of a transaction,
 other than 
\family typewriter
javax.persistence.NoResultException
\family default
 or 
\family typewriter
javax.persistence.NonUniqueResultException
\family default
, will cause the transaction to be marked for rollback.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ScalaEntityManager-and-ScalaQuery"

\end_inset

ScalaEntityManager and ScalaQuery
\end_layout

\begin_layout Standard
Now that we've gone through setting up our EntityManager, let's look at
 how we actually use them in an application.
 As a convenience, we will define two thin wrappers on the existing EntityManage
r
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html
\end_layout

\end_inset


\end_layout

\end_inset

 and Query
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html
\end_layout

\end_inset


\end_layout

\end_inset

 interfaces to provide more Scala-friendly methods.
 This means that we get Scala's collection types (i.e.
 List instead of java.util.List) and generic signatures so that we can avoid
 explicit casting.
 Listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:ScalaEntityManager"

\end_inset

 shows the ScalaEntityManager class.
 We start with the method and RequestVar definitions that we discussed in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Obtaining-an-EM"

\end_inset

.
 Following that, we have a few convenience methods for creating and executing
 named queries in a single method, as well combo methods to merge or remove
 an entity and flush to the database in one go.
 The rest of the methods essentially delegate to the underlying EM directly.
\end_layout

\begin_layout Standard
Next, we have the ScalaQuery class in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:ScalaQuery"

\end_inset

.
 Like ScalaEntityManager, this is a thin wrapper on the Query interface.
 In particular, methods that return entities are typed against the ScalaQuery
 itself, so that you don't need to do any explicit casting in your client
 code.
 We also add some utility methods to simplify setting a parameter list as
 well as obtaining the result(s) of the query.
 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:JPA-Examples"

\end_inset

Examples
\end_layout

\begin_layout Standard
We find it helpful to solidify what we've discussed here with some concrete
 examples.
 Let's start with some basic operations
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Persisting,-merging-and-removing"

\end_inset

Persisting, merging and removing
\end_layout

\begin_layout Standard
The first step to working with any persistent entities is to actually persist
 them.
 If you have a brand new object, you can do this with the 
\family typewriter
persist
\family default
 method:
\end_layout

\begin_layout LyX-Code
Model.persist(myNewAuthor)
\end_layout

\begin_layout Standard
This attaches the myNewAuthor object to the current persistence session.
 Once the object is attached it should be visible in any subsequent queries,
 although it may not be written to the database just yet (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-importance-of-flush"

\end_inset

).
 Note that the persist method is only intended for brand new objects.
 If you have a detached object and you try to use persist you will most
 likely get an EntityExistsException as the instance you're merging is technical
ly conflicting with itself.
 Instead, you want to use the merge method to re-attach detached objects:
\end_layout

\begin_layout LyX-Code
val author = Model.merge(myOldAuthor)
\end_layout

\begin_layout Standard
An important thing to note is that the merge method doesn't actually attach
 the object passed to it; instead, it makes an attached 
\emph on
copy
\emph default
 of the passed object and returns the copy.
 If you mistakenly merge without using the returned value:
\end_layout

\begin_layout LyX-Code
Model.merge(myOldAuthor)
\end_layout

\begin_layout LyX-Code
myOldAuthor.name = 
\begin_inset Quotes eld
\end_inset

Fred
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
you'll find that subsequent changes to the object won't be written to the
 database.
 One nice aspect of the merge method is that it intelligently detects whether
 the entity you're merging is a new object or a detached object.
 That means that you can use merge everywhere and let it sort out the semantics.
 For example, in our library application, using merge allows us to combine
 the add and edit functionality into a single snippet; if we want to edit
 an existing Author we pass it into the method.
 Otherwise, we pass a brand new Author instance into the method and the
 merge takes care of either case appropriately.
\end_layout

\begin_layout Standard
Removing an object is achieved by calling the 
\family typewriter
remove
\family default
 method:
\end_layout

\begin_layout LyX-Code
Model.remove(myAuthor)
\end_layout

\begin_layout Standard
The passed entity is detached from the session immediately and will be removed
 from the database at the appropriate time.
 If the entity has any associations on it (to collections or other entities),
 they will be cascaded as indicated by the entity mapping.
 An example of a cascade is shown in the Author listing on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "lst:Author.scala"

\end_inset

.
 The books collection has the cascade set to REMOVE, which means that if
 an author is deleted, all of the books by that author will be removed as
 well.
 The default is to not cascade anything, so it's important that you properly
 set the cascade on collections to avoid constraint violations when you
 remove entities.
 It's also useful to point out that you don't actually need to have an entity
 loaded to remove it.
 You can use the 
\family typewriter
getReference
\family default
 method to obtain a proxy that will cause the corresponding database entry
 to be removed:
\end_layout

\begin_layout LyX-Code
Model.remove(Model.getReference(classOf[Author], someId))
\end_layout

\begin_layout Subsection
Loading an Entity
\end_layout

\begin_layout Standard
There are actually three ways to load an entity object in your client code.
 The simplest is to use the 
\family typewriter
find
\family default
 method: 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Jorge has pointed out that this may change: http://groups.google.com/group/liftweb
/browse_thread/thread/874b38daa0d535f7
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
val myBook = Model.find(classOf[Book], someId)
\end_layout

\begin_layout Standard
The 
\family typewriter
find
\family default
 method takes two parameters: the class that you're trying to load and the
 value of the ID field of the entity.
 In our example, the Book class uses the Long type for its ID, so we would
 put a Long value here.
 It returns either a Full Box
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: cross-ref
\end_layout

\end_inset

 if the entity is found in the database, otherwise it returns Empty.
 With 
\family typewriter
find
\family default
, the entity is loaded immediately from the database and can be used in
 both attached and detached states.
 The next method you can use is the 
\family typewriter
getReference
\family default
 method:
\end_layout

\begin_layout LyX-Code
val myBook = Model.getReference(classOf[Book], someId)
\end_layout

\begin_layout Standard
This is very similar to the 
\family typewriter
find
\family default
 method with a few key differences.
 First, the object that is returned is a lazy proxy for the entity.
 That means that no database load is required to occur when you execute
 the method, although providers may do at least a check on the existence
 of the ID.
 Because this is a lazy proxy, you usually don't want to use the returned
 object in a detached state unless you've accessed its fields while the
 session was open.
 The normal use of getReference is when you want to set up a relationship
 between two (or more) entities, since you don't need to query all of the
 fields just to set a foreign key.
 For example:
\end_layout

\begin_layout LyX-Code
myBook.author = Model.getReference(classOf[Author], authorId)
\end_layout

\begin_layout Standard
When myBook is flushed to the database the EM will correctly set up the
 relationship.
 The final difference is in how unknown entities are handled.
 Recall that the 
\family typewriter
find
\family default
 method returns Empty if the entity cannot be found; with 
\family typewriter
getReference
\family default
, however, we don't query the database until the reference is used.
 Because of this, the javax.persistence.EntityNotFoundException is thrown
 when you try to access an undefined entity for the first time (this also
 marks the transaction for rollback).
 The third method for loading an entity would be to use a query (named or
 otherwise) to fetch the entity.
 As an example, here's a query equivalent of the 
\family typewriter
find
\family default
 method:
\end_layout

\begin_layout LyX-Code
val myBook = 
\end_layout

\begin_layout LyX-Code
  Model.createQuery[Book](
\begin_inset Quotes eld
\end_inset

from Book bk where bk.id = :id
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
       .setParams(
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 -> someId).findOne
\end_layout

\begin_layout Standard
The advantage here is that we have more control over what is selected by
 using the query language to specify other properties.
 One caveat is that when you use the findOne method you need to ensure that
 the query will actually result in a unique entity; otherwise, the EM will
 throw a 
\family typewriter
NonUniqueResultException
\family default
.
\end_layout

\begin_layout Subsection
Loading many entities
\end_layout

\begin_layout Standard
Corresponding to the findOne method is the findAll method, which returns
 all entities based on a query.
 There are two ways to use findAll; the first is to use the convenience
 findAll method defined in the ScalaEntityManager class:
\end_layout

\begin_layout LyX-Code
val myBooks = Model.findAll(
\begin_inset Quotes eld
\end_inset

booksByYear
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

year
\begin_inset Quotes erd
\end_inset

 -> myYear)
\end_layout

\begin_layout Standard
This requires the use of a named query for the first arg, and subsequent
 args are of the form (
\begin_inset Quotes eld
\end_inset

paramName
\begin_inset Quotes erd
\end_inset

 -> value).
 Named queries
\begin_inset Index
status collapsed

\begin_layout Plain Layout
named queries
\end_layout

\end_inset

 can be defined in your orm.xml
\begin_inset Index
status collapsed

\begin_layout Plain Layout
orm.xml
\end_layout

\end_inset

, as shown in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Using-the-orm.xml"

\end_inset

.
 Named queries are highly recommended over ad-hoc queries since they allow
 you to keep the queries in one location instead of being scattered all
 over your code.
 Named queries can also be pre-compiled by the JPA provider, which will
 catch errors at startup (or in your unit tests, hint hint) instead of when
 the query is run inside your code.
\end_layout

\begin_layout Standard
The second method is to create a ScalaQuery instance directly and then set
 parameters and execute it.
 In reality this is exactly what the Model.findAll method is doing.
 The advantage here is that with the ScalaQuery instance you can do things
 like set hinting, paging, etc.
 For instance, if you wanted to do paging on the books query, you could
 do
\end_layout

\begin_layout LyX-Code
val myBooks = Model.createNamedQuery(
\begin_inset Quotes eld
\end_inset

booksByYear
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
                   .setParams(
\begin_inset Quotes eld
\end_inset

year
\begin_inset Quotes erd
\end_inset

 -> myYear)
\end_layout

\begin_layout LyX-Code
                   .setMaxResults(20)
\end_layout

\begin_layout LyX-Code
                   .setFirstResult(pageOffset).findAll
\end_layout

\begin_layout Subsection
Tips for using queries
\end_layout

\begin_layout Standard
In general we recommend that you use named queries throughout your code.
 In our experience, the extra effort involved in adding a named query is
 more than offset by the time it saves you if you ever need to modify the
 query.
 Additionally, we recommend that you use named parameters in your queries.
 Named parameters are just that: parameters that are inserted into your
 query by name, in contrast to positional parameters.
 As an example, here is the same query using named and positional parameters:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Named
\begin_inset space ~
\end_inset

parameters 
\family typewriter
select user from User where (user.name like :searchString or user.email like
 :searchString) and user.widgets > :widgetCount
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Positional
\begin_inset space ~
\end_inset

parameters 
\family typewriter
select user from User where (user.name like ? or user.email like ?) and user.widget
s > :widgetCount
\end_layout

\begin_layout Standard
From this example we can show several advantages of named params over positional
 params
\end_layout

\begin_layout Enumerate
You can reuse the same parameter within the same query and you only set
 it once.
 In the example about we would set the same parameter twice using positional
 params
\end_layout

\begin_layout Enumerate
The parameters can have meaningful names.
\end_layout

\begin_layout Enumerate
With positional params you may have to edit your code if you need to alter
 your query to add or remove parameters
\end_layout

\begin_layout Standard
In any case, you should generally use the parameterized query types as opposed
 to hand constructing your queries; using things like string concatenation
 opens up your site to SQL injection attacks unless you're very careful.
 For more information on queries there's an excellent reference for the
 EJBQL on the Hibernate website at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.hibernate.org/hib_docs/entitymanager/reference/en/html/queryhql.html
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Converting collection properties
\end_layout

\begin_layout Standard
The ScalaEntityManager and ScalaQuery methods are already defined so that
 they return Scala-friendly collections such as 
\family typewriter
scala.collection.jcl.BufferWrapper
\family default
 or SetWrapper.
 We have to use Java Collections
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.sun.com/docs/books/tutorial/collections/index.html
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

under the hood
\begin_inset Quotes erd
\end_inset

 and then wrap them because JPA doesn't understand Scala collections.
 For the same reason, collections in your entity classes must also use the
 Java Collections classes.
 Fortunately, Scala has a very nice framework for wrapping Java collections.
 In particular, the scala.collection.jcl.Conversions class contains a number
 of implicit conversions
\begin_inset Index
status collapsed

\begin_layout Plain Layout
implicit conversions
\end_layout

\end_inset

; all you have to do is import them at the top of your source file like
 so:
\end_layout

\begin_layout LyX-Code
import scala.collection.jcl.Conversions._
\end_layout

\begin_layout Standard
Once you've done that the methods are automatically in scope and you can
 use collections in your entities as if they were real Scala collections.
 For example, we may want to see if our Author has written any mysteries:
\end_layout

\begin_layout LyX-Code
val suspenseful = author.books.exists(_.genre = Genre.Mystery)
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:The-importance-of-flush"

\end_inset

The importance of flush()
\end_layout

\begin_layout Standard
It's important to understand that in JPA the provider isn't required to
 write to the database until the session closes or is flushed.
 That means that constraint violations aren't necessarily checked at the
 time that you persist, merge or remove and object.
 Using the flush method forces the provider to write any pending changes
 to the database and immediately throw any exceptions resulting from any
 violations.
 As a convenience, we've written methods to do persist, merge and remove
 with a subsequent flush, as shown in listing 
\begin_inset CommandInset ref
LatexCommand vref
reference "lst:ScalaEntityManager"

\end_inset

.
 We do, however, recommend that if you will be doing multiple operations
 in one session cycle that you use a single flush at the end:
\end_layout

\begin_layout LyX-Code
val container = Model.find(classOf[Container], containerId)
\end_layout

\begin_layout LyX-Code
Model.remove(container.widget)
\end_layout

\begin_layout LyX-Code
container.widget = new Widget(
\begin_inset Quotes eld
\end_inset

Foo!
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
// next line only required if container.widget doesn't cascade PERSIST
\end_layout

\begin_layout LyX-Code
Model.persist(container.widget)
\end_layout

\begin_layout LyX-Code
Model.flush()
\end_layout

\end_body
\end_document
