#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Helpers
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-Helpers"

\end_inset


\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Standard
Lift provides a a pretty consistent collection of helper artifacts.
 The helpers are essentially utility functions that helps you avoid boilerplate
 code.
 Hence it is important to be aware what is provided by Lift already for
 you to use so you wont have to spend time coding something that already
 exists.
 We won't be detailing here every single helper or helper function as you
 can easily discover them and enjoy using them in your applciation.
\end_layout

\begin_layout Standard
Pretty much all Lift's helpers live in 
\family typewriter
net.liftweb.util
\family default
 package.
\end_layout

\begin_layout Section
Box (or Scala's Option class on steroids)
\begin_inset CommandInset label
LatexCommand label
name "sec:Box-(or-Scala's"

\end_inset


\end_layout

\begin_layout Standard
The Box is a utility that is built on top of Scala's Option Type (also heavily
 used inside Lift ), so let's take a quick look at Option first.
 The Option class allows for typesafe method of dealing with a situation
 where you may or may not have a result.
 Option has two values, either Some(value) where value is actually the value
 and None which is used to represent nothing.
 A typical example for Option is outlined using Scala's Map type.
 Below you'll see a definition of a Map, a successful attempt to get the
 value of key 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and an attempt to get the value of key 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

.Notice that when there was an existing key-value pair for 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 the value was returned as Some(A) and when we asked for the value of key
 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 we received None.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Option and Map example
\begin_inset CommandInset label
LatexCommand label
name "lst:Option-and-Map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

scala> val cap = Map("a" -> "A", "b" -> "B") 
\end_layout

\begin_layout LyX-Code

cap: scala.collection.immutable.Map[java.lang.String,java.lang.String] = Map(a
 -> A, b -> B)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> cap.get("a")  
\end_layout

\begin_layout LyX-Code

res1: Option[java.lang.String] = Some(A)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> cap.get("i") 
\end_layout

\begin_layout LyX-Code

res2: Option[java.lang.String] = None 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Getting the value out of an Option is usually handled via map, for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Fetch value from an Option
\begin_inset CommandInset label
LatexCommand label
name "lst:Fetch-value-from"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

def prettyPrint(foo: Option[String]): String = foo match {
\end_layout

\begin_layout LyX-Code

  case Some(x) => x
\end_layout

\begin_layout LyX-Code

  case None => 
\begin_inset Quotes eld
\end_inset

Nothing found.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout Plain Layout

    Which would be used in conjunction with the previous code:
\end_layout

\begin_layout LyX-Code

scala> prettyPrint(cap.get("a")) 
\end_layout

\begin_layout LyX-Code

res7: String = A
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> prettyPrint(cap.get("i")) 
\end_layout

\begin_layout LyX-Code

res8: String = Nothing found.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Box in Lift may seem very similar in functionality with Option.
 But Box is taking Option at the next level.
 If we have an Option that is None at some point we can not really tell
 why that Option is None although in many situation it would be quite helpful.
 With Box, on the other hand, and Empty Box can be a Failure incorporating
 the cause for the failure.
 So you can think of Box as a container that can either contain something
 or to be empty.
 A Box can be empty from various causes including some error conditions.
 This is why we also have Failure which is an Empty Box but contains information
 about the error.
 See 
\family typewriter
case class Failure(msg: String, exception: Box[Throwable], chain: Box[Failure])
\family default
.
 Of course, the usability doesn;t stop here.
 Lots of times when writing code we have to do a bunch of null checks than
 perform that operation then other null checks, other operations and so
 on.
 So we would have something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Pseudocode nested operations example
\begin_inset CommandInset label
LatexCommand label
name "lst:Pseudocode-nested-operations"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

	x = getSomeValue();
\end_layout

\begin_layout Plain Layout

	if (x != null) {
\end_layout

\begin_layout Plain Layout

  	y = getSomeOtherValue();
\end_layout

\begin_layout Plain Layout

  	if (y != null) {
\end_layout

\begin_layout Plain Layout

    	compute(x, y);
\end_layout

\begin_layout Plain Layout

  	}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
 so you got the picture.
 Needless to say how tedious such style is in practice.
 Now let's see if we can do better with Lift's Box.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Scala nested operations example
\begin_inset CommandInset label
LatexCommand label
name "lst:Scala-nested-operations"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def getSomeValue(): Box[Int] = Full(12)     
\end_layout

\begin_layout Plain Layout

    def getSomeOtherValue(): Box[Int] = Full(2)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def compute(x: Int, y: Int) = x * y
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    val res = for ( x <- getSomeValue();
\end_layout

\begin_layout Plain Layout

    	            y <- getSomeOtherValue() if x > 10) yield compute(x, y)
\end_layout

\begin_layout Plain Layout

    println(res) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above example we have to values x and y and we want to do some computatio
n with these values.
 But we must ensure that computation is done on the correct data.
 For instance the computation can not be done if 
\family typewriter
getSomeValue()
\family default
 returns no value.
 In this context the two function return a Box[Int].
 The interesting part is that if either of the two functions or both return
 an Empty Box instead of Full (Empty impersonating the non-existence of
 the value) the res value will also be Empty.
 However if both functions return a Full (like in the very example) the
 computation is called and res will be a 
\family typewriter
Full(24)
\family default
.
 But we have something else interesting here: 
\family typewriter
if x > 10
\family default
.
 If we would make getSomeValue to return a value less or equal with 10 the
 res value will be Empty.
 The point of all this is to exemplify the power of Box and for comprehentions
 in Scala and how it can be used to build quite complex expressions and
 yet keep an impressive code claririty.
\end_layout

\begin_layout Standard
Lift's Box extends Option with a few ideas, mainly the fact that you can
 add a message about why a Box is Empty.
 Empty corresponds to Option's None and Full to Option's Some.
 So you can pattern match against a Box like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Box example
\begin_inset CommandInset label
LatexCommand label
name "lst:Box-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

a match {
\end_layout

\begin_layout LyX-Code

  Full(author) => Text(
\begin_inset Quotes eld
\end_inset

I found the author 
\begin_inset Quotes eld
\end_inset

 + author.niceName)
\end_layout

\begin_layout LyX-Code

  Empty => Text(
\begin_inset Quotes eld
\end_inset

No author by that name.
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

  Failure(message, _, _) => Text(
\begin_inset Quotes eld
\end_inset

Nothing found due to 
\begin_inset Quotes eld
\end_inset

 + message) // message may be something like 
\begin_inset Quotes eld
\end_inset

Database disconnected.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout LyX-Code

def confirmDelete {     
\end_layout

\begin_layout LyX-Code

  (for (val id <- param("id");     // get the ID           
\end_layout

\begin_layout LyX-Code

        val user <- User.find(id)) // find the user                     
                                                           
\end_layout

\begin_layout LyX-Code

  yield {          
\end_layout

\begin_layout LyX-Code

    user.delete_!                   
\end_layout

\begin_layout LyX-Code

    notice("User deleted")          
\end_layout

\begin_layout LyX-Code

    redirectTo("/simple/index.html")        
\end_layout

\begin_layout LyX-Code

  }) getOrElse {error("User not found"); redirectTo("/simple/index.html")}
    
\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In conjunction with the above example we have.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
openOr example
\begin_inset CommandInset label
LatexCommand label
name "lst:openOr-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

lazy val UserBio = UserBio.find(By(UserBio.id, id)) openOr (new UserBio)
\end_layout

\begin_layout LyX-Code

def view (xhtml: NodeSeq): NodeSeq = passedAuthor.map({ author => 
\end_layout

\begin_layout LyX-Code

  // do bind, etc here and return a NodeSeq
\end_layout

\begin_layout LyX-Code

}) openOr Text("Invalid author") 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We won't be detailing here all the Box functions but a few words on the
 most common function might be benficial.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Short example.
 Assume myBox is a Box
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
openOr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns the value contained by this Box.
 If the Box is Empty 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox openOr 
\begin_inset Quotes eld
\end_inset

The box is Empty
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
map
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apply a function on the values of this Box and return something else.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox map (value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dmap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalent with map(..) openOr default_value.
 The default value will be returned in case the map is Empty
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox dmap(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

)(value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If the argument is null in will return an Empty, otherwise a Full containing
 the arguent's value.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox !! (<a reference>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?~
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transforms an Empty to a Failure and passing a message.
 If the Box is a Full it will just return 
\family typewriter
this
\family default
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox ?~ (
\begin_inset Quotes eld
\end_inset

Error message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
isDefined
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns true if this Box contains a value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox isDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
isEmpty
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retun true is this Boxis empty
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox isEmpty
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
asA[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Return a Full[B] if the content of this Box is of type B, otherwise return
 Empty 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox asA[Person]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
isA[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Return a Full[B] if the contents of this Box is an instance of the specified
 class, otherwise return Empty 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox isA[Person]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that Box contains a set of implicit conversion functions form/to Option
 and from/to Iterable.
\end_layout

\begin_layout Standard
Remember that Box is heavily used in Lift and most of the Lift's API's operates
 with Box-es.
 The rationale is to avoid null references and to operate safely in context
 where values may be missing.
 Of course that programmatically a variabel of type Box can be set to null
 manually but we strongly recommend against such practices.
 There are cases however where you are using some third party Java libraries
 and their API's return null values.
 To cope with such cases in Lift you can use the !! function to Box that
 value.
 For instance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Null example
\begin_inset CommandInset label
LatexCommand label
name "lst:Null-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var x = getSomeValueThatMayBeNull();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var boxified = Box !! x
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case the boxified variable will be Empty if x is null or Full if
 x is a valid value/reference..
\end_layout

\begin_layout Section
ActorPing
\begin_inset CommandInset label
LatexCommand label
name "sec:ActorPing"

\end_inset


\end_layout

\begin_layout Standard
It provides convenient functionality to schedule messages to Actors.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ActorPing examples
\begin_inset CommandInset label
LatexCommand label
name "lst:ActorPing-examples"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Assume myActor an existing Actor
\end_layout

\begin_layout Plain Layout

// And a case object MyMessage
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Send the MyMessage message after 15 seconds
\end_layout

\begin_layout Plain Layout

ActorPing.schedule(myActor, MyMessage, 15 seconds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Send the MyMessage message every 15 seconds.
 The cycle is stopped 
\end_layout

\begin_layout Plain Layout

// if recipient actor exits or replied back with UnSchedule message
\end_layout

\begin_layout Plain Layout

ActorPing.scheduleAtFixedRate(myActor, MyMessage, 0 seconds, 15 secods)
\end_layout

\end_inset


\end_layout

\begin_layout Section
ClassHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:ClassHelpers"

\end_inset


\end_layout

\begin_layout Standard
Provides convenient functions for loading classes using Java reflection,
 instantiating dinamically loaded classes, invoking methods vis reflection
 etc.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ClassHelper examples
\begin_inset CommandInset label
LatexCommand label
name "lst:ClassHelper-examples"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import _root_.net.liftweb.util.Helpers._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// lookup the class Bar in the three packages specified in th list
\end_layout

\begin_layout Plain Layout

findClass(
\begin_inset Quotes eld
\end_inset

Bar
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

com.foo
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

com.bar
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

com.baz
\begin_inset Quotes erd
\end_inset

 :: Nil)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

invokeMethod(myClass, myInstance, 
\begin_inset Quotes eld
\end_inset

doSomething
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section
CodeHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:CodeHelpers"

\end_inset


\end_layout

\begin_layout Standard
Provides a convenient way of telling why a boolean expression failed.
 For instance we are seeing manytime code like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Expressiom example
\begin_inset CommandInset label
LatexCommand label
name "lst:Expressiom-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var isTooYoung = false;
\end_layout

\begin_layout Plain Layout

var isTooBig = false;
\end_layout

\begin_layout Plain Layout

var isTooLazy = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var exp = isTooYoung && isTooBig && isTooLazy
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see we have no way of telling if the exp was false because of
 isTooYoung, isTooBig or isTooLazy unless we test them again.
 But let's see this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CodeHelpers example
\begin_inset CommandInset label
LatexCommand label
name "lst:CodeHelpers-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import net.liftweb.util._
\end_layout

\begin_layout Plain Layout

import net.liftweb.util.MonadicConversions._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val exp = (isTooYoung ~ "too young") &&  
\end_layout

\begin_layout Plain Layout

          (isTooBad ~ "too bad") &&  
\end_layout

\begin_layout Plain Layout

          (isToLazy ~ "too lazy")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

println(exp match {  
\end_layout

\begin_layout Plain Layout

          case False(msgs) => msgs mkString("Test failed because it is '",
 "' and '", "'.")  
\end_layout

\begin_layout Plain Layout

          case _ => "success"  
\end_layout

\begin_layout Plain Layout

        }) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if exp is a False we can tell why it failed as we have the messages
 now.
\end_layout

\begin_layout Section
ControlHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:ControlHelpers"

\end_inset


\end_layout

\begin_layout Standard
Provides convenient functions for try/catch situations.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ControlHelpers examples
\begin_inset CommandInset label
LatexCommand label
name "lst:ControlHelpers-examples"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tryo {
\end_layout

\begin_layout Plain Layout

  // code here.
 Any exception thrown here will be silently caught
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

tryo((e: Throwable) => println(e)) {
\end_layout

\begin_layout Plain Layout

  // code here.
 Any exception here willbe caught add passed to the above function.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tryo(List(classOf[ClassNotFoundException], classOf[IOException])) {
\end_layout

\begin_layout Plain Layout

  // code here.
 If IOException or ClassNotFoundException is thrown (or a subclass of the
 two) they will be ignored.
 Any other
\end_layout

\begin_layout Plain Layout

  // exception will be rethrown.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
CSSHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:CSSHelpers"

\end_inset


\end_layout

\begin_layout Standard
This provide a convenient functionality to fix relative root paths in CSS
 (Cascade Stylesheet) files.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CSSHelper example
\begin_inset CommandInset label
LatexCommand label
name "lst:CSSHelper-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

Assume this entry in a CSS file:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.boxStyle {
\end_layout

\begin_layout Plain Layout

  background-image: url('/img/bkg.png')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//in your code you can say
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CSSHelpers.fixCSS(reader, 
\begin_inset Quotes eld
\end_inset

/myliftapp
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// where reader is a java.io.Reader that provides the content of the CSS file.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if your application is not deployed in the ROOT context path (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

) and say it is deployed with the context root /myliftapp then the background
 picture will probably notbe found.
 Say 
\family typewriter
http://my.domain.com/img/bkg.png
\family default
 is an unknown path.
 However 
\family typewriter
http://my.domain.com/
\bar under
myliftapp
\bar default
/img/bkg.png 
\family default
is known.
 In the example above we are calling fixCSS so that it will automatically
 replace the root relative paths such that 
\family typewriter
background-image: url('/img/bkg.png')
\family default
 becomes 
\family typewriter
background-image: url('/myliftapp/img/bkg.png')
\family default
.
 To use that in your lift application you can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
fixCSS example
\begin_inset CommandInset label
LatexCommand label
name "lst:fixCSS-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def boot(){
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

	LiftRules.fixCSS("styles" :: "theme" :: Nil, Empty)
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the 
\family typewriter
/styles/theme.css
\family default
 file Lift will apply the prefix specified.
 But in this case we provodided an Empty Box.
 This actually means that Lift will apply the context path rturned by 
\family typewriter
S.contextPath 
\family default
function which as you know return the context path from the 
\family typewriter
HttpSession
\family default
.
\end_layout

\begin_layout Standard
Internally when you call 
\family typewriter
fixCSS
\family default
 a dispatch function is automatically created and prepended to 
\family typewriter
LiftRules.dispatch
\family default
.
 This is needed in order to intercept the broser reqiest to this .css resource.
 Also internally we are telling Lift the this resource must be server by
 Lift and not by container.
 
\end_layout

\begin_layout Standard
The way it works internally is that we are using Scala combinator parsers
 to augment only the root relative paths with the given prefix.
\end_layout

\begin_layout Section
BindHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:BindHelpers"

\end_inset


\end_layout

\begin_layout Standard
Binders are extensivley discussed in other chapters so we won't reiterate
 them here.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Choose template
\begin_inset CommandInset label
LatexCommand label
name "lst:Choose-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

//Assume the following markup.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<lift:CountGame.run form="post">
\end_layout

\begin_layout Plain Layout

  <choose:guess>
\end_layout

\begin_layout Plain Layout

    Guess a number between 1 and 100.<br/>
\end_layout

\begin_layout Plain Layout

    Last guess: <count:last/><br />
\end_layout

\begin_layout Plain Layout

    Guess: <count:input/><br/>
\end_layout

\begin_layout Plain Layout

    <input type="submit" value="Guess"/>
\end_layout

\begin_layout Plain Layout

  </choose:guess>
\end_layout

\begin_layout Plain Layout

  <choose:win>
\end_layout

\begin_layout Plain Layout

    You Win!!<br />
\end_layout

\begin_layout Plain Layout

    You guessed <count:number/> after <count:count/> guesses.<br/>
\end_layout

\begin_layout Plain Layout

  </choose:win>
\end_layout

\begin_layout Plain Layout

</lift:CountGame.run>  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// And the Scala code
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import net.liftweb.util._
\end_layout

\begin_layout Plain Layout

import Helpers._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class CountGame {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def run(xhtml: NodeSeq): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    ...
 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    chooseTemplate(
\begin_inset Quotes eld
\end_inset

choose
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

win
\begin_inset Quotes erd
\end_inset

, xhtml);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
So in the snippet conditionally we can choose between parts of the snippet
 template.
 In the case above only the childs of 
\family typewriter
<choose:win>
\family default
 node will be returned by the snippetfunction, hence rendered.
\end_layout

\begin_layout Section
HttpHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:HttpHelpers"

\end_inset


\end_layout

\begin_layout Standard
This provides helper functions for HTTP parameters manipulation, URL encoding/de
coding etc.
 However there is some interesting functionality available that lets you
 choose between tags of a snippet.
 
\end_layout

\begin_layout Section
JSON
\begin_inset CommandInset label
LatexCommand label
name "sec:JSON"

\end_inset


\end_layout

\begin_layout Standard
Lift provides its own JSON parser if you ever need one.
 At a first glance it may be a bit rendundant with Scala's JSON parser but
 infact Scala'sparser has its own problems with large JSON objects hence
 List's uses its own JSON parser implemented of course using combinator
 parsers.
\end_layout

\begin_layout Section
LD
\begin_inset CommandInset label
LatexCommand label
name "sec:LD"

\end_inset


\end_layout

\begin_layout Standard
Provides utility functions for calculating the distance between words 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Levenshtein_distance
\end_layout

\end_inset


\end_layout

\begin_layout Section
ListHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:ListHelpers"

\end_inset


\end_layout

\begin_layout Standard
Provides utility functions for manipulating lists that are not provided
 by Scala libraries.
\end_layout

\begin_layout Section
NamedPartialFunctions
\begin_inset CommandInset label
LatexCommand label
name "sec:NamedPartialFunctions"

\end_inset


\end_layout

\begin_layout Standard
Provides extremly useful functions for invoking partial functions that are
 chained in lists of functions.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
NamedPF exmaple
\begin_inset CommandInset label
LatexCommand label
name "lst:NamedPF-exmaple"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var f1: PartialFunction[Int,Int] = {
\end_layout

\begin_layout Plain Layout

  case 10 => 11
\end_layout

\begin_layout Plain Layout

  case 12 => 14
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var f2: PartialFunction[Int,Int] = {
\end_layout

\begin_layout Plain Layout

  case 20 => 11
\end_layout

\begin_layout Plain Layout

  case 22 => 14
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

NamedPF(10, f1 :: f2 :: Nil)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Remember that many LiftRules variable are RuleSeq-s.
 Meaning that most of the times we re talking about lists of partial functions.
 Hence internally lift uses NamedPF for invoking such functions that ultimatelly
 are provided by the user.
 Please see 
\family typewriter
LiftRules.dispatch
\end_layout

\begin_layout Section
SecurityHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:SecurityHelpers"

\end_inset


\end_layout

\begin_layout Standard
Provides various functions used for random number generation, encryption/decript
ions (blowfish), hash calculations (MD5, SHA, SHA-256) and so on.
\end_layout

\begin_layout Section
TimeHelpers
\begin_inset CommandInset label
LatexCommand label
name "sec:TimeHelpers"

\end_inset


\end_layout

\begin_layout Standard
Utility functions for time operations.
 For instance if also provides a set of implicit converion functions thatallow
 you to type 
\begin_inset Quotes eld
\end_inset

10 seconds
\begin_inset Quotes erd
\end_inset

 and returns the value in milliseconds.
 
\end_layout

\end_body
\end_document
