#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Helpers
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Lift provides a a pretty consistent collection of helper artifacts.
 The helpers are essentially utility functions that helps you avoid boilerplate
 code.
 Hence it is important to be aware what is provided by Lift already for
 you to use so you wont have to spend time coding something that already
 exists.
 We won't be detailing here every single helper or helper function as you
 can easily discover them and enjoy using them in your applciation.
\end_layout

\begin_layout Standard
Pretty much all Lift's helpers live in 
\family typewriter
net.liftweb.util
\family default
 package.
\end_layout

\begin_layout Section
Box (or Scala's Option class on steroids)
\end_layout

\begin_layout Standard
The Box is a utility that is built on top of Scala's Option Type (also heavily
 used inside Lift ), so let's take a quick look at Option first.
 The Option class allows for typesafe method of dealing with a situation
 where you may or may not have a result.
 Option has two values, either Some(value) where value is actually the value
 and None which is used to represent nothing.
 A typical example for Option is outlined using Scala's Map type.
 Below you'll see a definition of a Map, a successful attempt to get the
 value of key 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and an attempt to get the value of key 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

.Notice that when there was an existing key-value pair for 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 the value was returned as Some(A) and when we asked for the value of key
 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 we received None.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Option and Map example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

scala> val cap = Map("a" -> "A", "b" -> "B") 
\end_layout

\begin_layout LyX-Code

cap: scala.collection.immutable.Map[java.lang.String,java.lang.String] = Map(a
 -> A, b -> B)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> cap.get("a")  
\end_layout

\begin_layout LyX-Code

res1: Option[java.lang.String] = Some(A)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> cap.get("i") 
\end_layout

\begin_layout LyX-Code

res2: Option[java.lang.String] = None 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Getting the value out of an Option is usually handled via map, for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Fetch value from an Option
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

def prettyPrint(foo: Option[String]): String = foo match {
\end_layout

\begin_layout LyX-Code

  case Some(x) => x
\end_layout

\begin_layout LyX-Code

  case None => 
\begin_inset Quotes eld
\end_inset

Nothing found.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout Plain Layout

    Which would be used in conjunction with the previous code:
\end_layout

\begin_layout LyX-Code

scala> prettyPrint(cap.get("a")) 
\end_layout

\begin_layout LyX-Code

res7: String = A
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

scala> prettyPrint(cap.get("i")) 
\end_layout

\begin_layout LyX-Code

res8: String = Nothing found.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before detailing the Box functionality, it is relevant to point out some
 interesting functionality about Option.
 Lots of times when writing code we have to doa bunch of null checks than
 perform that operation then other null checks, other operations and so
 one.
 So we would have something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Pseudocode nested operations example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

	x = getSomeValue();
\end_layout

\begin_layout Plain Layout

	if (x != null) {
\end_layout

\begin_layout Plain Layout

  	y = getSomeOtherValue();
\end_layout

\begin_layout Plain Layout

  	if (y != null) {
\end_layout

\begin_layout Plain Layout

    	compute(x, y);
\end_layout

\begin_layout Plain Layout

  	}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
 so you got the picture.
 Needless to say how tedious such style is in practice.
 Now let's see if we can do better with Scala and Option.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Scala nested operations example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def getSomeValue(): Option[Int] = Some(12)     
\end_layout

\begin_layout Plain Layout

    def getSomeOtherValue(): Option[Int] = Some(2)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def compute(x: Int, y: Int) = x * y
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    val res = for ( x <- getSomeValue();
\end_layout

\begin_layout Plain Layout

    	            y <- getSomeOtherValue() if x > 10) yield compute(x, y)
\end_layout

\begin_layout Plain Layout

    println(res) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above example we have to values x and y and we want to do some computatio
n with these values.
 But we must ensure that computation is done on the correct data.
 For instance the computation can not be done if 
\family typewriter
getSomeValue()
\family default
 returns no value.
 In this context the two function return an Option[Int].
 The interesting part is that if eith ofthe two functions or both return
 a None Option instead of Some (None impersonating the non-existence of
 the value) the res value will also be None.
 However if both functions return a Some (like in the very example) the
 computation is called and res will be a 
\family typewriter
Some(24)
\family default
.
 But we have something else interesting here: 
\family typewriter
if x > 10
\family default
.
 If we would make getSomeValue to return a value less or equalwith 10 the
 res value will be None.
 The point of all this is to exemplify the power of Option and for comprehention
s in Scala and how it can be used to build quite complex expressions and
 yet keep an impressive code claririty.
\end_layout

\begin_layout Standard
Lift's Box extends Option with a few ideas, mainly the fact that you can
 add a message about why a Box is Empty.
 Empty corresponds to Option's None and Full to Option's Some.
 So you can pattern match against a Box like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Box example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

a match {
\end_layout

\begin_layout LyX-Code

  Full(author) => Text(
\begin_inset Quotes eld
\end_inset

I found the author 
\begin_inset Quotes eld
\end_inset

 + author.niceName)
\end_layout

\begin_layout LyX-Code

  Empty => Text(
\begin_inset Quotes eld
\end_inset

No author by that name.
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

  Failure(message, _, _) => Text(
\begin_inset Quotes eld
\end_inset

Nothing found due to 
\begin_inset Quotes eld
\end_inset

 + message) // message may be something like 
\begin_inset Quotes eld
\end_inset

Database disconnected.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout LyX-Code

def confirmDelete {     
\end_layout

\begin_layout LyX-Code

  (for (val id <- param("id");     // get the ID           
\end_layout

\begin_layout LyX-Code

        val user <- User.find(id)) // find the user                     
                                                           
\end_layout

\begin_layout LyX-Code

  yield {          
\end_layout

\begin_layout LyX-Code

    user.delete_!                   
\end_layout

\begin_layout LyX-Code

    notice("User deleted")          
\end_layout

\begin_layout LyX-Code

    redirectTo("/simple/index.html")        
\end_layout

\begin_layout LyX-Code

  }) getOrElse {error("User not found"); redirectTo("/simple/index.html")}
    
\end_layout

\begin_layout LyX-Code

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In conjunction with the above example we have.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
openOr example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

lazy val UserBio = UserBio.find(By(UserBio.id, id)) openOr (new UserBio)
\end_layout

\begin_layout LyX-Code

def view (xhtml: NodeSeq): NodeSeq = passedAuthor.map({ author => 
\end_layout

\begin_layout LyX-Code

  // do bind, etc here and return a NodeSeq
\end_layout

\begin_layout LyX-Code

}) openOr Text("Invalid author") 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So you can think of Box as a container that can either contain something
 or to be empty.
 A Box can be empty from various causes including some error conditions.
 This is why we also have Failure which is an Empty Box but contains information
 about the error.
 See 
\family typewriter
case class Failure(msg: String, exception: Box[Throwable], chain: Box[Failure])
\family default
.
\end_layout

\begin_layout Standard
We won't be detailing here all the Box functions but a few words on the
 most common function might be benficial.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Short example.
 Assume myBox is a Box
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
openOr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns the value contained by this Box.
 If the Box is Empty 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox openOr 
\begin_inset Quotes eld
\end_inset

The box is Empty
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
map
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apply a function on the values of this Box and return something else.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox map (value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dmap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalent with map(..) openOr default_value.
 The default value will be returned in case the map is Empty
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox dmap(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

)(value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?~
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transforms an Empty to a Failure and passing a message.
 If the Box is a Full it will just return 
\family typewriter
this
\family default
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox ?~ (
\begin_inset Quotes eld
\end_inset

Error message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that Box contains a set of implicit conversion functions form/to Option
 and from/to Iterable.
\end_layout

\begin_layout Section
ActorPing
\end_layout

\begin_layout Standard
It provides convenient functionality to schedule messages to Actors.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ActorPing examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Assume myActor an existing Actor
\end_layout

\begin_layout Plain Layout

// And a case object MyMessage
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Send the MyMessage message after 15 seconds
\end_layout

\begin_layout Plain Layout

ActorPing.schedule(myActor, MyMessage, 15 seconds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Send the MyMessage message every 15 seconds.
 The cycle is stopped 
\end_layout

\begin_layout Plain Layout

// if recipient actor exits or replied back with UnSchedule message
\end_layout

\begin_layout Plain Layout

ActorPing.scheduleAtFixedRate(myActor, MyMessage, 0 seconds, 15 secods)
\end_layout

\end_inset


\end_layout

\begin_layout Section
ClassHelpers
\end_layout

\begin_layout Standard
Provides convenient functions for loading classes using Java reflection,
 instantiating dinamically loaded classes, invoking methods vis reflection
 etc.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ClassHelper examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import _root_.net.liftweb.util.Helpers._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// lookup the class Bar in the three packages specified in th list
\end_layout

\begin_layout Plain Layout

findClass(
\begin_inset Quotes eld
\end_inset

Bar
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

com.foo
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

com.bar
\begin_inset Quotes erd
\end_inset

 :: 
\begin_inset Quotes eld
\end_inset

com.baz
\begin_inset Quotes erd
\end_inset

 :: Nil)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

invokeMethod(myClass, myInstance, 
\begin_inset Quotes eld
\end_inset

doSomething
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section
CodeHelpers
\end_layout

\begin_layout Standard
Provides a convenient way of telling why a boolean expression failed.
 For instance we are seeing manytime code like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Expressiom example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var isTooYoung = false;
\end_layout

\begin_layout Plain Layout

var isTooBig = false;
\end_layout

\begin_layout Plain Layout

var isTooLazy = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var exp = isTooYoung && isTooBig && isTooLazy
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see we have no way of telling if the exp was false because of
 isTooYoung, isTooBig or isTooLazy unless we test them again.
 But let's see this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CodeHelpers example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import net.liftweb.util._
\end_layout

\begin_layout Plain Layout

import net.liftweb.util.MonadicConversions._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val exp = (isTooYoung ~ "too young") &&  
\end_layout

\begin_layout Plain Layout

          (isTooBad ~ "too bad") &&  
\end_layout

\begin_layout Plain Layout

          (isToLazy ~ "too lazy")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

println(exp match {  
\end_layout

\begin_layout Plain Layout

          case False(msgs) => msgs mkString("Test failed because it is '",
 "' and '", "'.")  
\end_layout

\begin_layout Plain Layout

          case _ => "success"  
\end_layout

\begin_layout Plain Layout

        }) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if exp is a False we can tell why it failed as we have the messages
 now.
\end_layout

\begin_layout Section
ControlHelpers
\end_layout

\begin_layout Standard
Provides convenient functions for try/catch situations.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ControlHelpers examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tryo {
\end_layout

\begin_layout Plain Layout

  // code here.
 Any exception thrown here will be silently caught
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

tryo((e: Throwable) => println(e)) {
\end_layout

\begin_layout Plain Layout

  // code here.
 Any exception here willbe caught add passed to the above function.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tryo(List(classOf[ClassNotFoundException], classOf[IOException])) {
\end_layout

\begin_layout Plain Layout

  // code here.
 If IOException or ClassNotFoundException is thrown (or a subclass of the
 two) they will be ignored.
 Any other
\end_layout

\begin_layout Plain Layout

  // exception will be rethrown.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
CSSHelpers
\end_layout

\begin_layout Standard
This provide a convenient functionality to fix relative root paths in CSS
 (Cascade Stylesheet) files.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
CSSHelper example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

Assume this entry in a CSS file:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.boxStyle {
\end_layout

\begin_layout Plain Layout

  background-image: url('/img/bkg.png')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//in your code you can say
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CSSHelpers.fixCSS(reader, 
\begin_inset Quotes eld
\end_inset

/myliftapp
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// where reader is a java.io.Reader that provides the content of the CSS file.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if your application is not deployed in the ROOT context path (
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

) and say it is deployed with the context root /myliftapp then the background
 picture will probably notbe found.
 Say 
\family typewriter
http://my.domain.com/img/bkg.png
\family default
 is an unknown path.
 However 
\family typewriter
http://my.domain.com/
\bar under
myliftapp
\bar default
/img/bkg.png 
\family default
is known.
 In the example above we are calling fixCSS so that it will automatically
 replace the root relative paths such that 
\family typewriter
background-image: url('/img/bkg.png')
\family default
 becomes 
\family typewriter
background-image: url('/myliftapp/img/bkg.png')
\family default
.
 To use that in your lift application you can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
fixCSS example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def boot(){
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

	LiftRules.fixCSS("styles" :: "theme" :: Nil, Empty)
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the 
\family typewriter
/styles/theme.css
\family default
 file Lift will apply the prefix specified.
 But in this case we provodided an Empty Box.
 This actually means that Lift will apply the context path rturned by 
\family typewriter
S.contextPath 
\family default
function which as you know return the context path from the 
\family typewriter
HttpSession
\family default
.
\end_layout

\begin_layout Standard
Internally when you call 
\family typewriter
fixCSS
\family default
 a dispatch function is automatically created and prepended to 
\family typewriter
LiftRules.dispatch
\family default
.
 This is needed in order to intercept the broser reqiest to this .css resource.
 Also internally we are telling Lift the this resource must be server by
 Lift and not by container.
 
\end_layout

\begin_layout Standard
The way it works internally is that we are using Scala combinator parsers
 to augment only the root relative paths with the given prefix.
\end_layout

\begin_layout Section
HttpHelpers
\end_layout

\begin_layout Standard
This provides helper functions for HTTP parameters manipulation, URL encoding/de
coding etc.
 
\end_layout

\begin_layout Section
JSON
\end_layout

\begin_layout Standard
Lift provides its own JSON parser if you ever need one.
 At a first glance it may be a bit rendundant with Scala's JSON parser but
 infact Scala'sparser has its own problems with large JSON objects hence
 List's uses its own JSON parser implemented of course using combinator
 parsers.
\end_layout

\begin_layout Section
LD
\end_layout

\begin_layout Standard
Provides utility functions for calculating the distance between words 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Levenshtein_distance
\end_layout

\end_inset


\end_layout

\begin_layout Section
ListHelpers
\end_layout

\begin_layout Standard
Provides utility functions for manipulating lists that are not provided
 by Scala libraries.
\end_layout

\begin_layout Section
Log
\end_layout

\begin_layout Standard
Used to abstract the logging.
 It provides functions like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Log example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

 def trace(msg: => AnyRef)
\end_layout

\begin_layout Plain Layout

 def debug(msg: => AnyRef) 
\end_layout

\begin_layout Plain Layout

 def error(msg: => AnyRef)
\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default it uses Log4J logger but you an of course provideay other implementat
ion.
 See 
\family typewriter
LogBoot.loggerByName
\family default
 variable.
 
\end_layout

\begin_layout Standard
It is important to note that each logger function does not take a value
 as parameter but instead a call-by-name function.
 Normally if we use Log4J's 
\family typewriter
log.error(
\begin_inset Quotes eld
\end_inset

Message
\begin_inset Quotes erd
\end_inset

)
\family default
 even if the error log is not enabled the function parameters are still
 computed.
 In large applications this may consume quite considerable amount of time.
 However in Lift's case if we are calling 
\family typewriter
Log.error(
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

)
\family default
 the parameter is lazily evaluated and it will be evaluated ONLY IF the
 error logger is enabled.
 This is extremely useful as we don't have to wrap the logging calls like
 
\family typewriter
if (log.isErrorEnabled()) {log.error(
\begin_inset Quotes eld
\end_inset

Message
\begin_inset Quotes erd
\end_inset

)}
\family default
.
\end_layout

\begin_layout Section
Mailer
\end_layout

\begin_layout Standard
Utility class that allows you to send emails.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Mailer example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Mailer.sendMail(
\begin_inset Quotes eld
\end_inset

john.doe@domain.com
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

jane.doe@domain.com
\begin_inset Quotes erd
\end_inset

, PlainMailBodyType(
\begin_inset Quotes eld
\end_inset

Honey, I'm comming home !
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the call to sendMail is asynchronous.
\end_layout

\begin_layout Section
NamedPartialFunctions
\end_layout

\begin_layout Standard
Provides extremly useful functions for invoking partial functions that are
 chained in lists of functions.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
NamedPF exmaple
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var f1: PartialFunction[Int,Int] = {
\end_layout

\begin_layout Plain Layout

  case 10 => 11
\end_layout

\begin_layout Plain Layout

  case 12 => 14
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var f2: PartialFunction[Int,Int] = {
\end_layout

\begin_layout Plain Layout

  case 20 => 11
\end_layout

\begin_layout Plain Layout

  case 22 => 14
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

NamedPF(10, f1 :: f2 :: Nil)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Remember that many LiftRules variable are RuleSeq-s.
 Meaning that most of the times we re talking about lists of partial functions.
 Hence internally lift uses NamedPF for invoking such functions that ultimatelly
 are provided by the user.
 Please see 
\family typewriter
LiftRules.dispatch
\end_layout

\begin_layout Section
SecurityHelpers
\end_layout

\begin_layout Standard
Provides various functions used for random number generation, encryption/decript
ions (blowfish), hash calculations (MD5, SHA, SHA-256) and so on.
\end_layout

\begin_layout Section
TimeHelpers
\end_layout

\begin_layout Standard
Utility functions for time operations.
 For instance if also provides a set of implicit converion functions thatallow
 you to type 
\begin_inset Quotes eld
\end_inset

10 seconds
\begin_inset Quotes erd
\end_inset

 and returns the value in milliseconds.
 
\end_layout

\end_body
\end_document
