#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift Helpers
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Lift provides a a pretty consistent collection of helper artifacts.
 The helpers are essentially utility functions that helps you avoid boilerplate
 code.
 Hence it isimportant to be aware what is provided by Lift already for you
 to use so you wont have to spend time coding something that already exists.
\end_layout

\begin_layout Standard
Pretty much all Lift's helpers live in 
\family typewriter
net.liftweb.util
\family default
 package.
\end_layout

\begin_layout Section
Box (or Scala's Option class on steroids)
\end_layout

\begin_layout Standard
The Box is a utility that is built on top of Scala's Option Type (also heavily
 used inside Lift ), so let's take a quick look at Option first.
 The Option class allows for typesafe method of dealing with a situation
 where you may or may not have a result.
 Option has two values, either Some(value) where value is actually the value
 and None which is used to represent nothing.
 A typical example for Option is outlined using Scala's Map type.
 Below you'll see a definition of a Map, a successful attempt to get the
 value of key 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and an attempt to get the value of key 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

.Notice that when there was an existing key-value pair for 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 the value was returned as Some(A) and when we asked for the value of key
 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 we received None.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout
Option and Map example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
scala> val cap = Map("a" -> "A", "b" -> "B") 
\end_layout

\begin_layout LyX-Code
cap: scala.collection.immutable.Map[java.lang.String,java.lang.String] = Map(a
 -> A, b -> B)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
scala> cap.get("a")  
\end_layout

\begin_layout LyX-Code
res1: Option[java.lang.String] = Some(A)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
scala> cap.get("i") 
\end_layout

\begin_layout LyX-Code
res2: Option[java.lang.String] = None 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Getting the value out of an Option is usually handled via map, for example:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout

Fetch value from an Option
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
def prettyPrint(foo: Option[String]): String = foo match {
\end_layout

\begin_layout LyX-Code
  case Some(x) => x
\end_layout

\begin_layout LyX-Code
  case None => 
\begin_inset Quotes eld
\end_inset

Nothing found.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout

    
\lang english
Which would be used in conjunction with the previous code:
\end_layout

\begin_layout LyX-Code
scala> prettyPrint(cap.get("a")) 
\end_layout

\begin_layout LyX-Code
res7: String = A
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
scala> prettyPrint(cap.get("i")) 
\end_layout

\begin_layout LyX-Code
res8: String = Nothing found.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before detailing the Box functionality, it is relevant to point out some
 interesting functionality about Option.
 Lots of times when writing code we have to doa bunch of null checks than
 perform that operation then other null checks, other operations and so
 one.
 So we would have something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Pseudocode nested operations example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

	x = getSomeValue();
\end_layout

\begin_layout Plain Layout

	if (x != null) {
\end_layout

\begin_layout Plain Layout

  	y = getSomeOtherValue();
\end_layout

\begin_layout Plain Layout

  	if (y != null) {
\end_layout

\begin_layout Plain Layout

    	compute(x, y);
\end_layout

\begin_layout Plain Layout

  	}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
 so you got the picture.
 Needless to say how tedious such style is in practice.
 Now let's see if we can do better with Scala and Option.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Scala nested operations example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def getSomeValue(): Option[Int] = Some(12)     
\end_layout

\begin_layout Plain Layout

    def getSomeOtherValue(): Option[Int] = Some(2)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def compute(x: Int, y: Int) = x * y
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    val res = for ( x <- getSomeValue();
\end_layout

\begin_layout Plain Layout

    	            y <- getSomeOtherValue() if x > 10) yield compute(x, y)
\end_layout

\begin_layout Plain Layout

    println(res) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above example we have to values x and y and we want to do some computatio
n with these values.
 But we must ensure that computation is done on the correct data.
 For instance the computation can not be done if 
\family typewriter
getSomeValue()
\family default
 returns no value.
 In this context the two function return an Option[Int].
 The interesting part is that if eith ofthe two functions or both return
 a None Option instead of Some (None impersonating the non-existence of
 the value) the res value will also be None.
 However if both functions return a Some (like in the very example) the
 computation is called and res will be a 
\family typewriter
Some(24)
\family default
.
 But we have something else interesting here: 
\family typewriter
if x > 10
\family default
.
 If we would make getSomeValue to return a value less or equalwith 10 the
 res value will be None.
 The point of all this is to exemplify the power of Option and for comprehention
s in Scala and how it can be used to build quite complex expressions and
 yet keep an impressive code claririty.
\end_layout

\begin_layout Standard
Lift's Box extends Option with a few ideas, mainly the fact that you can
 add a message about why a Box is Empty.
 Empty corresponds to Option's None and Full to Option's Some.
 So you can pattern match against a Box like:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout

Box example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
a match {
\end_layout

\begin_layout LyX-Code
  Full(author) => Text(
\begin_inset Quotes eld
\end_inset

I found the author 
\begin_inset Quotes eld
\end_inset

 + author.niceName)
\end_layout

\begin_layout LyX-Code
  Empty => Text(
\begin_inset Quotes eld
\end_inset

No author by that name.
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
  Failure(message, _, _) => Text(
\begin_inset Quotes eld
\end_inset

Nothing found due to 
\begin_inset Quotes eld
\end_inset

 + message) // message may be something like 
\begin_inset Quotes eld
\end_inset

Database disconnected.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
def confirmDelete {     
\end_layout

\begin_layout LyX-Code
  (for (val id <- param("id");     // get the ID           
\end_layout

\begin_layout LyX-Code
        val user <- User.find(id)) // find the user                     
                                                           
\end_layout

\begin_layout LyX-Code
  yield {          
\end_layout

\begin_layout LyX-Code
    user.delete_!                   
\end_layout

\begin_layout LyX-Code
    notice("User deleted")          
\end_layout

\begin_layout LyX-Code
    redirectTo("/simple/index.html")        
\end_layout

\begin_layout LyX-Code
  }) getOrElse {error("User not found"); redirectTo("/simple/index.html")}
    
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In conjunction with the above example we have.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

\begin_inset Caption

\begin_layout Plain Layout

openOr example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
lazy val UserBio = UserBio.find(By(UserBio.id, id)) openOr (new UserBio)
\end_layout

\begin_layout LyX-Code
def view (xhtml: NodeSeq): NodeSeq = passedAuthor.map({ author => 
\end_layout

\begin_layout LyX-Code

  
\lang english
// do bind, etc here and return a NodeSeq
\end_layout

\begin_layout LyX-Code
}) openOr Text("Invalid author") 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So you can think of Box as a container that can either contain something
 or to be empty.
 A Box can be empty from various causes including some error conditions.
 This is why we also have Failure which is an Empty Box but contains information
 about the error.
 See 
\family typewriter
case class Failure(msg: String, exception: Box[Throwable], chain: Box[Failure])
\family default
.
\end_layout

\begin_layout Standard
We won't be detailing here all the Box functions but a few words on the
 most common function might be benficial.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Short example.
 Assume myBox is a Box
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
openOr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns the value contained by this Box.
 If the Box is Empty 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox openOr 
\begin_inset Quotes eld
\end_inset

The box is Empty
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
map
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apply a function on the values of this Box and return something else.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox map (value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dmap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalent with map(..) openOr default_value.
 The default value will be returned in case the map is Empty
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
myBox dmap(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

)(value => value + 
\begin_inset Quotes eld
\end_inset

 suffix
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that Box contains a set of implicit conversion functions form/to Option
 and from/to Iterable.
\end_layout

\begin_layout Subsection
Time/date formatting
\end_layout

\begin_layout Standard
Various time span and general convenience functions.
\end_layout

\begin_layout Subsection
String formatting and utilities
\end_layout

\begin_layout Standard
Capitailize, spliting, parsing strings to numbers, cleaning non-standard
 chars.
\end_layout

\begin_layout Subsection
Encryption and hashing
\end_layout

\begin_layout Standard
Blowfish en/decrypt, md5, sha256, hexEncode
\end_layout

\begin_layout Subsection
List helpers
\end_layout

\begin_layout Standard
Rotation, enumsToList, join, or
\end_layout

\begin_layout Subsection
Binding
\end_layout

\begin_layout Standard
Binding for templates
\end_layout

\begin_layout Subsection
URL modification
\end_layout

\begin_layout Standard
encode, decode, add params, check appropriate file extensions.
\end_layout

\begin_layout Subsection
IO Helpers
\end_layout

\begin_layout Standard
Reading files and Streams, executing files
\end_layout

\begin_layout Subsection
tryo wrappers
\end_layout

\begin_layout Standard
Addition to try blocks, allows the developer to ignore certain exceptions.
\end_layout

\begin_layout Subsection
Regular Expressions
\end_layout

\end_body
\end_document
