#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Advanced Lift Architecture
\begin_inset CommandInset label
LatexCommand label
name "cha:Advanced-Lift-Guts"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
This chapter is still under active development.
 The contents will change.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Congratulations! You've either made it through the introduction to Lift,
 or maybe you've just skipped Basics and jumped right to here to Advanced;
 either way, the next group of chapters will be exciting.
 
\end_layout

\begin_layout Standard
In this chapter we're going to dive into some of the advanced guts of Lift
 so that you have a thorough understanding of what's going on before we
 explore further.
\end_layout

\begin_layout Section
Architectural Overview
\end_layout

\begin_layout Standard
Before we jump into the specific details of the architecture, let's refresh
 our memories.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture-diagram"

\end_inset

 highlights the main Lift components and where they live in the ecosystem.
 Scala compiles down to Java bytecode, so we sit on top of the JVM.
 Lift Applications are typically run in a J(2)EE web container, such as
 Jetty or Tomcat.
 As we explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Entry-into-Lift"

\end_inset

, Lift is set up to act as a Filter
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/Filter.html"

\end_inset


\end_layout

\end_inset

 that acts as the entry point.
 Usage of the rest of the framework varies from application to application,
 depending on how simple or complex you make it.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/LiftArchDiagram.pdf
	BoundingBox 0bp 5.75in 5in 792bp
	clip

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The major components outlined in the diagram are:
\end_layout

\begin_layout Description
LiftCore The engine of the framework responsible for request/response lifecycle,
 rendering pipeline, invoking user's functions etc.
 We don't directly cover the core in this book since essentially all of
 the functionality that we do cover sits on top of the core
\end_layout

\begin_layout Description
SiteMap Contains the web pages for a Lift application (chapter
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

)
\end_layout

\begin_layout Description
LiftRules Allows you to configure Lift.
 We cover this in various sections throughout the book
\end_layout

\begin_layout Description
LiftSession The session state representation (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-Management"

\end_inset

)
\end_layout

\begin_layout Description
S The stateful object impersonating the state context for a given request/respon
se lifecycle (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Advanced-S-Object"

\end_inset

)
\end_layout

\begin_layout Description
SHtml Contains helper functions for XHtml artifacts (chapters 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Forms-in-Lift"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

)
\end_layout

\begin_layout Description
Views LiftView objects impersonating a view as a XML content.
 Thus pages can be composed from other sources not only from html files.
 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Views"

\end_inset

)
\end_layout

\begin_layout Description
LiftResponse Represents the abstraction of a response that will be propagated
 to the client.
 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

)
\end_layout

\begin_layout Description
Comet Represents the Comet Actors layer which allows the sending of asynchronous
 content to the browser (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:COMET"

\end_inset

)
\end_layout

\begin_layout Description
ORM - Either Mapper or Record - The lightweight ORM library provided by
 Lift.
 The Mapper framework is the proposed ORM framework for Lift 1.0 and the
 Record framework will be out for next releases.
 (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:mapper_and_record"

\end_inset

)
\end_layout

\begin_layout Description
HTTP
\begin_inset space ~
\end_inset

Auth - You can use either Basic or Digest HTTP authentication in your Lift
 application.
 This provides you more control as opposed to web-container's HTTP authenticatio
n model.
 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:HTTP-Authentication"

\end_inset

)
\end_layout

\begin_layout Description
JS
\begin_inset space ~
\end_inset

API The JavaScript abstraction layer.
 These are Scala classes/objects that abstract JavaScript artifacts.
 Such objects can be combined to build JavaScript code (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Lift-and-Javascript"

\end_inset

)
\end_layout

\begin_layout Description
Utils Contains a number of helper functions that Lift uses internally and
 are available to your application
\end_layout

\begin_layout Section
The Request/Response Lifecycle
\begin_inset CommandInset label
LatexCommand label
name "sec:Request/Response-Lifecycle"

\end_inset


\end_layout

\begin_layout Standard
We briefly discussed the Request/Response Liftcycle in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-Rendering-Process"

\end_inset

, and now we're going to cover it in depth.
 This will serve not only to familiarize you with the full processing power
 of Lift, but also to introduce some of the other advanced topics we'll
 be discussing in this and later chapters.
\end_layout

\begin_layout Standard
One important thing we'd like to mention is that most of the configurable
 properties are in 
\family typewriter
LiftRules
\family default
, and are of type 
\family typewriter
RulesSeq
\family default
.
 With a 
\family typewriter
RulesSeq
\family default
 you essentially have a list of functions or values that are applied in
 order.
 
\family typewriter
RulesSeq
\family default
 defines a prepend and append method that allows you to add new configuration
 items at the beginning or end of the configuration, respectively.
 This allows you to prioritize things like partial functions and compose
 various methods together to control Lift's behavior.
 You can think of a RulesSeq as a Seq on steroids, tweaked for Lift's usage.
\end_layout

\begin_layout Standard
The following list outlines, in order, the process of transforming a Request
 into a Response.
 We provide references to the sections of the book where we discuss each
 step in case you want to branch off.
\end_layout

\begin_layout Enumerate
Execute early functions: this is a mechanism that allows a user function
 to be called on the HttpServletRequest before it enters the normal processing
 chain.
 This can be used for, for example, to set the XHTML output to UTF-8.
 This is controlled through 
\family typewriter
LiftRules.early
\end_layout

\begin_layout Enumerate
Perform URL Rewriting, which we already covered in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:URL-Rewriting"

\end_inset

.
 Controlled via 
\family typewriter
LiftRules.rewrite
\family default
, this is useful for creating user-friendly URLs, among other things.
 The result of the transformation will be checked for possible rewrites
 until there are no more matches or it is explicitly stopped by setting
 the 
\family typewriter
stopRewriting
\family default
 val in ReqwriteResponse to 
\family typewriter
true
\family default
.
 It is relevant to know that you can have rewriter functions per-session
 hence you can have different rewriter in different contexts.
 These session rewriters are prended to the LiftRules rewriters before their
 application.
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftRules.onBeginServicing
\family default
 hooks.
 This is a mechanism that allows you to add your own hook functions that
 will be called when Lift is starting to process the request.
 You could set up logging here, for instance.
\end_layout

\begin_layout Enumerate
Check for user-defined stateless dispatch in 
\family typewriter
LiftRules.statelessDispatchTable
\family default
.
 If the partial functions defined in this table match the request then they
 are used to create a 
\family typewriter
LiftResponse
\family default
 that is sent to the user, bypassing any further processing.
 These are very useful for building things like REST APIs.
 The term stateless refers to the fact that at the time the dispatch function
 is called, the stateful object, called 
\family typewriter
S
\family default
, is not available and the 
\family typewriter
LiftSession
\family default
 is not created yet.
 Custom dispatch is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset


\end_layout

\begin_layout Enumerate
Create a 
\family typewriter
LiftSession
\family default
.
 The 
\family typewriter
LiftSession
\family default
 holds various bits of state for the request, and is covered in more detail
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-Management"

\end_inset

.
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onSetupSession
\family default
.
 This is a mechanism for adding hook functions that will be called when
 the LiftSession is created.
 We'll get into more details when we discuss Lift's session management in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-Management"

\end_inset

.
\end_layout

\begin_layout Enumerate
Initialize the 
\family typewriter
S
\family default
 object (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:S-object"

\end_inset

).
 The 
\family typewriter
S
\family default
 object represents the current state of the Request and Response.
\end_layout

\begin_layout Enumerate
Call any 
\family typewriter
LoanWrapper
\family default
 instances that you've added through 
\family typewriter
S.addAround
\family default
.
 A 
\family typewriter
LoanWrapper
\family default
 is a way to insert your own processing into the render pipeline, similar
 to how Filter works in the Servlet API.
 This means that when your 
\family typewriter
LoanWrapper
\family default
 implementation is called, Lift passes you a function allowing you to chain
 the processing of the request.
 With this functionality you can execute your own pre- and post-condition
 code.
 A simple example of this would be if you need to make sure that something
 is configured at the start of processing and cleanly shut down when processing
 terminates.
 LoanWrappers are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Wrapping-Lift's-processing"

\end_inset


\end_layout

\begin_layout Enumerate
Process the stateful request
\end_layout

\begin_deeper
\begin_layout Enumerate
Check the stateful dispatch functions defined in 
\family typewriter
LiftRules.dispatch
\family default
.
 This is similar to the stateless dispatch in step #4 except that these
 functions are executed in the context of a LiftSession and an 
\family typewriter
S
\family default
 object (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:S-object"

\end_inset

).
 The first matching partial function is used to generate a 
\family typewriter
LiftResponse
\family default
 that is returned to the client.
 If none of the dispatch functions match then processing continues.
 Dispatch functions are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

.
 This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls
\end_layout

\begin_layout Enumerate
If this is a 
\series bold
Comet
\series default
 request, then process it and return the response.
 Comet is a method for performing asynchronous updates of the user's page
 without a reload.
 We cover Comet techniques in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset


\end_layout

\begin_layout Enumerate
If this is an 
\series bold
Ajax
\series default
 request, execute the user's callback function; the specific function is
 mapped via a request parameter (essentially a token).
 The result of the callback is returned as the response to the user.
 The response can be a JavaScript snippet, an XML construct or virtually
 any 
\family typewriter
LiftResponse
\family default
.
 For an overview of 
\family typewriter
LiftResponse
\family default
 please see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

.
 This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls.
\end_layout

\begin_layout Enumerate
If this is a regular HTTP request, then:
\end_layout

\begin_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onBeginServicing
\family default
 hooks.
 Mostly 
\begin_inset Quotes eld
\end_inset

onBegin
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

onEnd
\begin_inset Quotes erd
\end_inset

 functions are used for logging.
 Note that LiftRules also have onBeginServicing and onEndServicing functions
 but theae are 
\begin_inset Quotes eld
\end_inset

wrapping
\begin_inset Quotes erd
\end_inset

 more Lift processing not only statefull processing.
\end_layout

\begin_layout Enumerate
Check the user-defined dispatch functions that are set per-session (
\family typewriter
see S.addHighLevelSessionDispatcher
\family default
).
 This is similar to 
\family typewriter
LiftRules.dispatch
\family default
 except that you can have different functions set up for a different session
 depending on your application logic.
 If there is a function applicable, execute it and return its response.
 If there is no per-session dispatch function, process the request by executing
 the Scala function that user set up for specific events (such as when clicking
 a link, or pressing the submit button, or a function that will be executed
 when a form field is set etc.).
 Please see SHtml obejct 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SHtml"

\end_inset

.
\end_layout

\begin_layout Enumerate
Check the SiteMap and Loc functions.
 We cover SiteMap extensively in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset

.
\end_layout

\begin_layout Enumerate
Lookup the template based on the request path.
 Lift will locate the templates using various approaches:
\end_layout

\begin_deeper
\begin_layout Enumerate
Check the partial functions defined in 
\family typewriter
LiftRules.viewDispatch
\family default
.
 If there is a function defined for this path invoke it and return an Either[
\begin_inset Formula $()\Rightarrow Can[NodeSeq]$
\end_inset

,LiftView].
 This allows you to either return the function for handling the view directly,
 or delegate to a LiftView subclass.
 LiftView is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Views"

\end_inset


\end_layout

\begin_layout Enumerate
If no viewDispatch functions match, then look for the template using the
 ServletContext's 
\family typewriter
getResourceAsStream
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Process the templates by executing snippets, combining templates etc.
\end_layout

\begin_deeper
\begin_layout Enumerate
Merge <head> elements, as described in section e
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Head-Merge"

\end_inset


\end_layout

\begin_layout Enumerate
Update the internal functions map.
 Basically this associates the user's Scala functions with tokens that are
 passed around in subsequent requests using HTTP query parameters.
 We cover this mechanism in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lift-Function-Mapping"

\end_inset


\end_layout

\begin_layout Enumerate
Clean up notices (see S.error, S.warning, S.notice) since they were already
 rendered they are no longer needed.
 Notices are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Message-Handling"

\end_inset

.
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftRules.convertResponse
\family default
.
 Basically this glues together different pieces if information such as the
 actual markup, the response headers, cookies, etc into a LiftResponse instance.
\end_layout

\begin_layout Enumerate
Check to see if Lift needs to send HTTP redirect.
 For an overview please see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onEndServicing
\family default
 hooks, the counterparts to 
\family typewriter
LiftSession.onBeginServicing
\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftRules.performTransform
\family default
.
 This is actually configured via the 
\family typewriter
LiftRules.responseTransformers
\family default
 
\family typewriter
RulesSeq
\family default
.
 This is a list of functions on 
\begin_inset Formula $LiftResponse\Rightarrow LiftResponse$
\end_inset

 that allows the user to modify the response before it's sent to the client
\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftRules.onEndServicing
\family default
 hooks.
 These are the stateless end-servicing hooks, called after the S object
 context is destroyed.
\end_layout

\begin_layout Enumerate
Call any functions defined in 
\family typewriter
LiftRules.beforeSend
\family default
.
 This is the last place where you can modify the response before it's sent
 to the user
\end_layout

\begin_layout Enumerate
Convert the 
\family typewriter
LiftResponse
\family default
 to a raw byte stream and send it to client as an HTTP response.
\end_layout

\begin_layout Enumerate
Call any functions defined in 
\family typewriter
LiftRules.afterSend
\family default
.
 Typically these would be used for cleanup.
\end_layout

\begin_layout Standard
We realize that this is a lot of information to digest in one pass, so as
 we continue to cover the specific details of the rendering pipeline you
 may want to keep a bookmark here so that you can come back and process
 the new information in the greater context of how Lift is working.
\end_layout

\begin_layout Section
Lift Function Mapping
\begin_inset CommandInset label
LatexCommand label
name "sub:Lift-Function-Mapping"

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Form-Fundamentals"

\end_inset

, lift utilizes scala closures and functions for almost all processing of
 client data.
 Because of this, Lift's ability to associate functions with specific form
 elements, AJAX calls, etc, is critical to its operation.
 This association of functions, commonly known as 
\begin_inset Quotes eld
\end_inset

mapping
\begin_inset Quotes erd
\end_inset

 is handled through a combination of request parameters, Scala closures
 and Session data.
 We feel that understanding how mapping works is important if you want to
 work on advanced topics.
\end_layout

\begin_layout Standard
At its most basic, mapping of functions is just that; a map of the user's
 currently defined functions.
 To simplify things, Lift actually uses one of four subclasses of AFuncHolder
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.S.AFuncHolder
\end_layout

\end_inset

:
\end_layout

\begin_layout Description
BinFuncHolder used for binding functions for file uploading.
 It will hold a 
\begin_inset Formula $FileParamHolder\Rightarrow Any$
\end_inset

 function, which is used to process the file data after upload (section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:File-Uploads"

\end_inset

)
\end_layout

\begin_layout Description
SFuncHolder used for binding 
\begin_inset Formula $String\Rightarrow Any$
\end_inset

 functions.
 This function corresponds to a single HTTP query parameter, except that
 the parameter name is 
\emph on
unique to this request
\emph default
 (we'll cover naming shortly)
\end_layout

\begin_layout Description
LFuncHolder used for binding 
\begin_inset Formula $List[String]\Rightarrow Any$
\end_inset

 functions.
 This is essentially the same as SFuncHolder but for multiple values
\end_layout

\begin_layout Description
NFuncHolder used for binding 
\begin_inset Formula $()\Rightarrow Any$
\end_inset

 functions.
 Typically these are used for event callabcks (such as form submission)
\end_layout

\begin_layout Standard
Wherever Lift takes a function callback it is converted to one of these
 types behind the scenes.
 Also on the backend, each function is assigned a token ID (generated by
 
\family typewriter
Helpers.nextFuncName
\family default
), which is then added to the session, typically via 
\family typewriter
S.addFunctionMap
\family default
 or 
\family typewriter
S.mapFunc
\family default
.
 The token is generally used as the form element name so that the tokens
 for a given form are passed back to Lift when the form is submitted; in
 AJAX, the token is used as an HTTP query parameter of the AJAX callback
 from the client JavaScript code.
 In either case, Lift processes the query parameters within LiftSession.runParams
 and executes each associated function in the function mapping.
\end_layout

\begin_layout Standard
As a concrete example, let's look at a simple binding in a form.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Function-binding-snippet"

\end_inset

 shows a small example snippet that will request a person's name and print
 it out when the person clicks the submit button.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Function binding snippet
\begin_inset CommandInset label
LatexCommand label
name "lst:Function-binding-snippet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def greet (xhtml : NodeSeq) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

  var name = 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  def process() = {
\end_layout

\begin_layout Plain Layout

    println(name)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  bind(
\begin_inset Quotes eld
\end_inset

form
\begin_inset Quotes erd
\end_inset

, xhtml, 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 -> SHtml.text(name, name = _),
\end_layout

\begin_layout Plain Layout

                      
\begin_inset Quotes eld
\end_inset

greet
\begin_inset Quotes erd
\end_inset

 -> SHtml.submit(
\begin_inset Quotes eld
\end_inset

Greet
\begin_inset Quotes erd
\end_inset

, process))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Function-binding-template"

\end_inset

 shows the corresponding template using our sample snippet.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Function binding template
\begin_inset CommandInset label
LatexCommand label
name "lst:Function-binding-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with=
\begin_inset Quotes erd
\end_inset

default
\begin_inset Quotes erd
\end_inset

 at=
\begin_inset Quotes erd
\end_inset

content
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

  <lift:Test.greet form=
\begin_inset Quotes erd
\end_inset

GET
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

    <form:name /> <form:greet />
\end_layout

\begin_layout Plain Layout

  </lift:Test.greet>
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Function-binding-result"

\end_inset

 shows an example of the resulting HTML that's generated when a user views
 the template.
 As you can see, each of the elements with callbacks has a corresponding
 form element with a token ID for the name value.
 Since we've used the GET CGI method here (we usually recommend using POST
 in the real world), when we submit the form our URL would look like 
\family typewriter
/greet.html?F541542594358JE2=...&F541542594359PM4=Greet
\family default
.
 For SFuncHolder mappings the value of the request parameter is passed directly.
 For NFuncHolders the presence of the token in the query parameter list
 is enough to fire the function.
 For BinFuncHolder and LFuncHolder mappings some additional processing is
 performed to coerce the submitted values into proper values for the functions
 to handle.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Function binding result
\begin_inset CommandInset label
LatexCommand label
name "lst:Function-binding-result"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<form method="get" action="/greet.html">
\end_layout

\begin_layout Plain Layout

  <input name="F541542594358JE2" type="text" value=""/>
\end_layout

\begin_layout Plain Layout

  <input name="F541542594359PM4" type="submit" value="Greet"/>
\end_layout

\begin_layout Plain Layout

</form> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Normally you do not have to directly deal with the function holder classes,
 since the generator functions in SHtml handle that internally.
 However, if you're in a situation when you need to bind functions by yourself
 (such as building your own widget where SHtml doesn't provided needed elements)
, you can use the previously mentioned 
\family typewriter
S.addFunctionMap
\family default
 or 
\family typewriter
S.mapFunc
\family default
 to do the 
\begin_inset Quotes eld
\end_inset

registration
\begin_inset Quotes erd
\end_inset

 for you.
\end_layout

\begin_layout Section
LiftResponse in Detail
\begin_inset CommandInset label
LatexCommand label
name "sec:LiftResponse-in-Detail"

\end_inset


\end_layout

\begin_layout Standard
The Lift framework makes a lot of things really easy and it provides extremly
 useful abstractions as you may have already discovered.
 Responses to clients are also abstacted by 
\family typewriter
LiftResponse
\family default
 trait.
 There are numerous response types and here is the simplified view of the
 class hierarchy:
\end_layout

\begin_layout Itemize
LiftResponse
\end_layout

\begin_deeper
\begin_layout Itemize
BasicResponse
\end_layout

\begin_deeper
\begin_layout Itemize
InMemoryResponse
\end_layout

\begin_layout Itemize
StreamingResponse
\end_layout

\end_deeper
\begin_layout Itemize
JSonResponse
\end_layout

\begin_layout Itemize
RedirectResponse
\end_layout

\begin_deeper
\begin_layout Itemize
RedirectWithState
\end_layout

\end_deeper
\begin_layout Itemize
ToResponse
\end_layout

\begin_deeper
\begin_layout Itemize
XhtmlRespomse
\end_layout

\begin_layout Itemize
XmlResponse
\end_layout

\begin_layout Itemize
XmlMimeResponse
\end_layout

\begin_layout Itemize
AtomResponse
\end_layout

\begin_layout Itemize
OpenSearchResponse
\end_layout

\begin_layout Itemize
AtomCreatedResponse
\end_layout

\begin_layout Itemize
AtomCategoryResponse
\end_layout

\begin_layout Itemize
AtomServiceResponse
\end_layout

\begin_layout Itemize
CreatedResponse
\end_layout

\end_deeper
\begin_layout Itemize
OkResponse
\end_layout

\begin_layout Itemize
PermRedirectResponse
\end_layout

\begin_layout Itemize
BadResponse
\end_layout

\begin_layout Itemize
UnauthorizedResponse
\end_layout

\begin_layout Itemize
UnauthorizedDigestResponse
\end_layout

\begin_layout Itemize
NotFoundResponse
\end_layout

\begin_layout Itemize
MethodNotAllowedResponse
\end_layout

\begin_layout Itemize
GoneResponse
\end_layout

\end_deeper
\begin_layout Standard
We won't get into details right now on what exactly each and every class/object
 does, although their purpose is given away by their names.
 It is important to know that whenever you need to return a 
\family typewriter
LiftResponse
\family default
 reference from one of your functions, for example 
\family typewriter
LiftRules.dispatch
\family default
 you can you can use one of these classes.
 Lift doesn't really provide the HttpServletResponse object, instead all
 responses are impersonated by a 
\family typewriter
LiftResponse
\family default
 instance and it content (the actual payload, http headers, content-type,
 cookies etc.) is written internally by Lift to the container's output stream.
\end_layout

\begin_layout Standard
Still let's take a look at a few examples
\end_layout

\begin_layout Subsection
RedirectWithState
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
RedirectWithState example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Assume you boot function
\end_layout

\begin_layout Plain Layout

import MessageState._
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def boot = { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LiftRules.dispatch.prepend {
\end_layout

\begin_layout Plain Layout

  case Req("redirect1" :: _, _, _) => () => 
\end_layout

\begin_layout Plain Layout

	Full(RedirectWithState("/page1", "My error" -> Error))
\end_layout

\begin_layout Plain Layout

  case Req("redirect2" :: _, _, _) => () => 
\end_layout

\begin_layout Plain Layout

	Full(RedirectWithState("/page2", 
\end_layout

\begin_layout Plain Layout

	       				RedirectState(() => println(
\begin_inset Quotes eld
\end_inset

Called on redirect!
\begin_inset Quotes erd
\end_inset

), 
\end_layout

\begin_layout Plain Layout

			  		   				"My error" -> Error)))     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all we added a DispatchPF function that pattern matches for paths
 starting with 
\family typewriter
redirect1
\family default
 and 
\family typewriter
redirect2
\family default
.
 Let's see what happens in each case.
\end_layout

\begin_layout Itemize

\family typewriter
redirect1
\family default
 - We are returning a RedirectWithState response.
 It will do HTTP redirect towards /page1 and the state is impersonated by
 the tuple 
\begin_inset Quotes eld
\end_inset

MyError
\begin_inset Quotes erd
\end_inset

 -> Error.
 Because MessageState object holds an implicit conversion function from
 Tuple2 to MessageState it suffices to just provide the tuple here.
 Essentially we are saying here that when the browser sends the redirect
 request to server we already have an Error notice set up and the <lift:msgs>
 tag from your /page1 will show this 
\begin_inset Quotes eld
\end_inset

My error
\begin_inset Quotes erd
\end_inset

 error message.
\end_layout

\begin_layout Itemize

\family typewriter
redirect2
\family default
 - Similarly it does an HTTP redirect to browser towards your /page2.
 But we are passing now a RedirectState object.
 This object holds a () => Unit function that will be executed when browser
 send the redirect request and the Notices impersonated by a repeated parameter
 (String, NoticeType.Value)*.
 In fact the mapping between the actual message and its type: Notice, Warning
 or Error.
\end_layout

\begin_layout Subsection
XmlResponse
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XmlResponse example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Assume you boot function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def boot = { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LiftRules.dispatch.prepend {
\end_layout

\begin_layout Plain Layout

  case Req("rest" :: Nil, _, _) => () => Full(XmlResponse(
\end_layout

\begin_layout Plain Layout

		<persons>
\end_layout

\begin_layout Plain Layout

			<name>John</name>
\end_layout

\begin_layout Plain Layout

			<name>Jane</name>
\end_layout

\begin_layout Plain Layout

		</persons>
\end_layout

\begin_layout Plain Layout

	))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When you are receiving a request with the path /rest the code is returning
 an XML response.
 The content-type and everything else is taken care of by XmlResponse.
 You can build much more complex REST API's an return XML response which
 is probably mot commonly used.
\end_layout

\begin_layout Section
Session Management 
\begin_inset CommandInset label
LatexCommand label
name "sec:Session-Management"

\end_inset


\end_layout

\begin_layout Standard
Lift is a stateful framework and naturally this state needs to be managed.
 You may already be familiar with HttpSession and and how a J(2)EE web container
 identifies an HttpSession; either by a JSESSIONID cookie or by a JSESSIONID
 URI sequence (in case of URL rewriting).
 Similarly, Lift uses a LiftSession reference which is not actually 
\begin_inset Quotes eld
\end_inset

persisted
\begin_inset Quotes erd
\end_inset

 in HttpSession.
 As a matter of fact Lift does not really use the HttpSession provided by
 the web container to maintain conversational state, but rather uses a bridge
 between the 
\family typewriter
HttpSession
\family default
 and the 
\family typewriter
LiftSession
\family default
.
 This bridge is impersonated by 
\family typewriter
SessionToServletBridge
\family default
 class which implements 
\emph on
javax.servlet.http.HttpSessionBindingListener
\emph default
 and 
\emph on
javax.servlet.http.HttpSessionActivationListener
\emph default
 and works like this:
\end_layout

\begin_layout Enumerate
When receiving an HTTP Request and there was no stateless dispatch function
 to execute, Lift does the stateful processing.
 But before doing that it checks to see if there is a 
\family typewriter
LiftSession
\family default
 associated with this HTTP session ID.
 This mapping is kept on a SessionMaster Scala actor.
 
\end_layout

\begin_layout Enumerate
If there is no associated LiftSession in the SessionMaster actor, create
 it and add a SessionToServletBridge attribute on HttpSession.
 This will make Lift aware of the session when the container terminates
 the HttpSession or when the HTTP session is about to be passivated or activated.
\end_layout

\begin_layout Enumerate
When the container terminates the HTTP session, SessionToServletBridge sends
 a message to the SessionMaster Actor to terminate the LiftSession, which
 includes the following steps:
\end_layout

\begin_deeper
\begin_layout Enumerate
Call any defined LiftSession.onAboutToShutdownSession hooks
\end_layout

\begin_layout Enumerate
Send a ShutDown message to all Comet Actors pertaining to this session
\end_layout

\begin_layout Enumerate
Clean up any internal LiftSession state
\end_layout

\begin_layout Enumerate
Call LiftSession.onShutdownSession hooks
\end_layout

\end_deeper
\begin_layout Standard
The SessionMaster Actor is also protected by another watcher Actor.
 This watcher Actor receives the Exit messages of the watched Actors.
 When it receives an Exit message it will call the users' failure functions
 and restart the watched actor (Please see ActorWatcher.failureFuncs).
 
\end_layout

\begin_layout Standard
Even while Lift is handling session management you still have the ability
 to manually add attributes to the HttpSession object.
 We do not recommend this unless you really must.
 A simpler way to keep your own session variables, is to use 
\family typewriter
SessionVar
\family default
s.
 For more details about SessionVar please see the fundamental chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-and-Request"

\end_inset


\end_layout

\begin_layout Standard
The next question would probably be 
\begin_inset Quotes eld
\end_inset

So we have internal session management, how do we cope with that in a clustered
 environment? ...
 how are sessions replicated?
\begin_inset Quotes erd
\end_inset

 the answer is, they aren't.
 There is no intention to use the web container's session replication as
 these technologies appears to be inferior to other solutions on the market.
 Relying on Java serialization brings a lot of performance concerns and
 alternative technologies have been investigated and they are still under
 investigation.
 Until there is a standard session replication technology you can still
 cluster you application using 
\begin_inset Quotes eld
\end_inset

sticky session
\begin_inset Quotes erd
\end_inset

.
 This meas that all requests pertaining to a HTTP session must be processed
 by the same cluster node.
 This can be done by software or hardware load balancers, as they would
 dispatch the requests based on JSESSIONID cookie.
 Another approach is that the dispatching is done based on some URI or query
 parameters.
 For example, a query parameter like serverid=1 is configured in the load
 balancer to always be dispatched to the node 1 of the cluster, and so on.
 There are some downsides for the sticky session approach.
 For instance you are logged in the application and do your stuff.
 Suddenly the node designated to your session crashes.
 At this moment you lost your session.
 The next subsequent request would be automatically dispatched by the load
 balancer to another cluster node and depending how your application is
 built this may mean that you need to log in again or if part of the state
 was persisted in DB you may resume your work from some point avoiding re-login
 ...
 but this is application specific behavior that is beyond the scope of this
 discussion.
 The advantages of sticky sessions are related with application performance
 since in this model the state does not need to be replicated in all cluster
 nodes which for significant state information can be quite time/resources
 consuming.
\end_layout

\begin_layout Section
Miscellaneous Lift Features
\end_layout

\begin_layout Standard
In this section we will discuss various features that can prove helpful
 in building rich Lift applications.
\end_layout

\begin_layout Subsection
Wrapping Lift's processing logic
\begin_inset CommandInset label
LatexCommand label
name "sub:Wrapping-Lift's-processing"

\end_inset


\end_layout

\begin_layout Standard
Lift provides the ability to allow user functions to be part of processing
 lifecycle.
 In these cases Lift allows you to provide your own functions and the actual
 Lift's processing function is passed to your function.
 Hence your own function is responsible of calling the actual Lift's processing
 logic.
 
\end_layout

\begin_layout Standard
But let's see how exactly you can do this.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LoanWrapper example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 class Boot {   
\end_layout

\begin_layout Plain Layout

  def boot {    
\end_layout

\begin_layout Plain Layout

    ...
   
\end_layout

\begin_layout Plain Layout

    S.addAround(new LoanWrapper { // Y   
\end_layout

\begin_layout Plain Layout

      def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

        println("Y -> hello to the request!")  
\end_layout

\begin_layout Plain Layout

        val result = f // Let Lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

		println("Y -> goodbye!")  
\end_layout

\begin_layout Plain Layout

        result   
\end_layout

\begin_layout Plain Layout

      }   
\end_layout

\begin_layout Plain Layout

    })   
\end_layout

\begin_layout Plain Layout

    S.addAround(new LoanWrapper { // X   
\end_layout

\begin_layout Plain Layout

      def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

        println("X -> hello to the request!")   
\end_layout

\begin_layout Plain Layout

        val result = f // Let Lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

        println("X -> goodbye!")   
\end_layout

\begin_layout Plain Layout

        result
\end_layout

\begin_layout Plain Layout

      }   
\end_layout

\begin_layout Plain Layout

    })   
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code looks pretty straight-forward in the sense that we add two 
\family typewriter
LoanWrapper
\family default
 instances to the 
\family typewriter
S
\family default
 object.
 (Note that we're using the 
\family typewriter
S
\family default
 object not 
\family typewriter
LiftRules
\family default
 meaning that 
\family typewriter
LoanWrapper
\family default
s are applicable only for stateful processing.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

 for when exactly 
\family typewriter
LoanWrapper
\family default
s are invoked.) 
\end_layout

\begin_layout Standard
So let's see what happens when the above code processess a request from
 a client.
 You can think of the invocation sequence as 
\family typewriter
X(Y(f))
\family default
 where f is the Lift function that impersonates the core processing.
 Therefore you'll see the following output in the console:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

X -> hello to the request!
\end_layout

\begin_layout Plain Layout

Y -> hello to the request!
\end_layout

\begin_layout Plain Layout

<Lift's logic ...
 whatever is printed here>
\end_layout

\begin_layout Plain Layout

Y -> goodbye!
\end_layout

\begin_layout Plain Layout

X -> goodbye!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This feature allows you use a resource before Lift does and release them
 after Lift has finished processing the stateful request and before the
 LiftResponse object is constructed.
\end_layout

\begin_layout Subsection
Additional Snippet Features
\begin_inset CommandInset label
LatexCommand label
name "sub:Additional-Snippet-Features"

\end_inset


\end_layout

\begin_layout Standard
By now you already have a fairly good idea how snippets work, how you can
 use them etc.
 There are a few things that were not revealed yet to you, such as:
\end_layout

\begin_layout Enumerate
Ability to pass parameters to snippets:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet attributes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:Ledger.balance default=
\begin_inset Quotes erd
\end_inset

10
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

  <ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Plain Layout

</lift:Ledger.balance>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How do we read the 
\emph on
default
\emph default
 attribute from the snippet code? Actualy it is only about calling S.attr
 function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet attributes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

	val dflt = S.attr(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

) openOr 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

    bind (
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset

, content,
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

balance
\begin_inset Quotes erd
\end_inset

 -> Text(currentLegdger.formattedBalance),
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 -> Text((new java.util.Date).toString))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Use snippets for tag attributes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Attribute Snippet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// In your page you can have
\end_layout

\begin_layout Plain Layout

<div lift:snippet="MyDivThing:calcDir"> ...
 </div>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

// Your snippet
\end_layout

\begin_layout Plain Layout

class MyDivThing {   
\end_layout

\begin_layout Plain Layout

  def calcDir = new UnprefixedAttribute("dir", "rtl", Null)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The utility of this support is quite obvious in so many situations.
 For instance when supporting right-to-left languages you can add the direction
 of the page to be rtl quite easily.
\end_layout

\end_deeper
\begin_layout Standard
Now we have seen how we can pass xml parameters to snippets but what if
 we want to pass parameters to the nodes that will be bound? For instance
 in Listing 1.3 we also want to pass the am/pm information:
\end_layout

\begin_layout Standard

\family typewriter
<ledger:time ampm=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

/> 
\family default
where the time will be displayed in AM-PM format as opposed to 24h format.
 But how can we access the ampm parameter?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet attributes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

	val dflt = S.attr(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

) openOr 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

    bind (
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset

, content,
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

balance
\begin_inset Quotes erd
\end_inset

 -> Text(currentLegdger.formattedBalance),
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 -> {node: NodeSeq => println(BindHelpers.attr(
\begin_inset Quotes eld
\end_inset

ampm
\begin_inset Quotes erd
\end_inset

)); Text((new java.util.Date).toString))}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The key aspect here is the BindHelpers object.
 You can use it for obtaining information about node attributes.
 This context is maintained internally using ThreadLocals and closures.
 Note that the context is cleared after bind method is executed.
 In our example above for 
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 node we are actually binding a function that takes the child nodes of the
 
\family typewriter
<ledger:time>
\family default
 node.
 When our function is called by Lift we can access the BindHelpers, such
 ass the attributes of the current node.
 The sequence 
\family typewriter
<string> -> <right-hand-side-expression>
\family default
 is turned into a BindParam object using implicit conversions.
 It is important to note that BindParam.calcValue function is called in the
 correct context so that BindHelpers can be safely used.
\end_layout

\begin_layout Section
Advanced S Object Features
\begin_inset CommandInset label
LatexCommand label
name "sub:Advanced-S-Object"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
S
\family default
, or Stateful, object is a very important part of Lift.
 The S context is created when a client request is recieved that needs to
 be handled as a stateful reuest.
 Please see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

 for more details on the state creation and handling.
 The actual state information is kept inside the S object using ThreadLocal
\begin_inset Foot
status open

\begin_layout Plain Layout
java.lang.ThreadLocal
\end_layout

\end_inset

 variables since 
\family typewriter
S
\family default
 is a singleton.
 This means that if you have any code that is executed in the stateful context
 you can safely use any 
\family typewriter
S
\family default
 object goodies, which include:
\end_layout

\begin_layout Subsection
Managing cookies
\end_layout

\begin_layout Standard
You can retrieve cookies from the request or set cookies to be sent in the
 response.
 Cookies are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cookies"

\end_inset

.
\end_layout

\begin_layout Subsection
Localization and Internationalization
\end_layout

\begin_layout Standard
Localization (also called L10N) and Internationalization (also called I18N)
 are very important aspects of many web applications that deal with different
 languages.
 These topics are covered in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Internationalization"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Managing the Timezone
\end_layout

\begin_layout Standard
The
\family typewriter
 S.timeZone
\family default
 function returns the current timezone as computed by the 
\family typewriter
LiftRules.timeZoneCalculator
\family default
 function.
 By default, the 
\family typewriter
LiftRules
\family default
 method simply executes TimeZone.getDefault, but you can provide your own
 
\begin_inset Formula $Box[HttpServletRequest]\Rightarrow TimeZone$
\end_inset

 partial function to define your own behavior.
 Examples would include allowing users to choose their own timezone, or
 to use geographic lookup of the user's IP address.
\end_layout

\begin_layout Subsection
Per-session DispatchPF functions 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Need an example of usage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can set DispatchPF functions that operate in the context of a current
 session.
 Essentially you can bind DispatchPF functions with a given name.
 Relevant functions are:
\end_layout

\begin_layout Itemize

\family typewriter
S.highLevelSessionDispatcher
\family default
 - returns a 
\family typewriter
List[LiftRules.DispatchPF]
\end_layout

\begin_layout Itemize

\family typewriter
S.highLevelSessionDispatchList
\family default
 - returns a 
\family typewriter
List[DispatchHolder] 
\end_layout

\begin_layout Itemize

\family typewriter
S.addHighLevelSessionDispatcher 
\family default
- maps a name with a given 
\family typewriter
DispatchPF
\end_layout

\begin_layout Itemize

\family typewriter
S.removeHighLevelSessionDispatcher
\family default
 - removes the 
\family typewriter
DispatchPF
\family default
 given its name
\end_layout

\begin_layout Itemize

\family typewriter
S.clearHighLevelSessionDispatcher
\family default
 - removes all 
\family typewriter
DispatchPF
\family default
 associations
\end_layout

\begin_layout Subsection
Session re-writers
\begin_inset Note Note
status open

\begin_layout Plain Layout
Need an example of usage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Session re-writers are per session functions that allow you to modify a
 HTTP request (URI, query parameters etc.) before the request is actually
 processed.
 This is similar with LiftRules.rewrite variable but you can apply rewriters
 per a given session.
 Hence you can have different rewrites in diferent contexts.
 The relevant functions are:
\end_layout

\begin_layout Itemize

\family typewriter
S.sessionRewriter
\family default
 - returns a
\family typewriter
 List[RewriteHolder]
\end_layout

\begin_layout Itemize

\family typewriter
S.addSessionRewriter
\family default
 - maps a 
\family typewriter
LiftRules.RewritePF 
\family default
with a given name
\end_layout

\begin_layout Itemize

\family typewriter
S.removeSessionRewriter
\family default
 - removes a rewriter by a name
\end_layout

\begin_layout Itemize

\family typewriter
S.clearSessionRewriter
\family default
 - remove all session rewriters.
\end_layout

\begin_layout Subsection
Access to HTTP headers
\end_layout

\begin_layout Standard
Accessing HTTP header parameters from the request and adding HTTP header
 parameters to the HTTP response represent very common operations.
 You can easily perform these operations using the following functions:
\end_layout

\begin_layout Itemize

\family typewriter
S.getHeaders
\family default
 - returns a 
\family typewriter
List[(String, String)] 
\family default
containing all HTTP headers grouped by name and value pair
\end_layout

\begin_layout Itemize

\family typewriter
S.setHeader
\family default
 - sets a HTTP header parameter by specifying the name and value pair
\end_layout

\begin_layout Subsection
Manage the document type
\end_layout

\begin_layout Standard
You can also read and write the XML document type set for the current response.
 You can use the following functions:
\end_layout

\begin_layout Itemize

\family typewriter
S.getDocType
\family default
 - returns the doc type that was set forthe current response
\end_layout

\begin_layout Itemize

\family typewriter
S.setDocType
\family default
 - sets a document type for the curent response object.
\end_layout

\begin_layout Subsection
Other functions 
\end_layout

\begin_layout Itemize
Access to the raw HttpServletRequest and HttpSession if you really need
 it.
\end_layout

\begin_layout Itemize
Managing the function map.
 The function map generates an association between a String and a function.
 This string represents a query parameter that when Lift receives upon a
 HTTP request, it will execute your function.
 Normally these names are auto-generated by Lift but you can also provide
 you own name.
 Please see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lift-Function-Mapping"

\end_inset

 for more details.
\end_layout

\begin_layout Itemize
Managing wrappers - see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Wrapping-Lift's-processing"

\end_inset


\end_layout

\begin_layout Itemize
Managing notices - see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Notices/Warnings/Errors-messages"

\end_inset


\end_layout

\begin_layout Itemize
Managing HTTP redirects - see S.redirectTo functions and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset


\end_layout

\begin_layout Itemize
Using XML attibutes of a snippet - see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Additional-Snippet-Features"

\end_inset


\end_layout

\begin_layout Section
ResourceServer
\begin_inset CommandInset label
LatexCommand label
name "sub:ResourceServer"

\end_inset


\end_layout

\begin_layout Standard
ResourceServer is a Lift component that manages the serving of resources
 like JS, CSS etc.
 Well the web container can do that right? ...
 still container does not serve these resources if they are inside jar files.
 The default URI path for serving such resources is given by
\family typewriter
 LiftRules.resourceServerPath
\family default
 variable which by default it is set to 
\begin_inset Quotes eld
\end_inset

classpath
\begin_inset Quotes erd
\end_inset

.
 The folder location where the resource is looked up inside jar files is
 given by 
\family typewriter
ResourceServer.baseResourceLocation
\family default
 variable which by default it is set to 
\begin_inset Quotes eld
\end_inset

toserve
\begin_inset Quotes erd
\end_inset

.
 Let's assume the following folder structure inside you Lift project:
\end_layout

\begin_layout Standard

\family typewriter
lift-proj/src/main/resources/toserve/css/mystyle.css
\end_layout

\begin_layout Standard
Maven will create the toserver folder in the jar/war file generated.
 Then in your web page you add something like:
\end_layout

\begin_layout Standard

\family typewriter
<link rel="stylesheet" href="/classpath/css/mystyle.css" type="text/css"/>
\end_layout

\begin_layout Standard
Because the first URI part matches with 
\family typewriter
LiftRules.resourceServerPath
\family default
 Lift will tell ResouceServer to load this resource from 'toserve' folder.
 But it will fail.
 There is one thing left to do.
 We need to tell ResouceServer to allow the loading of mystyle.css resource.
 We can do this from Boot by calling:
\end_layout

\begin_layout Standard

\family typewriter
ResourceServer.allow { 
\end_layout

\begin_layout Standard

\family typewriter
case "css" :: _ => true 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
We basically told Lift here to allow any resource found in css folder under
 toserve.
 Note that toserver comes from 
\family typewriter
ResourceServer.baseResourceLocation
\family default
 which can be changed.
\end_layout

\begin_layout Section
HTTP Authentication
\begin_inset CommandInset label
LatexCommand label
name "sub:HTTP-Authentication"

\end_inset


\end_layout

\begin_layout Standard
HTTP authentication is described by RFC 2617 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://www.isi.edu/in-notes/rfc2617.txt"

\end_inset


\end_layout

\end_inset

.
 It describes the means of protecting server resources and allowing access
 only to authorized entities.
 As you may know any J(2)EE web container provides HTTP authentication support
 mostly using JAAS
\begin_inset Foot
status open

\begin_layout Plain Layout
Java Authentication and Authorization Service.
 More informations can be found at 
\begin_inset CommandInset href
LatexCommand href
target "http://java.sun.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html"

\end_inset


\end_layout

\end_inset

 .
 But this appoach is not without caveats.
 For instance if you provide your own LoginModule or CallbackHandler implementat
ion this will not be loaded by the web application classloader but instead
 by the container classloader (..
 at least in tomcat).
 This means that if your code has other dependencies that you can not use
 these dependencies from your web application since web application classloader
 sits below container's classloader in the delegation chain.
 Besides all these using Scala's power the developer experience of protecting
 server resources using HTTP authentication can be simplified a lot.
 Lift supports both basic and digest authentications, Basic is shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Authentication example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => Full(AuthRole(
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpBasicAuthentication("lift") {  
\end_layout

\begin_layout Plain Layout

      case ("John", "12test34", req) => 
\end_layout

\begin_layout Plain Layout

	    println("John is authenticated!")
\end_layout

\begin_layout Plain Layout

	    userRoles(AuthRole(
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

)) 
\end_layout

\begin_layout Plain Layout

	    true    
\end_layout

\begin_layout Plain Layout

    }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we just told Lift that /users path is a protected resource and only
 by users that have the Role admin.
 So here we have both authentication and authorization.
 If this function returns an Empty box it means that this resource is not
 bound to any Role meaning that only authentication will be performed, not
 authorization.
 Secondly using 
\family typewriter
LiftRules.authentication
\family default
 we told Lift that we want BasicAuthentication and of course we are passing
 the function that actually does the authentication.
 This function is actually a PartialFunction[(String, String, Req), Boolean].
 First two members of the tuple are username and password, then the Req
 object.
 In the above example we're basically saying that if user is authenticating
 itself as 
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset

 and password is 
\begin_inset Quotes eld
\end_inset

12test34
\begin_inset Quotes erd
\end_inset

 the access to the protected resource will be granted (since our function
 returns true).
 But in our authentication function we also specify the role for user 
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset

 as being 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

.
 
\family typewriter
userRole
\family default
 is a RequestVar that will be used later on by Lift.
\end_layout

\begin_layout Standard
So at runtime when user tries to access /users Lift knows that this is a
 protected resource and only an admin can access it.
 Therefore Lift is sending down to client a 401 HTTP status (unauthorized
 response).
 User will enter the credentials and if they match with username John and
 password 12test34 we got a successful authentication and because the role
 we set is admin which matches with the role assigned to the protected resource,
 the /users resource is served to client.
 
\end_layout

\begin_layout Standard
A Role is an n-ary tree structure.
 So when we assign a Role to a protectedResource we can actually provide
 an entire tree such as:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/roles.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Roles hierarchy example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assume that your application uses a roles structure as above.
 The Admin is the all mighty role for admins that can do what any sub-role
 can do and more.
 Then we have the Site-Admin that can monitor the application, the User-Admin
 that can manage users, then Romania-Admin that can manage users from Romania,
 US-Admin that can manage users from US and UK-Admin that can only manage
 users from UK.
 Now a User-Admin can manage users from anywhere but a Site-Admin can not
 manage any users.
 Neither a Romania-Admin has the priviledges of User-Admin or Admin, nor
 it can manage the US or UK users.
 You got the picture here; the idea is that the lower a Role is in the hierarchy
 the less priviledged it is.
 Let'see how the code looks like based on the above figure:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Authentication multi-roles example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val roles = AuthRole(
\begin_inset Quotes eld
\end_inset

Admin
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

US-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

UK-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		)
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => roles.getRoleByName(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpBasicAuthentication("lift") {  
\end_layout

\begin_layout Plain Layout

      case ("John", "12test34", req) => 
\end_layout

\begin_layout Plain Layout

	    println("John is authenticated !")
\end_layout

\begin_layout Plain Layout

	    userRoles(AuthRole("User-Admin")) 
\end_layout

\begin_layout Plain Layout

	    true    
\end_layout

\begin_layout Plain Layout

    }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case if user is authenticated, authorization will also succeed because
 the user's Role is User-Admin and it is a parent of 
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

.
 If the /users resource would have been assigned with 
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

 role and user John would have 
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

 role that even if credentials are correct the authorization fails hence
 a 401 HTTP status is still sent to client.
\end_layout

\begin_layout Standard
In conclusion you have a simple authentication and authorization mechanism
 and of course authentication function would typically validate the credentials
 against a database and fetch the roles from there.
\end_layout

\begin_layout Subsubsection
HTTP Digest Authentication
\end_layout

\begin_layout Standard
So far we talked about basic authentication and authorization.
 Lift also support HTTP Digest authentication.
 This means that the password information that user enters in the browser
 is never propagated on the server.
 Here is how we use it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Digest Authentication multi-roles example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val roles = AuthRole(
\begin_inset Quotes eld
\end_inset

Admin
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

US-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

UK-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		)
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => roles.getRoleByName(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpDigestAuthentication("lift") {
\end_layout

\begin_layout Plain Layout

      case ("John", req, func) => if (func("12test34")) {
\end_layout

\begin_layout Plain Layout

        println("John is authenticated !")
\end_layout

\begin_layout Plain Layout

        userRoles(AuthRole("useradmin"))
\end_layout

\begin_layout Plain Layout

        true
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        println("Not verified")
\end_layout

\begin_layout Plain Layout

        false
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eveything we talked about Roles is still valid.
 However we're now using digest authentication.
 Note that in this case we're not provided with a password anymore but our
 function is provided with the user name, the Req object and a callback
 function.
 Because digest authentication implies checksum calculations there is no
 need to burden the user with such things.
 However our code calls this callback function by providing the password
 (which can be retrieved from database as we know the user name).
 If this function returns true it means that the digest that client sent
 andthe one that Lift calculated matches so we have a successful authentication.
 
\end_layout

\begin_layout Standard
There is also important to know that diget authentication mechanism uses
 a nonce sequence.
 This sequence is generated by the server when sending down the authentication
 challenge down to client (401 HTTP status).
 In order to avoid replay attacks this nonce is valid only for a period
 of time.
 By default this is set to 30 seconds but you can change this by setting:
\end_layout

\begin_layout Standard

\family typewriter
HttpDigestAuthentication.nonceValidityPeriod = <a value in milliseconds>
\end_layout

\begin_layout Standard
If you use Lift's TimeHelpers you can say:
\end_layout

\begin_layout Standard

\family typewriter
HttpDigestAuthentication.nonceValidityPeriod = 50 seconds 
\end_layout

\begin_layout Standard

\family typewriter
// where seconds is a function and there are implicit conversion functions
 from 
\begin_inset Quotes eld
\end_inset

primitives
\begin_inset Quotes erd
\end_inset

 to TimeSpans type.
\end_layout

\begin_layout Standard
If this period expires even if the authentication and authorization succeed
 Lift will challenge it again by returning 401 HTTP status and a new nonce.
 So the resource is not served yet.
\end_layout

\begin_layout Standard
It is important to know that a user can be assigned with multiple roles,
 not just one.
 This can be done by calling:
\end_layout

\begin_layout Standard

\family typewriter
userRoles(AuthRole("US-Admin", 
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

)) // AuthRole overloaded apply function takes a repeated parameter.
\end_layout

\begin_layout Standard
This is pretty much it as far as HTTP authentication and authorization goes
 but there is one more thing that is worth to be mentioned.
 If your application does not persist the user's password and only a digest
 internally calculated, the HTTP digest authentication can not really be
 used.
 The reason is that in order to match the client's digest, server needs
 to calculate it and for that it needs the password in clear but because
 the application stores a digest, the user's password can not be recovered.
 Hence the HTTP digest can not be calculated.
 This is a missmatch betwen the two concepts: HTTP digest authentication
 given by RFC 2617 and the unrecoverable password storage.
\end_layout

\end_body
\end_document
