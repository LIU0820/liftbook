#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Architecture and Advanced Topics
\begin_inset CommandInset label
LatexCommand label
name "cha:Advanced-Lift-Guts"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
This chapter is still under active development.
 The contents will change.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Congratulations! You've made it through the introduction to Lift.
 Or maybe you've skipped Basics and jumped right to here to Advanced, either
 way, the next section will be exciting.
 
\end_layout

\begin_layout Standard
In this chapter we're going to dive into some of the advanced mechanics
 and features of Lift so that you have a thorough understanding of what's
 going on.
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Standard
The diagram above highlights the main Lift components and where they live
 in the ecosystem.
 Scala compiles down to Java bytecode, so we sit on top of the JVM.
 Lift Applications are typically run in a J(2)EE web container, such as
 Jetty or Tomcat.
 As we explained in the introduction, Lift is set up to act as a Filter
 component (REF) and this acts as the entry point.
 The rest of the component layout varies from application to application,
 and how you've implemented your Snippets and Templates amongst other things.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/LiftArchDiagram.pdf
	BoundingBox 0bp 5.75in 5in 792bp
	clip

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture-diagram"

\end_inset

 we've broken Lift up into it's major components, which are described below:
\end_layout

\begin_layout Description
SiteMap Contains the web pages for a Lift application.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap"

\end_inset


\end_layout

\begin_layout Description
LiftRules Allows you to configure Lift REF
\end_layout

\begin_layout Description
LiftSession The session state representation REF
\end_layout

\begin_layout Description
S The stateful object impersonating the state context for a given request/respon
se lifecycle REF
\end_layout

\begin_layout Description
SHtml Contains helper functions for XHtml artifacts (form fields, links,
 Ajax links, buttons, etc.) REF
\end_layout

\begin_layout Description
Views LiftView objects impersonating a view as a XML content.
 Thus pages can be composed from other sources not only from html files.
 REF
\end_layout

\begin_layout Description
LiftResponse Represents the abstraction of a response that will be propagated
 to the client.
 REF
\end_layout

\begin_layout Description
LiftCore The engine of the framework responsible for request/response lifecycle,
 rendering pipeline, invoking user's functions etc.
 REF
\end_layout

\begin_layout Description
Comet Represents the Comet Actors layer.
 As you already know, comet actors are capable of sending asynchronous content
 to the browser.
 REF
\end_layout

\begin_layout Description
ORM - Either Mapper or Record - The lightweight ORM library proposed by
 Lift.
 Mapper framework is the proposed ORM framework for Lift 1.0 and Record framework
 will be for next releases.
 REF
\end_layout

\begin_layout Description
HTTP Auth - You can use HTTP authentication (Basic and Digest models) in
 your lift application.
 This provides you more control as opposed to web-container's HTTP authenticatio
n model.
 REF
\end_layout

\begin_layout Description
JS
\series bold
-
\series default
API The JavaScript abstraction layer.
 These are Scala classes/objects that abstract JavaScript artifacts.
 Such objects can be combined to build JavaScript code.
 REF
\end_layout

\begin_layout Description
Utils contains a lot of helper functions that Lift uses internally that
 are also available to your application.
 REF
\end_layout

\begin_layout Subsection
The Request/Response Lifecycle
\begin_inset CommandInset label
LatexCommand label
name "sec:Request/Response-Lifecycle"

\end_inset


\end_layout

\begin_layout Standard
We would like to revisit the rendering pipeling that takes a Request and
 generates a Response.
 We briefly touched on this back in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-Rendering-Process"

\end_inset

, ??but before we get into all of the nitty gritty details we're going to
 cover it in depth.
 This will serve not only to familiarize you with the full processing power
 of Lift, but also to introduce some of the other advanced topics we'll
 be discussing in this and later chapters.
 One important thing we'd like to mention is that most of the configurable
 properties are in LiftRules, and are of the type RulesSeq.
 With a RulesSeq you essentially have a list of functions or values that
 are applied in order.
 RulesSeq defines a prepend and append method that allows you to add new
 configuration items at the beginning or end of the configuration, respectively.
 This allows you to prioritize things like partial functions and compose
 various methods together to control Lift's behavior.
 You can think of a RulesSeq as a Seq on steroids, tweaked for Lift's usage.
\end_layout

\begin_layout Standard
The following list outlines, in order, the process of transforming a Request
 into a Response.
 We provide references to the sections of the book where we discuss each
 step in case you want to branch off.
\end_layout

\begin_layout Enumerate
Execute early functions: this is a mechanism that allows a user function
 to be called before the request enters the normal processing chain.
 This can be used for, for example, to set the XHTML output to UTF-8.
 This is controlled through 
\family typewriter
LiftRules.early
\end_layout

\begin_layout Enumerate
Perform URL Rewriting, which we cover in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:URL-Rewriting"

\end_inset

.
 Controlled via 
\family typewriter
LiftRules.rewrite
\family default
, this is useful for creating user-friendly URLs, among other things.
 The result of the transformation will be checked for possible rewrites
 until there are no more matches or it is explicitly stopped
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftRules.onBeginServicing
\family default
 hooks.
 This is a mechanism that allows you to add your own hook functions that
 will be called when Lift is starting to process the request.
 You could set up logging here.
\end_layout

\begin_layout Enumerate
Check for user-defined stateless dispatch in 
\family typewriter
LiftRules.statelessDispatchTable
\family default
.
 If the partial functions defined in this table match the request then they
 are used to create a 
\family typewriter
LiftResponse
\family default
 that is sent to the user, bypassing any further processing.
 These are very useful for building things like REST APIs.
 The term stateless refers to the fact that at the time the dispatch function
 is called, the stateful object, called 
\family typewriter
S
\family default
, is not available and the 
\family typewriter
LiftSession
\family default
 is not created yet.
\end_layout

\begin_layout Enumerate
Create a 
\family typewriter
LiftSession
\family default
.
 The 
\family typewriter
LiftSession
\family default
 holds various bits of state for the request, and is covered in more detail
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-Management"

\end_inset

.
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onSetupSession
\family default
.
 This is a mechanism for adding hook functions that will be called when
 the LiftSession is created.
 We'll get into more details when we discuss Lift's session management in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Session-Management"

\end_inset

.
\end_layout

\begin_layout Enumerate
Initialize the 
\family typewriter
S
\family default
 object (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:S-object"

\end_inset

).
 The 
\family typewriter
S
\family default
 object represents the current state of the Request and Response.
\end_layout

\begin_layout Enumerate
Call any 
\family typewriter
LoanWrapper
\family default
 instances that you've added through 
\family typewriter
S.addAround
\family default
.
 A 
\family typewriter
LoanWrapper
\family default
 is a way to insert your own processing into the render pipeline, similar
 to how Filter works in the Servlet API.
 This means that when your 
\family typewriter
LoanWrapper
\family default
 implementation is called, Lift passes you a function allowing you to chain
 the processing of the request.
 With this functionality you can execute your own pre- and post-condition
 code.
 A simple example of this would be if you need to make sure that something
 is configured at the start of processing and cleanly shut down when processing
 terminates.
\end_layout

\begin_layout Enumerate
Process the stateful request
\end_layout

\begin_deeper
\begin_layout Enumerate
Check the stateful dispatch functions defined in 
\family typewriter
LiftRules.dispatch
\family default
.
 This is similar to the stateless dispatch in step #4 except that these
 functions are executed in the context of a LiftSession and an 
\family typewriter
S
\family default
 object (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:S-object"

\end_inset

).
 The first matching partial function is used to generate a 
\family typewriter
LiftResponse
\family default
 that is returned to the client.
 If none of the dispatch functions match then processing continues.
 Dispatch functions are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Custom-dispatch-func"

\end_inset

.
 This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls
\end_layout

\begin_layout Enumerate
If this is a 
\series bold
Comet
\series default
 request, then process it and return the response.
 Comet is a method for performing asynchronous updates of the user's page
 without a reload.
 We cover Comet techniques in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset


\end_layout

\begin_layout Enumerate
If this is an 
\series bold
Ajax
\series default
 request, execute the user's callback function; the specific function is
 mapped via a request parameter (essentially a token).
 The result of the callback is returned as the response to the user.
 The response can be a JavaScript snippet, an XML construct or virtually
 any 
\family typewriter
LiftResponse
\family default
.
 For an overview of 
\family typewriter
LiftResponse
\family default
 please see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftResponse-in-Detail"

\end_inset

.
 This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls.
\end_layout

\begin_layout Enumerate
If this is a regular HTTP request, then:
\end_layout

\begin_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onBeginServicing
\family default
 hooks.
 Mostly 
\begin_inset Quotes eld
\end_inset

onBegin
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

onEnd
\begin_inset Quotes erd
\end_inset

 functions are used for logging.
 Note that LiftRules also have onBeginServicing and onEndServicing functions
 but theae are 
\begin_inset Quotes eld
\end_inset

wrapping
\begin_inset Quotes erd
\end_inset

 more Lift processing not only statefull processing.
\end_layout

\begin_layout Enumerate
Check the user-defined dispatch functions that are set per-session (
\family typewriter
see S.addHighLevelSessionDispatcher
\family default
).
 This is similar to 
\family typewriter
LiftRules.dispatch
\family default
 except that you can have different functions set up for a different session
 depending on your application logic.
 If there is a function applicable, execute it and return its response.
 If there is no per-session dispatch function, process the request by executing
 the Scala function that user set up for specific events (such as when clicking
 a link, or pressing the submit button, or a function that will be executed
 when a form field is set etc.).
 Please see SHtml obejct 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SHtml"

\end_inset

.
\end_layout

\begin_layout Enumerate
Check the SiteMap and Loc functions.
 We cover SiteMap extensively in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:SiteMap-1"

\end_inset

.
\end_layout

\begin_layout Enumerate
Lookup the template based on the Req?? path.
 Lift will locate the templates using various approaches:
\end_layout

\begin_deeper
\begin_layout Enumerate
Check the partial functions defined in 
\family typewriter
LiftRules.viewDispatch
\family default
.
 If there is a function defined for this path invoke it and return an Either[
\begin_inset Formula $()\Rightarrow Can[NodeSeq]$
\end_inset

,LiftView].
 This allows you to either return the function for handling the view directly,
 or delegate to a LiftView subclass.
 LiftView is covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Views"

\end_inset


\end_layout

\begin_layout Enumerate
If no viewDispatch functions match, then look for the template using the
 ServletContext's 
\family typewriter
getResourceAsStream
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Process the templates by executing snippets combining templates etc.
\end_layout

\begin_deeper
\begin_layout Enumerate
Merge <head> elements, as described in section e
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Head-Merge"

\end_inset


\end_layout

\begin_layout Enumerate
Update the internal functions map.
 Basically this associates the user's Scala functions with tokens that are
 passed around in subsequent requests using HTTP query parameters??
\end_layout

\begin_layout Enumerate
Clean up notices (see S.error, S.warning, S.notice) since they were already
 rendered they are no longer needed.
 Notices are covered in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Message-Handling"

\end_inset

.
\end_layout

\begin_layout Enumerate
Call 
\family typewriter
LiftRules.convertResponse
\family default
.
 Basically this glues together different pieces if information such as the
 actual markup, the response headers, cookies, etc into a LiftResponse instance.
\end_layout

\begin_layout Enumerate
Check to see if Lift needs to send HTTP redirect.
 For an overview please see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HTTP-redirects"

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftSession.onEndServicing
\family default
 hooks, the counterparts to 
\family typewriter
LiftSession.onBeginServicing
\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftRules.performTransform
\family default
.
 This is actually configured via the 
\family typewriter
LiftRules.responseTransformers
\family default
 
\family typewriter
RulesSeq
\family default
.
 This is a list of functions on 
\begin_inset Formula $LiftResponse\Rightarrow LiftResponse$
\end_inset

 that allows the user to modify the response before it's sent to the client
\end_layout

\end_deeper
\begin_layout Enumerate
Call 
\family typewriter
LiftRules.onEndServicing
\family default
 hooks.
 These are the stateless end-servicing hooks, called after the S object
 context is destroyed.
\end_layout

\begin_layout Enumerate
Call any functions defined in 
\family typewriter
LiftRules.beforeSend
\family default
.
 This is the last place where you can modify the response before it's sent
 to the user
\end_layout

\begin_layout Enumerate
Convert the 
\family typewriter
LiftResponse
\family default
 to a raw byte stream and send it to client as an HTTP response.
\end_layout

\begin_layout Enumerate
Call any functions defined in 
\family typewriter
LiftRules.afterSend
\family default
.
 Typically these would be used for cleanup.
\end_layout

\begin_layout Standard
We realize that this is a lot of information to digest in one pass, so as
 we continue to cover the specific details of the rendering pipeline you
 may want to keep a bookmark here so that you can come back and process
 the new information in the greater context of how Lift is working.
\end_layout

\begin_layout Subsection
LiftResponse in Detail
\begin_inset CommandInset label
LatexCommand label
name "sec:LiftResponse-in-Detail"

\end_inset


\end_layout

\begin_layout Standard
The Lift framework makes a lot of things really easy and it provides extremly
 useful abstractions as you may have already discovered.
 Responses to clients are also abstacted by 
\family typewriter
LiftResponse
\family default
 trait.
 There are numerous response types and here is the simplified view of the
 class hierarchy:
\end_layout

\begin_layout Itemize
LiftResponse
\end_layout

\begin_deeper
\begin_layout Itemize
BasicResponse
\end_layout

\begin_deeper
\begin_layout Itemize
InMemoryResponse
\end_layout

\begin_layout Itemize
StreamingResponse
\end_layout

\end_deeper
\begin_layout Itemize
JSonResponse
\end_layout

\begin_layout Itemize
RedirectResponse
\end_layout

\begin_deeper
\begin_layout Itemize
RedirectWithState
\end_layout

\end_deeper
\begin_layout Itemize
ToResponse
\end_layout

\begin_deeper
\begin_layout Itemize
XhtmlRespomse
\end_layout

\begin_layout Itemize
XmlResponse
\end_layout

\begin_layout Itemize
XmlMimeResponse
\end_layout

\begin_layout Itemize
AtomResponse
\end_layout

\begin_layout Itemize
OpenSearchResponse
\end_layout

\begin_layout Itemize
AtomCreatedResponse
\end_layout

\begin_layout Itemize
AtomCategoryResponse
\end_layout

\begin_layout Itemize
AtomServiceResponse
\end_layout

\begin_layout Itemize
CreatedResponse
\end_layout

\end_deeper
\begin_layout Itemize
OkResponse
\end_layout

\begin_layout Itemize
PermRedirectResponse
\end_layout

\begin_layout Itemize
BadResponse
\end_layout

\begin_layout Itemize
UnauthorizedResponse
\end_layout

\begin_layout Itemize
UnauthorizedDigestResponse
\end_layout

\begin_layout Itemize
NotFoundResponse
\end_layout

\begin_layout Itemize
MethodNotAllowedResponse
\end_layout

\begin_layout Itemize
GoneResponse
\end_layout

\end_deeper
\begin_layout Standard
We won't get into details right now on what exactly each and every class/object
 does, although their purpose is given away by their names.
 It is important to know that whenever you need to return a 
\family typewriter
LiftResponse
\family default
 reference from one of your functions, for example 
\family typewriter
LiftRules.dispatch
\family default
 you can you can use one of these classes.
 Lift doesn't really provide the HttpServletResponse object, instead all
 responses are impersonated by a 
\family typewriter
LiftResponse
\family default
 instance and it content (the actual payload, http headers, content-type,
 cookies etc.) is written internally by Lift to the container's output stream.
\end_layout

\begin_layout Subsection
Session Management 
\begin_inset CommandInset label
LatexCommand label
name "sec:Session-Management"

\end_inset


\end_layout

\begin_layout Standard
Lift is a stateful framework and naturally this state needs to be managed.
 You may already be familiar with HttpSession and and how a J(2)EE web container
 identifies an HttpSession; either by a JSESSIONID cookie or by a JSESSIONID
 URI sequence (in case of URL rewriting).
 Similarly, Lift uses a LiftSession reference which is not actually 
\begin_inset Quotes eld
\end_inset

persisted
\begin_inset Quotes erd
\end_inset

 in HttpSession.
 As a matter of fact Lift does not really use the HttpSession provided by
 the web container to maintain conversational state, but rather uses a bridge
 between the 
\family typewriter
HttpSession
\family default
 and the 
\family typewriter
LiftSession
\family default
.
 This bridge is impersonated by 
\family typewriter
SessionToServletBridge
\family default
 class which implements 
\emph on
javax.servlet.http.HttpSessionBindingListener
\emph default
 and 
\emph on
javax.servlet.http.HttpSessionActivationListener
\emph default
 and works like this:
\end_layout

\begin_layout Enumerate
When receiving an HTTP Request and there was no stateless dispatch function
 to execute, Lift does the stateful processing.
 But before doing that it checks to see if there is a 
\family typewriter
LiftSession
\family default
 associated with this HTTP session ID.
 This mapping is kept on a SessionMaster Scala actor.
 
\end_layout

\begin_layout Enumerate
If there is no associated LiftSession in the SessionMaster actor, create
 it and add a SessionToServletBridge attribute on HttpSession.
 This will make Lift aware of the session when the container terminates
 the HttpSession or when the HTTP session is about to be passivated or activated.
\end_layout

\begin_layout Enumerate
When the container terminates the HTTP session, SessionToServletBridge sends
 a message to the SessionMaster Actor to terminate the LiftSession, which
 includes the following steps:
\end_layout

\begin_deeper
\begin_layout Enumerate
Call any defined LiftSession.onAboutToShutdownSession hooks
\end_layout

\begin_layout Enumerate
Send a ShutDown message to all Comet Actors pertaining to this session
\end_layout

\begin_layout Enumerate
Clean up any internal LiftSession state
\end_layout

\begin_layout Enumerate
Call LiftSession.onShutdownSession hooks
\end_layout

\end_deeper
\begin_layout Standard
The SessionMaster Actor is also protected by another watcher Actor.
 This watcher Actor receives the Exit messages of the watched Actors.
 When it receives an Exit message it will call the users' failure functions
 and restart the watched actor (Please see ActorWatcher.failureFuncs).
 
\end_layout

\begin_layout Standard
Even while Lift is handling session management you still have the ability
 to manually add attributes to the HttpSession object.
 We do not recommend this unless you really must.
 A simpler way to keep your own session variables, is to use 
\family typewriter
SessionVar
\family default
s.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
SessionVar example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

object count extends SessionVar(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// later in your code you can increment the count by calling
\end_layout

\begin_layout Plain Layout

count(count + 1)
\end_layout

\begin_layout Plain Layout

// or obtain the value
\end_layout

\begin_layout Plain Layout

var theCountValue: Int = count
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
SessionVar
\family default
s are typesafe representation of HTTP session attributes (they are kept
 in LiftSession and not directly in HttpSession).
 There are implicit conversion utility functions to convert a 
\family typewriter
SessionVar
\family default
 to its underlying type.
\end_layout

\begin_layout Standard
??The next question would be 
\begin_inset Quotes eld
\end_inset

So we have internal session management, how do we cope with that in a clustered
 environment? ...
 how are sessions replicated?
\begin_inset Quotes erd
\end_inset

 the answer is, they aren't.
 There is no intention to use the web container's session replication as
 these technologies appears to be inferior to other solutions on the market.
 Relying on Java serialization brings a lot of performance concerns and
 alternative technologies have been investigated and they are still under
 investigation.
 Until there is a standard session replication technology you can still
 cluster you application using 
\begin_inset Quotes eld
\end_inset

sticky session
\begin_inset Quotes erd
\end_inset

.
 This meas that all requests pertaining to a HTTP session must be processed
 by the same cluster node.
 This can be done by software or hardware load balancers, as they would
 dispatch the requests based on JSESSIONID cookie.
 Another approache is that the dispatching is done based on some URI or
 query parameters.
 For example, a query parameter like serverid=1 is configured in the load
 balancer to always be dispatched to the node 1 of the cluster, and so on.
 There are some downsides for the sticky session approach.
 For instance you are logged in the application and do your stuff.
 Suddenly the node designated to your session crashes.
 At this moment essentially you lost your session.
 The next subsequent request would be automatically dispatched by the load
 balancer to another cluster node and depending how your application is
 built this may mean that you need to log in again or if part of the state
 was persisted in DB you may resume your work from some point avoiding re-login
 ...
 but this is application specific behavior that is beyond the scope of this
 discussion.
 The advantages of sticky sessions are related with application performance
 since in this model the state does not need to be replicated in all cluster
 nodes which for significant state information can be quite time/resources
 consuming.
\end_layout

\begin_layout Section
Miscellaneous Lift Features
\end_layout

\begin_layout Standard
In this section we will discuss various features that can prove helpful
 in building rich Lift applications.
\end_layout

\begin_layout Subsection
Wrapping Lift's processing logic
\begin_inset CommandInset label
LatexCommand label
name "sub:Wrapping-Lift's-processing"

\end_inset


\end_layout

\begin_layout Standard
Lift provides the ability to allow user functions to be part of processing
 lifecycle.
 In these cases Lift allows you to provide your own functions and the actual
 Lift's processing function is passed to you??.
 This means that calling Lift's logic is your responsability.
 to call the function provided by Lift and of course you can have code before
 and after calling Lift's function.
\end_layout

\begin_layout Standard
But let's see how exactly you can do this and we do that by starting with
 a code snippet:??????
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
LoanWrapper example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 class Boot {   
\end_layout

\begin_layout Plain Layout

  def boot {    
\end_layout

\begin_layout Plain Layout

    ...
   
\end_layout

\begin_layout Plain Layout

    S.addAround(new LoanWrapper { // Y   
\end_layout

\begin_layout Plain Layout

      def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

        println("Y -> hello to the request!")  
\end_layout

\begin_layout Plain Layout

        val result = f // Let Lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

		println("Y -> goodbye!")  
\end_layout

\begin_layout Plain Layout

        result   
\end_layout

\begin_layout Plain Layout

      }   
\end_layout

\begin_layout Plain Layout

    })   
\end_layout

\begin_layout Plain Layout

    S.addAround(new LoanWrapper { // X   
\end_layout

\begin_layout Plain Layout

      def apply[T](f: => T): T = {   
\end_layout

\begin_layout Plain Layout

        println("X -> hello to the request!")   
\end_layout

\begin_layout Plain Layout

        val result = f // Let Lift do normal request processing.
   
\end_layout

\begin_layout Plain Layout

        println("X -> goodbye!")   
\end_layout

\begin_layout Plain Layout

        result
\end_layout

\begin_layout Plain Layout

      }   
\end_layout

\begin_layout Plain Layout

    })   
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code looks pretty straight-forward in the sense that we add two 
\family typewriter
LoanWrapper
\family default
 instances to the 
\family typewriter
S
\family default
 object.
 (Note that we're using the 
\family typewriter
S
\family default
 object not 
\family typewriter
LiftRules
\family default
 meaning that 
\family typewriter
LoanWrapper
\family default
s are applicable only for stateful processing.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

 for when exactly 
\family typewriter
LoanWrapper
\family default
s are invoked.) 
\end_layout

\begin_layout Standard
So let's see what happens when the above code processess a request from
 a client.
 You can think of the invocation sequence as 
\family typewriter
X(Y(f))
\family default
 where f is the Lift function that impersonates the core processing.
 Therefore you'll see the following output in the console:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

X -> hello to the request!
\end_layout

\begin_layout Plain Layout

Y -> hello to the request!
\end_layout

\begin_layout Plain Layout

<Lift's logic ...
 whatever is printed here>
\end_layout

\begin_layout Plain Layout

Y -> goodbye!
\end_layout

\begin_layout Plain Layout

X -> goodbye!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This feature allows you use a resource before Lift does and release them
 after Lift has finished processing the stateful request and before the
 LiftResponse object is constructed.
\end_layout

\begin_layout Subsection
More on snippets
\end_layout

\begin_layout Standard
By now you already have a fairly good idea how snippets work, how you can
 use them etc.
 There are a few things that were not revealed yet to you, such as:
\end_layout

\begin_layout Enumerate
Ability to pass parameters to snippets:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet attributes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:Ledger.balance default=
\begin_inset Quotes erd
\end_inset

10
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout Plain Layout

  <ledger:balance/> as of <ledger:time />
\end_layout

\begin_layout Plain Layout

</lift:Ledger.balance>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How do we read the 
\emph on
default
\emph default
 attribute from the snippet code? Actualy it is only about calling S.attr
 function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Snippet attributes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Ledger {
\end_layout

\begin_layout Plain Layout

  def balance (content : NodeSeq ) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

	val dflt = S.attr(
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

) openOr 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

    bind (
\begin_inset Quotes eld
\end_inset

ledger
\begin_inset Quotes erd
\end_inset

, content,
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

balance
\begin_inset Quotes erd
\end_inset

 -> Text(currentLegdger.formattedBalance),
\end_layout

\begin_layout Plain Layout

          
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 -> Text((new java.util.Date).toString))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Use snippets for tag attributes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Attribute Snippet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// In your page you can have
\end_layout

\begin_layout Plain Layout

<div lift:snippet="MyDivThing:calcDir"> ...
 </div>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

// Your snippet
\end_layout

\begin_layout Plain Layout

class MyDivThing {   
\end_layout

\begin_layout Plain Layout

  def calcDir = new UnprefixedAttribute("dir", "rtl", Null)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The utility of this support is quite obvious in so many situations.
 For instance when supporting right-to-left languages you can add the direction
 of the page to be rtl quite easily.
\end_layout

\end_deeper
\begin_layout Subsection
S Object
\end_layout

\begin_layout Standard
The 
\family typewriter
S
\family default
 or Stateful, object is a very important part of Lift.
 The S context is created when a client request is recieved that needs to
 be handled as a stateful reuest.
 Please see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request/Response-Lifecycle"

\end_inset

.
 The way the state is managed in Lift is interesting in that the processing
 logic is impersonated by a closure that is passed to the 
\family typewriter
S
\family default
 object.
 The 
\family typewriter
S
\family default
 object then gets initialized, the closure is executed and then state is
 cleaned up.
 The 
\family typewriter
S
\family default
 context is maintained for a request/response lifecycle.
 The actual state information is kept inside S object using ThreadLocal
 variables since 
\family typewriter
S
\family default
 is a singleton.
 This means that if you have any code that is executed in the stateful context
 you can safely use any 
\family typewriter
S
\family default
 object goodies, which include:
\end_layout

\begin_layout Itemize
Managing cookies
\end_layout

\begin_layout Itemize
Localization ...
 see S.? functions.
 The resource-bundle name is given by LiftRules.resourceName variable.
\end_layout

\begin_layout Itemize
Managing the Locale ...
 see S.locale function.
 The locale is given by LiftRules.localeCalculator variable which you can
 use to provide your own logic
\end_layout

\begin_layout Itemize
Managing the Timezone ...
 see S.timeZone function.
 The timezone is given by LiftRules.timeZoneCalculator variable which you
 can use to provide your own logic.
\end_layout

\begin_layout Itemize
Per-session DispatchPF functions ..
 see S.highLevelSessionDispatcher function.
\end_layout

\begin_layout Itemize
Session re-writers.
 There are per session functions that allows to modify a HTTP request (URI,
 query parameters etc.) before the request is actually processed.
\end_layout

\begin_layout Itemize
Access to the raw HttpServletRequest and HttpSession if you really need
 it.
\end_layout

\begin_layout Itemize
Managing notices ...
 see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Notices/Warnings/Errors-messages"

\end_inset


\end_layout

\begin_layout Itemize
Managing HTTP redirects ...
 see S.redirectTo functions.
\end_layout

\begin_layout Itemize
Managing wrappers ...
 see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Wrapping-Lift's-processing"

\end_inset


\end_layout

\begin_layout Itemize
Access to HTTP headers (get/set)
\end_layout

\begin_layout Itemize
Set document type for a particular response ...
 see S.setDocType
\end_layout

\begin_layout Itemize
Using XML attibutes of a snippet ..
 see S.attr
\end_layout

\begin_layout Itemize
Managing LiftSession parameters (we recommend using SessionVar due to its
 typesafe nature)
\end_layout

\begin_layout Itemize
Managing the function map.
 The function map generates an association between a String and a function.
 This string represents a query parameter that when Lift receives upon a
 HTTP request, it will execute your function.
 Normally these names are auto-generated by Lift.
 See S.mapFunc function.??? Reword
\end_layout

\begin_layout Subsubsection
Notices/Warnings/Errors messages
\begin_inset CommandInset label
LatexCommand label
name "sub:Notices/Warnings/Errors-messages"

\end_inset


\end_layout

\begin_layout Standard
Feedback for the user is required for modern applications, error messages
 for issues, status messages for update and general notifications.
 Lift provides a unified model for such messages that can be used for static
 pages as well as for Ajax and Comet calls.
 The S object provides three functions S.notice, S.warning, S.error.
 So we have a classification of messages where notices are just informative
 messages, warnings are advisory message letting the user know that the
 action is risky or may induce errors and error messages when we have an
 error conditions.
 How you use the different messages is up to you.
\end_layout

\begin_layout Standard
Here's a simple example to send a 
\family typewriter
notice
\family default
 message.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
S.notice example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class MySnippet {
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def doSomething() {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	S.notice(
\begin_inset Quotes eld
\end_inset

There are no records to render
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In your template you would use this Lift Tag: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
msgs tag
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:msgs>
\end_layout

\begin_layout Plain Layout

  <lift:notice_msg>Note</lift:notice_msg>
\end_layout

\begin_layout Plain Layout

  <lift:notice_class>noticeBox</lift:notice_class>
\end_layout

\begin_layout Plain Layout

</lift:msgs>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
<lift:msgs>
\family default
 tag is one of the built-in snippets and it will render all messages (notice/war
ning/error) by default.
 We have provided additional information in this case specifically for for
 notices.
 
\family typewriter
<lift:notice_msg>
\family default
 specifies the label of the message and 
\family typewriter
<lift:notice_class>
\family default
 the CSS class to be used.
 You can then style your message by wrapping this snippet by a div that
 has a certain ID.
\end_layout

\begin_layout Standard
Besides this there is another Lift buil in snippet call msg.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
msg tag
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:msg id="myNotice" noticeClass=
\begin_inset Quotes erd
\end_inset

noticeBox
\begin_inset Quotes erd
\end_inset

/>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will render only messages that are associate with 
\emph on
myNotice
\emph default
 ID.
 To do this in the 
\emph on
doSomething 
\emph default
function above we just call 
\end_layout

\begin_layout Standard

\family typewriter
S.notice(
\begin_inset Quotes eld
\end_inset

myNotice
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

There are no records to render
\begin_inset Quotes erd
\end_inset

).

\family default
 This snippet provides three attributes 
\emph on
noticeClass
\emph default
, 
\emph on
warningClass
\emph default
 and 
\emph on
errorClass 
\emph default
allowing the possibility to specify your own CSS classes.
 Again you can style you message using IDs in the CSS file as well.
 This snippet is very usefull when you want to render error messages for
 examples in different parts of the page such as near by a form field.
\end_layout

\begin_layout Standard
Now we've seen how we can use the notices for static pages and how they
 get rendered.
 But what about Ajax calls? ...
 for instance we're in an Ajax function and we want to return an error message.
 The answer is that you do not need to do anything special.
 Just use the same S.notice/warning/error functions and Lift will take care
 of the rest.
 For instance assume that in your page youhave <lift:msg> and <lift:msgs>
 snippets.
 When these snippets are processed the meta-information (title for msgs
 and style attributes) is captured by Lift and kept on the LiftSession.
 Later on, (being in the same page) notices propagated via Ajax responses
 will preserve the same styling information that yu used for the snippets.
 This makes the the notices API to be unified regardles if we're using 
\begin_inset Quotes eld
\end_inset

static
\begin_inset Quotes erd
\end_inset

 pages, asynchronous Ajax calls or push messages from server to client using
 Comet actors.
\end_layout

\begin_layout Standard
There is one thing left ...
 how do we use notices from a CometActor? ...
 well pretty much in the same way but we do not use the S object since CometActo
rs are asynchronous components and they exists beyon the request/response
 lifecycle.
 However the same functions notice/warning/error exist in the CometActor
 class, so being in a Comet actor isntead of calling 
\family typewriter
S.notice(
\begin_inset Quotes eld
\end_inset

myNotice
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

There are no records to render
\begin_inset Quotes erd
\end_inset

)
\family default
you just call
\family typewriter
 notice(
\begin_inset Quotes eld
\end_inset

myNotice
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

There are no records to render
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection
SHtml object
\end_layout

\begin_layout Standard
SHtml is derived from S object and it used to be only S.
 However SHtml contains only functions that helps us constuct HTML 
\begin_inset Quotes eld
\end_inset

primitives
\begin_inset Quotes erd
\end_inset

 (input element, select, links, buttons etc.).
 But it is not only about constructing these primitives but allowing user
 to pass functions that will process this field when a requst is made on
 server side.
 For example let's see how we build an ajax button:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ajax Button example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import SHtml._
\end_layout

\begin_layout Plain Layout

import JE._
\end_layout

\begin_layout Plain Layout

import JsCmds._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Assume your snippet function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def myFunc(html: Group) : NodeSeq = {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  bind("hello", html, 
\begin_inset Quotes eld
\end_inset

button" -> ajaxButton(Text(
\begin_inset Quotes eld
\end_inset

Press me
\begin_inset Quotes erd
\end_inset

), {() => 
\end_layout

\begin_layout Plain Layout

	println(
\begin_inset Quotes eld
\end_inset

Got an Ajax call
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

	SetHtml("my-div", Text(
\begin_inset Quotes eld
\end_inset

That's it
\begin_inset Quotes erd
\end_inset

)) 
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
You are already used to snippets and binding so we won't reiterate them
 now.
 But the interersting part here is that <hello:button> tag willbe replaced
 by the output of ajaxButton function which is a <button ...>Press me</button>
 tag.
 But more then that Lift adds the onclick attribute for us and adds the
 JavaScript ajax call in there.
 To ajaxButton function we also added an anonimous function that will be
 called by Lift when the Ajax request is sent from browser.
 It will print out to console 
\begin_inset Quotes eld
\end_inset

Got an Ajax call
\begin_inset Quotes erd
\end_inset

 and then return the JsCmd SetHtml.
 This will set the content of the element having the id 
\begin_inset Quotes eld
\end_inset

my-div
\begin_inset Quotes erd
\end_inset

 (for example a div element that exists in your page) with the text node
 
\begin_inset Quotes eld
\end_inset

That's it
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Here is a quick description of other SHtml functions:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxButton
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a button that will submit an Ajax request to server
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an anchor tag that when clicked will ubmit an Ajax request
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeAjaxCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders the JavaScript code that will submit an Ajax request
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
span
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a span elementthat when is clicked it will execute a JsCmd
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders the JavaScript code that will submit an Ajax request but it will
 also send the value returned by the JsExp provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
toggleKids
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provides the toggle effect on an element.
 When clicked it will also send an Ajax call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxText
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input text element that will send an Ajax request onblur.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jsonText
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type text element the will send a JSON request on-blur.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxCheckbox
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a checkbox element that when it is clicked it will send an Ajax
 call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxSelect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a select element then when something is selected it sends an Ajax
 request providing the selected values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajaxForm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wraps a NodeSeq, that impersonated the form's content, with <form> tag.
 When the form is submitted an Ajax call is made instead.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jsonForm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Similar with ajaxForm but on client side the form is json-infied and the
 json content is sent to server and pocessed by a JsonHandler.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
swappable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a span that contains one visible element and the other hidden.
 When visible element is clicke it will be hiden and the other one will
 be shown
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
link
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an anchor tag around a given NodeSeq
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type text that will be bound with the function provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
password
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type password that will be bound with the function provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
submit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type submit that will be bound with the function provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
select
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a select element that will be bound with the function provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
textarea
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders a textarea element that will be bound with the function provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
radio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type radio element that will be bound with the function
 provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
checkbox
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type checkbox element that will be bound with the function
 provided
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fileUpload
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Renders an input type file and binds it to the user function that deals
 with the uploaded file
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
JqSHtml object
\end_layout

\begin_layout Standard
SHtml generated code is independent on the JavaScript framework used.
 However 
\family typewriter
net.liftweb.http.jquery.JsSHtml
\family default
 object contains artifacts that are bound with JQuery framework.
 For instance it contains the autocomplete function that renders an input
 type text element but when start typing it will suggest words starting
 with what you typed already.
 Please see http://www.pengoworks.com/workshop/jquery/autocomplete.htm examples.
\end_layout

\begin_layout Subsection
ResourceServer
\end_layout

\begin_layout Standard
ResourceServer is a Lift component that manages the serving of resources
 like JS, CSS etc.
 Well the web container can do that righ? ...
 still container does not serve these resources if they are inside jar files.
 The default URI path for serving such resources is given by
\family typewriter
 LiftRules.resourceServerPath
\family default
 variable which by default it is set to 
\begin_inset Quotes eld
\end_inset

classpath
\begin_inset Quotes erd
\end_inset

.
 The folder location where the resource is looked up inside jar files is
 given by 
\family typewriter
ResourceServer.baseResourceLocation
\family default
 variable which by default it is set to 
\begin_inset Quotes eld
\end_inset

toserve
\begin_inset Quotes erd
\end_inset

.
 Let's assume the following folder structure inside you Lift project:
\end_layout

\begin_layout Standard

\family typewriter
lift-proj/src/main/resources/toserve/css/mystyle.css
\end_layout

\begin_layout Standard
Maven will create the toserver folder in the jar/war file generated.
 Then in your web page you add something like:
\end_layout

\begin_layout Standard

\family typewriter
<link rel="stylesheet" href="/classpath/css/mystyle.css" type="text/css"/>
\end_layout

\begin_layout Standard
Because the first URI part matches with 
\family typewriter
LiftRules.resourceServerPath
\family default
 Lift will tell ResouceServer to load this resource from 'toserve' folder.
 But it will fail.
 There is onething left to do.
 We need to tell ResouceServer to allow the loading of mystyle.css resource.
 We can do this from Boot by calling:
\end_layout

\begin_layout Standard

\family typewriter
ResourceServer.allow { 
\end_layout

\begin_layout Standard

\family typewriter
case "css" :: _ => true 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
We basically told Lift here to allow any resource found in css folder under
 toserve.
 Note that toserver comes from 
\family typewriter
ResourceServer.baseResourceLocation
\family default
 which can be changed.
\end_layout

\begin_layout Subsection
HTTP Authentication
\end_layout

\begin_layout Standard
HTTP authentication is described by RFC 2617 http://www.isi.edu/in-notes/rfc2617.tx
t.
 It describes the means of protecting server resources and allowing access
 only to authorized entities.As you may know any J(2)EE web container provides
 HTTP authentication support moslty using JAAS (Java Authentication and
 Authorization Service.
 More informations can be found here http://java.sun.com/javase/6/docs/technotes/g
uides/security/jaas/JAASRefGuide.html) .
 But this appoach is not without caveats.
 For instance if you provide your own LoginModule or CallbackHandler implementat
ion this will not be loaded by the web application classloader but instead
 by the container classloader (..
 at least in tomcat).
 This means that if your code has other dependencies that you can not use
 these dependencies from your web application since web application classloader
 sits below container's classloader in the delgation chain.
 Besides al these Using Scala's power the developer experience of protecting
 server resources using HTTP authentication can be simplified a lot.
 Lift supports both basic and digest authentications, Basic is shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Authentication example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => Full(AuthRole(
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpBasicAuthentication("lift") {  
\end_layout

\begin_layout Plain Layout

      case ("John", "12test34", req) => 
\end_layout

\begin_layout Plain Layout

	    println("John is authenticated!")
\end_layout

\begin_layout Plain Layout

	    userRoles(AuthRole(
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

)) 
\end_layout

\begin_layout Plain Layout

	    true    
\end_layout

\begin_layout Plain Layout

    }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we just told Lift that /users path is a protected resource and only
 by users that have the Role admin.
 So here we have both authentication and authorization.
 If this function returns an Emptybox it means that this resource is not
 bound to any Role meaning that only authorization will be performed, only
 authentication.
 Secondly using 
\family typewriter
LiftRules.authentication
\family default
 we told Lift that we want BasicAuthentication and of course we are passing
 the function that actually does the authentication.
 This function is actually a PartialFunction[(String, String, Req), Boolean].
 First two members of the tuple are username and password, then the Req
 object.
 In the above example we're basically saying that if user is authenticating
 itself as 
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset

 and password is 
\begin_inset Quotes eld
\end_inset

12test34
\begin_inset Quotes erd
\end_inset

 the access to the protected resource will be granted (since our function
 returns true).
 But in our authentication function we also specify the role for user 
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset

 as being 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

.
 
\family typewriter
userRole
\family default
 is a RequestVar that will be used later on by Lift.
\end_layout

\begin_layout Standard
So at runtime when user tries to access /users Lift knows that this is a
 protected resource and only an admin can access it.
 Therefore Lift is sending down to client a 401 HTTP status (unauthorized
 response).
 User will enter the credentials and if they match with username John and
 password 12test34 we got a successful authentication and because the role
 we set is admin which matches with the role assigned to the protected resource,
 the /users resource is served to client.
 
\end_layout

\begin_layout Standard
A Role is an n-ary tree structure.
 So when we assign a Role to a protectedResource we can actually provide
 an entire tree such as:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/roles.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Roles hierarchy example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assume that your application uses a roles structure as above.
 The Admin is the all mighty role for admins that can do what any sub-role
 can do and more.
 Then we have the Site-Admin that can monitor the application, the User-Admin
 that can manage users, then Romania-Admin that can manage users from Romania,
 US-Admin that can manage users from US and UK-Admin that can only manage
 users from UK.
 Now a User-Admin can manage users from anywhere but a Site-Admin can not
 manage any users.
 Neither a Romania-Admin has the priviledges of User-Admin or Admin, nor
 it can manage the US or UK users.
 You got the picture here; the idea is that the lower a Role is in the hierarchy
 the less priviledged it is.
 Let'see how the code looks like based on the above figure:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Authentication multi-roles example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val roles = AuthRole(
\begin_inset Quotes eld
\end_inset

Admin
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

US-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

UK-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		)
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => roles.getRoleByName(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpBasicAuthentication("lift") {  
\end_layout

\begin_layout Plain Layout

      case ("John", "12test34", req) => 
\end_layout

\begin_layout Plain Layout

	    println("John is authenticated !")
\end_layout

\begin_layout Plain Layout

	    userRoles(AuthRole("User-Admin")) 
\end_layout

\begin_layout Plain Layout

	    true    
\end_layout

\begin_layout Plain Layout

    }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case if user is authenticated authorization will also succeed because
 the user's Role is User-Admin and it is a parent of 
\begin_inset Quotes eld
\end_inset

Romani-Admin
\begin_inset Quotes erd
\end_inset

.
 If the /users resource would have been assigned with 
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

 role and user John would have 
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

 role that even if credentials are correct the authorization fails hence
 a 401 HTTP status is still sent to client.
\end_layout

\begin_layout Standard
In conclusion you have a simple authentication and authorization mechanism
 and of course authentication function would typically validate the credentials
 agains a database and fetch the role from there.
\end_layout

\begin_layout Subsubsection
HTTP Digest Authentication
\end_layout

\begin_layout Standard
So far we talked about basic authentication and authorization.
 Lift also support HTTP Digest authentication.
 This means that the password information that user enters in the browser
 is never propagated on the server.
 Here is how we use it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
HTTP Digest Authentication multi-roles example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import auth._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Boot {
\end_layout

\begin_layout Plain Layout

  def boot = {
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val roles = AuthRole(
\begin_inset Quotes eld
\end_inset

Admin
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

		AuthRole(
\begin_inset Quotes eld
\end_inset

User-Admin
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

US-Admin
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

			AuthRole(
\begin_inset Quotes eld
\end_inset

UK-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		)
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

    LiftRules.protectedResource.append {    
\end_layout

\begin_layout Plain Layout

      case (ParsePath("users" :: _, _, _, _)) => roles.getRoleByName(
\begin_inset Quotes eld
\end_inset

Romania-Admin
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    LiftRules.authentication = HttpDigestAuthentication("lift") {
\end_layout

\begin_layout Plain Layout

      case ("John", req, func) => if (func("12test34")) {
\end_layout

\begin_layout Plain Layout

        println("John is authenticated !")
\end_layout

\begin_layout Plain Layout

        userRoles(AuthRole("useradmin"))
\end_layout

\begin_layout Plain Layout

        true
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        println("Not verified")
\end_layout

\begin_layout Plain Layout

        false
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eveything we talked about Roles is still valid.
 However we're now using digest authentication.
 Note that in this case wer not provided with a password anymore but our
 function is provided with the user name, the Req object and a callback
 function.
 Because digest authentication implies checksum calculations there is no
 need to burden the user with such things.
 However our code calls this callback function by providing the password
 (which can be retrieved from database as we know the user name).
 If this function returns true it means that the digest that client sent
 andthe one that Lift calculated matches so we have a successful authentication.
 
\end_layout

\begin_layout Standard
There is also important to know that diget authentication mechanism uses
 a nonce sequence.
 This sequence is generated by the server when sending down the authentication
 challenge down to client (401 HTTP status).
 In order to avoid replay attacks this nonce is valid only for a period
 of time.
 By default this is set to 30 seconds but you can change this by setting:
\end_layout

\begin_layout Standard

\family typewriter
HttpDigestAuthentication.nonceValidityPeriod = <a value in milliseconds>
\end_layout

\begin_layout Standard
If you use Lift's TimeHelpers you can say:
\end_layout

\begin_layout Standard

\family typewriter
HttpDigestAuthentication.nonceValidityPeriod = 50 seconds 
\end_layout

\begin_layout Standard

\family typewriter
// where seconds is a function and there are implicit conversion functions
 from 
\begin_inset Quotes eld
\end_inset

primitives
\begin_inset Quotes erd
\end_inset

 to TimeSpans type.
\end_layout

\begin_layout Standard
If this period expires even if the authentication and authorization succeed
 Lift will challenge it again by returning 401 HTTP status and a new nonce.
 So the resource is not served yet.
\end_layout

\begin_layout Standard
It is important to know that a user can be assigned with multiple roles,
 not just one.
 This can be done by calling:
\end_layout

\begin_layout Standard

\family typewriter
userRoles(AuthRole("US-Admin", 
\begin_inset Quotes eld
\end_inset

Site-Admin
\begin_inset Quotes erd
\end_inset

)) // AuthRole overloaded apply function takes a repeated parameter.
\end_layout

\begin_layout Standard
This is pretty much it as far as HTTP authentication and authorization goes
 but there is one more thing that is worth to be mentioned.
 If your application does not persist the user's password and only a digest
 internally calculated, the HTTP digest authentication can not really be
 used.
 The reason is that in order to match the client's digest, server needs
 to calculate it and for that it needs the password in clear but because
 the application stores a digest, the user's password can not be recovered.
 Hence the HTTP digest can no be calculated.
 This is a missmatch betwen the two concepts: HTTP digest authentication
 given by RFC 2617 and the unrecoverable password storage.
\end_layout

\end_body
\end_document
