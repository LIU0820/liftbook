#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift and JavaScript
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-and-Javascript"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we'll be discussing some of the techniques that Lift provides
 for simplifying and abstracting access to JavaScript on the client side.
 Using these facilities follows Lift's model of separating code from presentatio
n by allowing you to essentially write JavaScript code in Scala.
 Lift also provides a layer that allows you to use advanced JavaScript functiona
lity via either the JQuery
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://jquery.com/"
target "http://jquery.com/"

\end_inset


\end_layout

\end_inset

 or YUI
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://developer.yahoo.com/yui/"

\end_inset


\end_layout

\end_inset

 user interface libraries.
\end_layout

\begin_layout Section
JavaScript high level abstractions
\end_layout

\begin_layout Standard
You may have noticed that Lift already comes with rich client side functionality
 in the form of AJAX and COMET support (chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:AJAX-and-COMET"

\end_inset

).
 Whenever you use this support, Lift automatically generates the proper
 
\family typewriter
<script>
\family default
 elements in the returned page so that the libraries are included.
 Lift goes one step further, however, by providing a class hierarchy representin
g JavaScript expressions.
 For example, with an AJAX form element in Lift the callback method must
 return JavaScript code to update the client side.
 Instead of just returning a raw JavaScript string to be interpreted by
 the client, you return an instance of the 
\family typewriter
JsCmd
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.js.JsCmd
\end_layout

\end_inset

 trait (either directly or via implicit conversion) that is transformed
 into the proper JavaScript for the client.
\end_layout

\begin_layout Standard

\family typewriter
JsCmd
\family default
 represents a JavaScript command that can be executed on the client.
 There is an additional 
\begin_inset Quotes eld
\end_inset

base
\begin_inset Quotes erd
\end_inset

 trait called 
\family typewriter
JsExp
\family default
 that represents a JavaScript expression.The differences between them are
 not usually important to the developer, since a 
\family typewriter
JsExp
\family default
 instance is implicitly converted to a 
\family typewriter
JsCmd
\family default
.
 Also note that while Lift's JavaScript classes attempt to keep things type-safe
 there are some limitations; in particular, Lift can't check semantic things
 like whether the variable you're trying to access from a given 
\family typewriter
JsCmd
\family default
 actually exists.
 Besides the obvious use in techniques like AJAX and COMET, Lift also makes
 it simple to attach JavaScript to regular Scala XML objects, such as form
 fields.
\end_layout

\begin_layout Standard
As a simple example, let's look at how we might add a simple alert to a
 form if it doesn't validate.
 In this example, we'll assume we have a 
\family typewriter
name
\family default
 form field that shouldn't be blank.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Simple-Form-Validation"

\end_inset

 shows a possible binding from our form snippet.
 Let's break this down a bit: the first thing is that in order to reference
 form elements (or any elements for that matter) from JavaScript, they need
 to have an 
\family typewriter
id
\family default
 attribute.
 We add the id attribute to our text field via the standard 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 mechanism
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cross-ref
\end_layout

\end_inset

.
 Next, we need to define our actual validation.
 We do this by adding some javascript to the 
\family typewriter
onclick
\family default
 attribute of our submit button.
 The onclick attribute evaluates whatever javascript is assigned when the
 button is clicked; if the javascript evaluates to true then submission
 continues.
 If it evaluates to false then submission is aborted.
 In our case, we use the JsIf case class to check to see if the value of
 our myName field is equal to an empty string.
 In this case the JE object holds an implicit conversion from a Scala string
 to a Str (JavaScript string) instance.
 The second argument to JsIf is the body to be executed if the condition
 is true.
 In our case we want to pop up an alert to the user and stop form submission.
 The JsCmd trait (which Alert mixes in) provides a 
\begin_inset Quotes eld
\end_inset

&
\begin_inset Quotes erd
\end_inset

 operator which allows you to chain multiple commands together.
 Here we follow the Alert with a JsReturn, which returns the specified value;
 again, there's an implicit conversion from Boolean to JsExp, so we can
 simply provide the 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

 value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Simple Form Validation
\begin_inset CommandInset label
LatexCommand label
name "lst:Simple-Form-Validation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import JsCmds._
\end_layout

\begin_layout Plain Layout

import JE._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var myName = 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

bind(...
\end_layout

\begin_layout Plain Layout

  
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 -> text(myName, myName = _) % (
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 -> 
\begin_inset Quotes eld
\end_inset

myName
\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Plain Layout

  
\begin_inset Quotes eld
\end_inset

submit
\begin_inset Quotes erd
\end_inset

 -> submit(
\begin_inset Quotes eld
\end_inset

Save
\begin_inset Quotes erd
\end_inset

, ...) % (
\begin_inset Quotes eld
\end_inset

onclick
\begin_inset Quotes erd
\end_inset

 -> 
\end_layout

\begin_layout Plain Layout

    JsIf(JsEq(ValById(
\begin_inset Quotes eld
\end_inset

myName
\begin_inset Quotes erd
\end_inset

), 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

), 
\end_layout

\begin_layout Plain Layout

      Alert(
\begin_inset Quotes eld
\end_inset

You must provide a name
\begin_inset Quotes erd
\end_inset

) & JsReturn(false))
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you peruse the Lift API docs you'll find a large number of traits and
 classes under the JsCmds and JE objects; these provide the vast majority
 of the functionality you would need to write simple JavaScript code directly
 in Lift.
 Having said that, however, it's important to realize that the Lift classes
 are intended to be used for small code fragments.
 If you need to write large portions of JavaScript code for your pages,
 we recommend writing that code in 
\emph on
pure
\emph default
 JavaScript in an external file and then including that file in your pages.
 In particular, if you write your code as JavaScript functions, you can
 use the 
\family typewriter
JE.Call
\family default
 class to execute those functions from your Lift code.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Should we add a small table of commonly used classes? Maybe a brief overview
 of the top-level ones?
\end_layout

\end_inset


\end_layout

\begin_layout Section
JQuery and other JavaScript frameworks
\end_layout

\begin_layout Standard
We've mentioned earlier that Lift uses the JQuery JavaScript framework by
 default.
 Lift wouldn't be Lift, however, if it didn't provide a mechanism for using
 other frameworks.
 The way that lift determines which JavaScript framework to use is via the
 
\family typewriter
JSArtifacts
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.js.JSArtifacts
\end_layout

\end_inset

 trait along with the LiftRules.jsArtifacts var.
 Lift comes with two default implementations of JSArtifacts: 
\family typewriter
JQueryArtifacts
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.js.jquery.JQueryArtifacts
\end_layout

\end_inset


\family default
 and 
\family typewriter
YUIArtifacts
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.js.yui.YUIArtifacts
\end_layout

\end_inset

.
 If you want to use a different framework, you must provide a concrete implement
ation of the JSArtifacts trait specific to that framework.
 The JQuery support in Lift extends beyond just the JSArtifacts, support;
 there are also a number of JSExp and JsCmd traits and classes in the 
\family typewriter
net.liftweb.http.js.jquery
\family default
 package that provide JQuery specific implementations for standard expressions
 and commands.
\end_layout

\begin_layout Standard
Changing one implementation or another can be done from LiftRules.jsArtifacts
 variable, which by default points to JQueryArtifacts.
 Typically this is done in Boot, as shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Configuring-Lift-YUI"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Configuring Lift YUI
\begin_inset CommandInset label
LatexCommand label
name "lst:Configuring-Lift-YUI"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js.yui.YUIArtifacts      
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

 class Boot {      
\end_layout

\begin_layout Plain Layout

   def boot = {      
\end_layout

\begin_layout Plain Layout

     ...
      
\end_layout

\begin_layout Plain Layout

     LiftRules.jsArtifacts = YUIArtifacts      
\end_layout

\begin_layout Plain Layout

     ...
     
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to changing LiftRules, you also need to take into account that
 other frameworks have their own scripts and dependencies that you'll need
 to include in your pages.
 For YUI you would need to include the following scripts (at minimum):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Lift YUI scripts
\begin_inset CommandInset label
LatexCommand label
name "lst:Lift-YUI-scripts"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/yahoo.js" type="text/javascript"/>
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/event.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/dom.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/connection.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/json.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/liftYUI.js" type="text/javascript"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, to keep things simple you could either place all of these items
 in a template that you could embed, or you could combine the files into
 a single JavaScript source file.
\end_layout

\begin_layout Standard
We have some simple recommendations on using different JavaScript frameworks
 from within Lift:
\end_layout

\begin_layout Enumerate
If you don't necessarily need YUI widgets or if you can find similar functionali
ty in JQuery plugins, we recommend using the JQuery framework.
 Lift provides much better support out-of-the-box for JQuery
\end_layout

\begin_layout Enumerate
Do not mix JQuery and YUI unless you really know what you are doing.
 Getting both of them together leads to a number of collisions.
\end_layout

\begin_layout Section
XML and JavaScript
\end_layout

\begin_layout Standard
What we've covered so far is pretty much standard JavaScript behind some
 Lift facades.
 There are situations, however, when you want to do things that are complicated
 or outside the scope of typical JavaScript functionality.
 One example of this is when you need to build dynamic DOM elements from
 JavaScript code, say to build an HTML list.
 Lift has a very nice way of dealing with such situation; with a few lines
 of code you can achieve quite a lot.
 The main functionality for this is provided via the Jx* classes
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.js.Jx, etc
\end_layout

\end_inset

, which you can use to transform a scala.xml.NodeSeq into javascript code
 that generates the corresponding nodes on the client side.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Jx-trivial-example"

\end_inset

 shows a simple example of emitting a div on a page via JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Jx trivial example
\begin_inset CommandInset label
LatexCommand label
name "lst:Jx-trivial-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js._ 
\end_layout

\begin_layout Plain Layout

 import JE._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 val div = Jx(<div>Hi there</div>)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code generates the following HTML:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Jx Emitted Code
\begin_inset CommandInset label
LatexCommand label
name "lst:Jx-Emitted-Code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

function(it) {
\end_layout

\begin_layout Plain Layout

  var df = document.createDocumentFragment();
\end_layout

\begin_layout Plain Layout

  var vINIJ1YTZG5 = document.createElement('div');
\end_layout

\begin_layout Plain Layout

  df.appendChild(vINIJ1YTZG5);
\end_layout

\begin_layout Plain Layout

  vINIJ1YTZG5.appendChild(document.createTextNode('Hi there'));
\end_layout

\begin_layout Plain Layout

  return df;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, Lift took our XML code and transformed it into a JavaScript
 function that dynamically creates a document fragment containing the given
 NodeSeq.
 The 
\family typewriter
it
\family default
 parameter can be any JavaScript object; we'll cover how you use it in a
 moment.
 The name of the 
\emph on
var
\emph default
 is automatically and randomly generated to ensure uniqueness.
\end_layout

\begin_layout Standard
Of course, if that was all Lift was doing that's not much help.
 At this point we've only generated a function that generates XML.
 Let's take a look on a more complex example that shows the real power of
 the Jx classes.
 Assume we have a JSON structure that contains an array of objects containing
 firstName and lastName properties.
 Such JSON structure could look something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Sample JSON Structure
\begin_inset CommandInset label
LatexCommand label
name "lst:Sample-JSON-Structure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var list = {
\end_layout

\begin_layout Plain Layout

	persons: [
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Thor
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Asgard
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Todd
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Wraith
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Rodney
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Human
\begin_inset Quotes erd
\end_inset

}
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Guess what I've been watching lately ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we can use a combination of Jx classes to render this content as an
 HTML dynamic list:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Rendering a JSON List Via Jx
\begin_inset CommandInset label
LatexCommand label
name "lst:Rendering-a-JSON-list"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

def renderPerson = Jx(<li class="item_header"> {JsVar("it", "name")} is
 {JsVar("it", "race")}</li>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Jx(<ul>{JxMap(JsVar("it.persons"), renderPerson)}</ul>)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well what this code does is this:
\end_layout

\begin_layout Enumerate
Construct an <ul> list that contains a bunch of elements
\end_layout

\begin_layout Enumerate
JxMap takes a JavaScript object, in this case 
\family typewriter
it.persons
\family default
 (remember 
\family typewriter
it
\family default
 is the parameter of the generated function), and iterate for each element
 of the array and apply the renderPerson function.
 Of course each element of the array will be a JSON object containing name
 and race properties.
\end_layout

\begin_layout Enumerate
The 
\family typewriter
renderPerson
\family default
 function generates a JavaScript function as we've already shown, and renders
 the JavaScript code that generates the <li> elements containing the name
 value followed by 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 followed by the race value.
\end_layout

\begin_layout Enumerate
If we send this generated JavaScript function to client and calling it by
 pass the 
\emph on
list
\emph default
 variable above It will create the following document fragment:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Thor is Asgard</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Todd is Wraith</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Rodney is Human</li>
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a couple of lines of code we've managed to generate the JavaScript
 code that creates document fragments dynamically.
\end_layout

\begin_layout Standard
Here is the list of JX classes that you may find interesting:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxBase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The parent trait for all other Jx classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iterates over a JavaScript array and applies a function on each element
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMatch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Match a JsExp against a sequence of JsCase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxCase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp for matching purposes and the NodeSeq to be applied in
 case the matching succeeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp and a NodeSeq to be applied only if JsExp is evaluated
 to true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIfElse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Similar with JxIf but it contains the else branch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The basic application of the transformation from a NodeSeq to the JavaScript
 code
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
JSON
\end_layout

\begin_layout Standard
JSON
\begin_inset Foot
status open

\begin_layout Plain Layout
Java Script Object Notation - 
\begin_inset CommandInset href
LatexCommand href
target "http://www.json.org"

\end_inset


\end_layout

\end_inset

 is a way of structuring information in JavaScript code.
 One of its most common uses is to represent structured information on the
 wire.
 One example would be a JavaScript AJAX API where the server response is
 in fact a JSON construct.
 Let's look at an example first in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Ajax-JSON-response"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ajax JSON response
\begin_inset CommandInset label
LatexCommand label
name "lst:Ajax-JSON-response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 class SimpleSnippet {
\end_layout

\begin_layout Plain Layout

  def ajaxFunc : JsCmd = {
\end_layout

\begin_layout Plain Layout

	JsCrVar("myObject", JsObj(("persons", JsArray(
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Thor"), ("race", "Asgard")),
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Todd"), ("race", "Wraith")),
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Rodney"), ("race", "Human"))
\end_layout

\begin_layout Plain Layout

	)))) & JsRaw("alert(myObject.persons[0].name)")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def renderAjaxButton(xhtml: Group): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    bind("ex", xhtml,         
\end_layout

\begin_layout Plain Layout

			"button" -> SHtml.ajaxButton(Text(
\begin_inset Quotes eld
\end_inset

Press me
\begin_inset Quotes erd
\end_inset

), ajaxFunc))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Your template would look like listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:AJAX-Template"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
AJAX Template
\begin_inset CommandInset label
LatexCommand label
name "lst:AJAX-Template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

	<lift:SimpleSnippet.renderAjaxButton>
\end_layout

\begin_layout Plain Layout

		<ex:button/>
\end_layout

\begin_layout Plain Layout

	</lift:SimpleSnippet.renderAjaxButton>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First off, we have a simple snippet function called 
\family typewriter
renderAjaxButton
\family default
.
 Here we're binding the ex:button tag and render a XHTML button tag that
 when pressed will send an Ajax request to server.
 When this request is received, the 
\family typewriter
ajaxFunc
\family default
 is executed and the JsCmd response is turned into a JavaScript content
 type response.
 In 
\family typewriter
ajaxFunc
\family default
 we construct a JSON object (the same one we used previously for the persons
 object).
 We assign the JSON structure to the JavaScript variable 
\family typewriter
myObject
\family default
 and them call alert on the first element on the persons object.
 The rendered JavaScript code that will be send down the wire will be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Generated JavaScript
\begin_inset CommandInset label
LatexCommand label
name "lst:Generated-JavaScript"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var myObject = {'persons': [{'name': 'Thor', 'race': 'Asgard'}, 
\end_layout

\begin_layout Plain Layout

                            {'name': 'Todd', 'race': 'Wraith'} , 
\end_layout

\begin_layout Plain Layout

							{'name': 'Rodney', 'race': 'Human'}]}; 
\end_layout

\begin_layout Plain Layout

alert(myObject.persons[0].name);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So in your page when you press the button you'll get an alert dialog saying
 
\begin_inset Quotes eld
\end_inset

Thor
\begin_inset Quotes erd
\end_inset

.
 Here we used the JsRaw class which basically renders the exact thing you
 passed to it: raw JavaScript code.
\end_layout

\begin_layout Subsection
JSON forms
\end_layout

\begin_layout Standard
Now that we've covered sending JSON from the server to the client, let's
 look at going in the opposite direction.
 Lift provides a mechanism for sending form data to the server encapsulated
 in a JSON object.
 In and of itself sending the data in JSON format is relatively simple;
 where Lift really adds value is via the JsonHandler
\begin_inset Foot
status open

\begin_layout Plain Layout
net.liftweb.http.JsonHandler
\end_layout

\end_inset

 class.
 This class provides a framework for simplifying processing of submitted
 JSON data.
 To start, let's look at some example template code for a JSON form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A Simple JSON form
\begin_inset CommandInset label
LatexCommand label
name "lst:A-Simple-JSON-form"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">      
\end_layout

\begin_layout Plain Layout

	<lift:JSONForm.head />      
\end_layout

\begin_layout Plain Layout

	<lift:JSONForm.show>
\end_layout

\begin_layout Plain Layout

	  <input type="text" name="name" />
\end_layout

\begin_layout Plain Layout

	  <br />
\end_layout

\begin_layout Plain Layout

	  <input type="text" name="value" /> 
\end_layout

\begin_layout Plain Layout

	  <br />  
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Bike" /> 
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Car" /> 
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Airplane" /> 
\end_layout

\begin_layout Plain Layout

	  <br /> 
\end_layout

\begin_layout Plain Layout

	  <select name="cars">
\end_layout

\begin_layout Plain Layout

	    <option value="volvo">Volvo</option> 
\end_layout

\begin_layout Plain Layout

		<option value="saab">Saab</option> 
\end_layout

\begin_layout Plain Layout

		<option value="opel">Opel</option>  
\end_layout

\begin_layout Plain Layout

	    <option value="audi">Audi</option>  
\end_layout

\begin_layout Plain Layout

	  </select>
\end_layout

\begin_layout Plain Layout

	  <button type="submit">Submit</button>
\end_layout

\begin_layout Plain Layout

	</lift:JSONForm.show>
\end_layout

\begin_layout Plain Layout

	<div id="json_result"></div> 
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A you can see, the XHTML template is relatively straightforward.
 The Snippet code is where things really get interesting:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JSON Form Snippet Code
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class JSONForm {  	
\end_layout

\begin_layout Plain Layout

	def head = <head>{Script(json.jsCmd)}</head> 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

	def show(html: Group): NodeSeq = {
\end_layout

\begin_layout Plain Layout

		SHtml.jsonForm(json, html) 
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	import JsCmds._ 
\end_layout

\begin_layout Plain Layout

	object json extends JsonHandler {
\end_layout

\begin_layout Plain Layout

		def apply(in: Any): JsCmd = SetHtml("json_result", in match { 
\end_layout

\begin_layout Plain Layout

			case j @ JsonCmd("processForm", _, p: Map[String, _], _) => {
\end_layout

\begin_layout Plain Layout

				// process the form or whatever 
\end_layout

\begin_layout Plain Layout

				println("Cars = " + urlDecode(p("cars"))) 
\end_layout

\begin_layout Plain Layout

				println("Name = " + urlDecode(p("name"))) 
\end_layout

\begin_layout Plain Layout

				<b>{p}</b> 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			case x => <b>Problem...
 didn't handle JSON message {x}</b>
\end_layout

\begin_layout Plain Layout

		})
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first thing we define is the 
\family typewriter
head
\family default
 function.
 Its purpose is simply to generate the JavaScript functions that set up
 the form handling on the client side.
 That means that when the submit button is clicked, the contents of the
 form are turned into JSON and submitted via an Ajax call to the server.
 The 
\family typewriter
show
\family default
 function defines the connection between the concrete JsonHandler instance
 that will process the form and the template HTML that contains the form.
 We perform this binding with the 
\family typewriter
SHtml.jsonForm
\family default
 method.
 This wraps the HTML with a 
\family typewriter
<form>
\family default
 tag and sets the 
\family typewriter
onsubmit
\family default
 event to do JSON bundling.
\end_layout

\begin_layout Standard
The key part of the equation is our JsonHandler object.
 The apply method is what will be called when the JSON object is submitted
 to the server.
 If the JSON is properly parsed then you'll get a JsonCmd instance which
 you can use Scala's matching to pick apart.
 The apply function needs to return a JsCmd (JavaScript code), which in
 this case sets the HTML content of the 
\family typewriter
json_result
\family default
 div element.
 When the form is stringified into its JSON representation Lift uses a command
 property indicating the action that needs to be done on server and the
 actual JSON data.
 In the case of JSON forms the command is always 
\begin_inset Quotes eld
\end_inset

processForm
\begin_inset Quotes erd
\end_inset

 as this is important for pattern matching as seen above.
 The actual form content is a Map object that can be easily use to obtain
 the values for each form field.
\end_layout

\end_body
\end_document
