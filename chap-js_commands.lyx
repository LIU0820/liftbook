#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift and Javascript
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-and-Javascript"

\end_inset


\end_layout

\begin_layout Section
JavaScript high level abstractions
\end_layout

\begin_layout Standard
You may already noticed that Lift comes with a rich client side functionality.
 By default it uses JQuery (http://jquery.com/) javascript framework.
 So a lot of JavaScript artifacts are there for you to use them from Scala
 code; for instance Lift is adding the JavaScript code for Ajax/Comet support.
 When you are using Ajax, for example, many times you want to return a little
 JavaScript code to be executed on client side.
 So instead of returning from your Ajax function a String containing the
 JavaScript code you can return a Lift object ...
 in essence a JsExp or JsCmd.
 So yes Lift abstracts away a JavaScript expression (JsExp) and JavaScript
 command (JsCmd) etc.
 But let's dig a bit deeper in this Lift JS API.
\end_layout

\begin_layout Standard

\family typewriter
net.liftweb.http.js.JsExp 
\family default
is a trait that abstracts a JavaScript expression.
 For instance JE.ValById(
\begin_inset Quotes eld
\end_inset

sometextfield
\begin_inset Quotes erd
\end_inset

) which will render the JavaScript code document.getElementById('sometextfield').v
alue.
 The next important class is 
\family typewriter
net.liftweb.http.js.JsCmd 
\family default
which impersonates a JavaScript command.
 For instance a call to a function.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JsExp example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import JE._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AnonFunc(ValById(
\begin_inset Quotes eld
\end_inset

sometextfield
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

//which will render the following JavaScript code:
\end_layout

\begin_layout Plain Layout

function(){document.getElementById('sometextfield').value}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you dig into code you'll see that apply function of the AnonFunc object
 takes a JsCmd parameter but here we've passed a JsExp.
 This is ok because there is an implicit conversion from JsExp to JsCmd.
 Please see the Lift API for JsCmd and JsExp subclasses.
 You may find some plain Scala objects that do not extends JsExp or JsCmd
 and yet they are used in JsExp.
 That's becasue their apply functions return a JsExp or JsCmd.
 There are other implicit functions defined to convert from String, Int,
 Long etc.
 to JsExp instances to ese up the code writing.
\end_layout

\begin_layout Standard
Another important class is JsCommands.
 It is actually used to chain JsCmd instances and construct a JavaScript
 LiftResponse.
 For example we can have:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JsCommands example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(JsCommands.create & Alert(
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

) & Alert(
\begin_inset Quotes eld
\end_inset

Lift
\begin_inset Quotes erd
\end_inset

)).toResponse
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above will create the LiftResponse having text/javascript content-type
 and calls subsequently JavaScript alert(
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

) and then alert(
\begin_inset Quotes eld
\end_inset

Lift
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
We barely scratched the surface of the JavaScript Scala API that Lift offers
 and presented the fundamental classes.
 It is not the scope of this book to discuss each ad every class but to
 provide an understanding of the API.
 If you have a large JavaScript code to build using Lift abstractions would
 lead to more code to type so we recommend putting your code into a .js file
 and include it in your page.
 But for simple things Lift JS abstractions can be extremely useful.
\end_layout

\begin_layout Subsection
JQuery and other JavaScript frameworks
\end_layout

\begin_layout Standard
We've mentioned earlier hat Lift comes together with JQuery JS framework
 (which is a great framework btw) but Lift is tightly coupled with Query.
 In fact you can plugin any JavaScript framework or your own framework for
 that matter by implementing JSArtifacts trait.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JSArtifacts trait
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Abstracted JavaScript artifacts used by lift core.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

trait JSArtifacts {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Toggles between current JS object and the object denominated by id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def toggle(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Hides the element denominated by id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def hide(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Shows the element denominated by this id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def show(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Shows the element denoinated by id and puts the focus on it
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def showAndFocus(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Serializes a form denominated by the id.
 It returns a query string
\end_layout

\begin_layout Plain Layout

   * containing the fields that are to be submitted
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def serialize(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Sets the inner HTML of the element denominated by the id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def setHtml(id: String, xml: NodeSeq): JsCmd
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Sets the JavaScript that will be executed when document is ready
\end_layout

\begin_layout Plain Layout

   * for processing
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def onLoad(cmd: JsCmd): JsCmd
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Makes an Ajax request using lift's Ajax path and the request
\end_layout

\begin_layout Plain Layout

   * attributes described by data parameter
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def ajax(data: AjaxInfo): String
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Makes a Ajax comet request using lift's Comet path and the request
\end_layout

\begin_layout Plain Layout

   * attributes described by data parameter
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def comet(data: AjaxInfo): String
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Trabsforms a JSON object intoits string representation
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def jsonStringify(in: JsExp) : JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Converts a form denominated by formId into a JSON object
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def formToJSON(formId: String): JsExp
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These functions are called by Lift core framework.
 Currently we have two implementations 
\family typewriter
net.liftweb.http.js.jquery.JQueryArtifacacts
\family default
 and 
\family typewriter
net.liftweb.http.js.yui.YUIArtifacts
\family default
.
 For JQuery implementation there is also a handful of JSExp-s and JsCmd-s
 in 
\family typewriter
net.liftweb.http.js.jquery
\family default
 package.
 They abstract away lots of JQuery goodies but we'll let you discover them.
\end_layout

\begin_layout Standard
Changing one implementation or another can be done from LiftRules.jsArtifacts
 variable which by default points to JQueryArtifacts.
 However each JavaScript framework comes with its own JS scripts and perhaps
 its own dependencies.
 For YUI you need to include the following scripts (at minimum):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Lift YUI scripts 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/yahoo.js" type="text/javascript"/>
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/event.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/dom.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/connection.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/json.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/liftYUI.js" type="text/javascript"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
..
 of course you can probably lint them into a single JS file for optimizations.
 
\end_layout

\begin_layout Standard
Now in Boot we need to configure YUIArtifacts:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Configuring Lift YUI
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js.yui.YUIArtifacts
\end_layout

\begin_layout Plain Layout

 ...
      
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

 class Boot {      
\end_layout

\begin_layout Plain Layout

   def boot = {      
\end_layout

\begin_layout Plain Layout

     ...
      
\end_layout

\begin_layout Plain Layout

     LiftRules.jsArtifacts = YUIArtifacts      
\end_layout

\begin_layout Plain Layout

     ...
     
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\bar under
Recommendations
\end_layout

\begin_layout Enumerate
If you do not necessary need YUI widgets or if you can find similar funcionality
 in JQuery plugins, we recommend using JQuery framewok.
 One of the reasons (besides the fact that we like JQuery more) is that
 Lift comes with a great deal of JsCmd and JsExp classes/objects for abstracting
 JQuery goodies.
\end_layout

\begin_layout Enumerate
Do not mix JQuery and YUI unless you really know what you are doing.
\end_layout

\begin_layout Subsection
XML and JavaScript
\end_layout

\begin_layout Standard
There are situations when you need to build dynamic DOM elements from JavaScript
 code and build dynamic lists, for example.
 Lift has a really interesting way of dealing with such situation and with
 a few lines of code you are achieving quite a lot.
 For instance there are a set of classes (we call them Jx classes) that
 you can use to transform a scala.xml.NodeSeq into javascript code that generates
 dynamically the nodes on the client side.
 But let's see a few examples and comment them.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Jx trivial example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js._ 
\end_layout

\begin_layout Plain Layout

 import JE._
\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 val div = Jx(<div>Hi there</div>)      
\end_layout

\begin_layout Plain Layout

 println(div.toJs) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 /* This will print out:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 function(it) {var df = document.createDocumentFragment();
\end_layout

\begin_layout Plain Layout

 var vINIJ1YTZG5 = document.createElement('div');
\end_layout

\begin_layout Plain Layout

 df.appendChild(vINIJ1YTZG5);
\end_layout

\begin_layout Plain Layout

 vINIJ1YTZG5.appendChild(document.createTextNode('Hi there'));
\end_layout

\begin_layout Plain Layout

 return df;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
So Lift took our XML code and transfomed it into a JavaScript function that
 dynamically creates a document fragment containing the same node.
 The it parameter can be any JavaScript object that you can exploit.
 The name of the 
\emph on
var
\emph default
 is automatically and randomly generated to ensure uniqueness.
\end_layout

\begin_layout Standard
But of course this is not all there is to it.
 Let's take a look on a more complex example.
 Assume we have a JSON structure that contains an array of objects containing
 firstName and lastName properties.
 Such JSON structure could look something like:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var list = {
\end_layout

\begin_layout Plain Layout

	persons: [
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Thor
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Asgard
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Todd
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Wraith
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Rodney
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Human
\begin_inset Quotes erd
\end_inset

}
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Guess what I've been watching lately ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now assume that we want to render this content as an HTML dynamic list:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

def renderPerson = Jx(<li class="item_header"> {JsVar("it", "name")} is
 {JsVar("it", "race")}</li>) 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Jx(<ul>{JxMap(JsVar("it.persons"), renderPerson)}</ul>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well whay this code does is this
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
Construct an <ul> list that contains a bunch of elements
\end_layout

\begin_layout Enumerate
JxMap takes a JavaScript object, in this case it.persons (remember it is
 the parameter of the generated function), and iterate for each element
 of the array and apply the renderPerson function.
 Of course each element of the array will be a JSON object containing name
 and race properties.
\end_layout

\begin_layout Enumerate
renderPerson function also generates a JavaScript function as we've seen
 above and renders the JavaScript code that generts the <li> elements containing
 the name value followed by 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 followed by the race value.
\end_layout

\begin_layout Enumerate
If we send this generated JavaScript function to client and calling it by
 passs the 
\emph on
list
\emph default
 variable above It will create the following document fragment:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Thor is Asgard</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Todd is Wraith</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Rodney is Human</li>
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So with a couple of lines of code we manaed to generate the JavaScript code
 that creates document fragments dynamically.
\end_layout

\begin_layout Standard
Here is the list of JX classes that you may find interesting:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxBase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The parent trait for all other Jx classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iterates over a JavaScript array and applies a function on each element
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMatch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Match a JsExp against a sequence of JsCase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxCase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp for matching purposes and the NodeSeq tobe applied in cas
 the matching succeeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp and a NodeSeq to be applied only if JsExp is evaluated
 to true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIfElse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Similar with JxIf but it contains the else branch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The basic application of the transformation from a NodeSeq to the JavaScript
 code
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_body
\end_document
