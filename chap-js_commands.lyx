#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Lift and Javascript
\begin_inset CommandInset label
LatexCommand label
name "cha:Lift-and-Javascript"

\end_inset


\end_layout

\begin_layout Section
JavaScript high level abstractions
\end_layout

\begin_layout Standard
You may already noticed that Lift comes with a rich client side functionality.
 By default it uses JQuery (http://jquery.com/) javascript framework.
 So a lot of JavaScript artifacts are there for you to use them from Scala
 code; for instance Lift is adding the JavaScript code for Ajax/Comet support.
 When you are using Ajax, for example, many times you want to return a little
 JavaScript code to be executed on client side.
 So instead of returning from your Ajax function a String containing the
 JavaScript code you can return a Lift object ...
 in essence a JsExp or JsCmd.
 So yes Lift abstracts away a JavaScript expression (JsExp) and JavaScript
 command (JsCmd) etc.
 But let's dig a bit deeper in this Lift JS API.
\end_layout

\begin_layout Standard

\family typewriter
net.liftweb.http.js.JsExp 
\family default
is a trait that abstracts a JavaScript expression.
 For instance JE.ValById(
\begin_inset Quotes eld
\end_inset

sometextfield
\begin_inset Quotes erd
\end_inset

) which will render the JavaScript code document.getElementById('sometextfield').v
alue.
 The next important class is 
\family typewriter
net.liftweb.http.js.JsCmd 
\family default
which impersonates a JavaScript command.
 For instance a call to a function.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JsExp example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import JE._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AnonFunc(ValById(
\begin_inset Quotes eld
\end_inset

sometextfield
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

//which will render the following JavaScript code:
\end_layout

\begin_layout Plain Layout

function(){document.getElementById('sometextfield').value}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you dig into code you'll see that apply function of the AnonFunc object
 takes a JsCmd parameter but here we've passed a JsExp.
 This is ok because there is an implicit conversion from JsExp to JsCmd.
 Please see the Lift API for JsCmd and JsExp subclasses.
 You may find some plain Scala objects that do not extends JsExp or JsCmd
 and yet they are used in JsExp.
 That's becasue their apply functions return a JsExp or JsCmd.
 There are other implicit functions defined to convert from String, Int,
 Long etc.
 to JsExp instances to ese up the code writing.
\end_layout

\begin_layout Standard
Another important class is JsCommands.
 It is actually used to chain JsCmd instances and construct a JavaScript
 LiftResponse.
 For example we can have:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JsCommands example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(JsCommands.create & Alert(
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

) & Alert(
\begin_inset Quotes eld
\end_inset

Lift
\begin_inset Quotes erd
\end_inset

)).toResponse
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above will create the LiftResponse having text/javascript content-type
 and calls subsequently JavaScript alert(
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

) and then alert(
\begin_inset Quotes eld
\end_inset

Lift
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
We barely scratched the surface of the JavaScript Scala API that Lift offers
 and presented the fundamental classes.
 It is not the scope of this book to discuss each ad every class but to
 provide an understanding of the API.
 If you have a large JavaScript code to build using Lift abstractions would
 lead to more code to type so we recommend putting your code into a .js file
 and include it in your page.
 But for simple things Lift JS abstractions can be extremely useful.
\end_layout

\begin_layout Section
JQuery and other JavaScript frameworks
\end_layout

\begin_layout Standard
We've mentioned earlier hat Lift comes together with JQuery JS framework
 (which is a great framework btw) but Lift is tightly coupled with Query.
 In fact you can plugin any JavaScript framework or your own framework for
 that matter by implementing JSArtifacts trait.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JSArtifacts trait
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Abstracted JavaScript artifacts used by lift core.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

trait JSArtifacts {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Toggles between current JS object and the object denominated by id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def toggle(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Hides the element denominated by id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def hide(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Shows the element denominated by this id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def show(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Shows the element denoinated by id and puts the focus on it
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def showAndFocus(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Serializes a form denominated by the id.
 It returns a query string
\end_layout

\begin_layout Plain Layout

   * containing the fields that are to be submitted
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def serialize(id: String): JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Sets the inner HTML of the element denominated by the id
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def setHtml(id: String, xml: NodeSeq): JsCmd
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Sets the JavaScript that will be executed when document is ready
\end_layout

\begin_layout Plain Layout

   * for processing
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def onLoad(cmd: JsCmd): JsCmd
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Makes an Ajax request using lift's Ajax path and the request
\end_layout

\begin_layout Plain Layout

   * attributes described by data parameter
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def ajax(data: AjaxInfo): String
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Makes a Ajax comet request using lift's Comet path and the request
\end_layout

\begin_layout Plain Layout

   * attributes described by data parameter
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def comet(data: AjaxInfo): String
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Trabsforms a JSON object intoits string representation
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def jsonStringify(in: JsExp) : JsExp
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Converts a form denominated by formId into a JSON object
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def formToJSON(formId: String): JsExp
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These functions are called by Lift core framework.
 Currently we have two implementations 
\family typewriter
net.liftweb.http.js.jquery.JQueryArtifacacts
\family default
 and 
\family typewriter
net.liftweb.http.js.yui.YUIArtifacts
\family default
.
 For JQuery implementation there is also a handful of JSExp-s and JsCmd-s
 in 
\family typewriter
net.liftweb.http.js.jquery
\family default
 package.
 They abstract away lots of JQuery goodies but we'll let you discover them.
\end_layout

\begin_layout Standard
Changing one implementation or another can be done from LiftRules.jsArtifacts
 variable which by default points to JQueryArtifacts.
 However each JavaScript framework comes with its own JS scripts and perhaps
 its own dependencies.
 For YUI you need to include the following scripts (at minimum):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Lift YUI scripts 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/yahoo.js" type="text/javascript"/>
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/event.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/dom.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/connection.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/yui/json.js" type="text/javascript"/>   
\end_layout

\begin_layout Plain Layout

 <script src="/classpath/liftYUI.js" type="text/javascript"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
..
 of course you can probably lint them into a single JS file for optimizations.
 
\end_layout

\begin_layout Standard
Now in Boot we need to configure YUIArtifacts:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Configuring Lift YUI
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js.yui.YUIArtifacts
\end_layout

\begin_layout Plain Layout

 ...
      
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

 class Boot {      
\end_layout

\begin_layout Plain Layout

   def boot = {      
\end_layout

\begin_layout Plain Layout

     ...
      
\end_layout

\begin_layout Plain Layout

     LiftRules.jsArtifacts = YUIArtifacts      
\end_layout

\begin_layout Plain Layout

     ...
     
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\bar under
Recommendations
\end_layout

\begin_layout Enumerate
If you do not necessary need YUI widgets or if you can find similar funcionality
 in JQuery plugins, we recommend using JQuery framewok.
 One of the reasons (besides the fact that we like JQuery more) is that
 Lift comes with a great deal of JsCmd and JsExp classes/objects for abstracting
 JQuery goodies.
\end_layout

\begin_layout Enumerate
Do not mix JQuery and YUI unless you really know what you are doing.
\end_layout

\begin_layout Section
XML and JavaScript
\end_layout

\begin_layout Standard
There are situations when you need to build dynamic DOM elements from JavaScript
 code and build dynamic lists, for example.
 Lift has a really interesting way of dealing with such situation and with
 a few lines of code you are achieving quite a lot.
 For instance there are a set of classes (we call them Jx classes) that
 you can use to transform a scala.xml.NodeSeq into javascript code that generates
 dynamically the nodes on the client side.
 But let's see a few examples and comment them.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Jx trivial example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

 import net.liftweb.http.js._ 
\end_layout

\begin_layout Plain Layout

 import JE._
\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 val div = Jx(<div>Hi there</div>)      
\end_layout

\begin_layout Plain Layout

 println(div.toJs) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 /* This will print out:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 function(it) {var df = document.createDocumentFragment();
\end_layout

\begin_layout Plain Layout

 var vINIJ1YTZG5 = document.createElement('div');
\end_layout

\begin_layout Plain Layout

 df.appendChild(vINIJ1YTZG5);
\end_layout

\begin_layout Plain Layout

 vINIJ1YTZG5.appendChild(document.createTextNode('Hi there'));
\end_layout

\begin_layout Plain Layout

 return df;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
So Lift took our XML code and transfomed it into a JavaScript function that
 dynamically creates a document fragment containing the same node.
 The it parameter can be any JavaScript object that you can exploit.
 The name of the 
\emph on
var
\emph default
 is automatically and randomly generated to ensure uniqueness.
\end_layout

\begin_layout Standard
But of course this is not all there is to it.
 Let's take a look on a more complex example.
 Assume we have a JSON structure that contains an array of objects containing
 firstName and lastName properties.
 Such JSON structure could look something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var list = {
\end_layout

\begin_layout Plain Layout

	persons: [
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Thor
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Asgard
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Todd
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Wraith
\begin_inset Quotes erd
\end_inset

}, 
\end_layout

\begin_layout Plain Layout

		{name: 
\begin_inset Quotes eld
\end_inset

Rodney
\begin_inset Quotes erd
\end_inset

, race: 
\begin_inset Quotes eld
\end_inset

Human
\begin_inset Quotes erd
\end_inset

}
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Guess what I've been watching lately ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now assume that we want to render this content as an HTML dynamic list:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

def renderPerson = Jx(<li class="item_header"> {JsVar("it", "name")} is
 {JsVar("it", "race")}</li>) 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Jx(<ul>{JxMap(JsVar("it.persons"), renderPerson)}</ul>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well what this code does is this:
\end_layout

\begin_layout Enumerate
Construct an <ul> list that contains a bunch of elements
\end_layout

\begin_layout Enumerate
JxMap takes a JavaScript object, in this case it.persons (remember it is
 the parameter of the generated function), and iterate for each element
 of the array and apply the renderPerson function.
 Of course each element of the array will be a JSON object containing name
 and race properties.
\end_layout

\begin_layout Enumerate
renderPerson function also generates a JavaScript function as we've seen
 above and renders the JavaScript code that generts the <li> elements containing
 the name value followed by 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 followed by the race value.
\end_layout

\begin_layout Enumerate
If we send this generated JavaScript function to client and calling it by
 passs the 
\emph on
list
\emph default
 variable above It will create the following document fragment:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Thor is Asgard</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Todd is Wraith</li>
\end_layout

\begin_layout Plain Layout

 <li class=
\begin_inset Quotes erd
\end_inset

item_header
\begin_inset Quotes erd
\end_inset

>Rodney is Human</li>
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So with a couple of lines of code we manaed to generate the JavaScript code
 that creates document fragments dynamically.
\end_layout

\begin_layout Standard
Here is the list of JX classes that you may find interesting:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxBase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The parent trait for all other Jx classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iterates over a JavaScript array and applies a function on each element
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxMatch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Match a JsExp against a sequence of JsCase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxCase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp for matching purposes and the NodeSeq tobe applied in cas
 the matching succeeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contains a JsExp and a NodeSeq to be applied only if JsExp is evaluated
 to true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JxIfElse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Similar with JxIf but it contains the else branch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The basic application of the transformation from a NodeSeq to the JavaScript
 code
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
JSON
\end_layout

\begin_layout Standard
JSON (Java Script Object Notation - http://www.json.org) is (as you may well
 know) a way of structuring information in JavaScript code.
 It is also use to represent structured information on the wire.
 One example would be a JavaScript Ajax API where server response is in
 fact a JSON construct.
 Let's take an example first.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ajax JSON response
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

 class SimpleSnippet {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def ajaxFunc : JsCmd = {
\end_layout

\begin_layout Plain Layout

	JsCrVar("myObject", JsObj(("persons", JsArray(
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Thor"), ("race", "Asgard")),
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Todd"), ("race", "Wraith")),
\end_layout

\begin_layout Plain Layout

		JsObj(("name", "Rodney"), ("race", "Human"))
\end_layout

\begin_layout Plain Layout

	)))) & JsRaw("alert(myObject.persons[0].name)")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def renderAjaxButton(xhtml: Group): NodeSeq = {
\end_layout

\begin_layout Plain Layout

    bind("ex", xhtml,         
\end_layout

\begin_layout Plain Layout

			"button" -> SHtml.ajaxButton(Text(
\begin_inset Quotes eld
\end_inset

Press me
\begin_inset Quotes erd
\end_inset

), ajaxFunc))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 /* And in your template the code ould be:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

	<lift:SimpleSnippet.renderAjaxButton>
\end_layout

\begin_layout Plain Layout

		<ex:button/>
\end_layout

\begin_layout Plain Layout

	</lift:SimpleSnippet.renderAjaxButton>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all we have a simple snippet functions called 
\family typewriter
renderAjaxButton
\family default
.
 Here we're binding the ex:button tag and render a XHTML button tag that
 when it is pressed it will send an Ajax request to server.
 When this request is received, the 
\family typewriter
ajaxFunc
\family default
 is executes and the JsCmd response is turned into a JavaScript content
 type response.
 In 
\family typewriter
ajaxFunc 
\family default
that we are constructing a JSON object in fact the same one we used previously
 for persons object.
 We declare the JavaScript variable myObject being assigned to the JSON
 structure and them call alert on the first element on the persons object.
 The rendered JavaScript code that will be send down the wire will be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var myObject = {'persons': [{'name': 'Thor', 'race': 'Asgard'}, 
\end_layout

\begin_layout Plain Layout

                            {'name': 'Todd', 'race': 'Wraith'} , 
\end_layout

\begin_layout Plain Layout

							{'name': 'Rodney', 'race': 'Human'}]}; 
\end_layout

\begin_layout Plain Layout

alert(myObject.persons[0].name);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So in your page when you are presing the button you'llget an alert dialog
 saying 
\begin_inset Quotes eld
\end_inset

Thor
\begin_inset Quotes erd
\end_inset

.
 You see we used JsRaw class which basically renders the exact thing you
 are passing to it; which is raw JavaScript code.
\end_layout

\begin_layout Subsection
JSON forms
\end_layout

\begin_layout Standard
This feature is about sending the fields of a forms to the server.
 The data sent to the server is a JSON object which is the form content
 representation formatted as a JSON structure.
 Then next question is how are we going to easily process this JSON string
 on server side? ...
 well Lift has these artifacts called JsonHandler.
 But let's first see an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
JSON form
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Assume we have this template
\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">      
\end_layout

\begin_layout Plain Layout

	<lift:JSONForm.head />      
\end_layout

\begin_layout Plain Layout

	<lift:JSONForm.show>
\end_layout

\begin_layout Plain Layout

	  <input type="text" name="name" />
\end_layout

\begin_layout Plain Layout

	  <br />
\end_layout

\begin_layout Plain Layout

	  <input type="text" name="value" /> 
\end_layout

\begin_layout Plain Layout

	  <br />  
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Bike" /> 
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Car" /> 
\end_layout

\begin_layout Plain Layout

	  <input type="radio" name="vehicle" value="Airplane" /> 
\end_layout

\begin_layout Plain Layout

	  <br /> 
\end_layout

\begin_layout Plain Layout

	  <select name="cars">
\end_layout

\begin_layout Plain Layout

	    <option value="volvo">Volvo</option> 
\end_layout

\begin_layout Plain Layout

		<option value="saab">Saab</option> 
\end_layout

\begin_layout Plain Layout

		<option value="opel">Opel</option>  
\end_layout

\begin_layout Plain Layout

	    <option value="audi">Audi</option>  
\end_layout

\begin_layout Plain Layout

	  </select>
\end_layout

\begin_layout Plain Layout

	  <button type="submit">Submit</button>
\end_layout

\begin_layout Plain Layout

	</lift:JSONForm.show>
\end_layout

\begin_layout Plain Layout

	<div id="json_result"></div> 
\end_layout

\begin_layout Plain Layout

</lift:surround>  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// And the Snippet code
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class JSONForm {      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def show(html: Group): NodeSeq = {
\end_layout

\begin_layout Plain Layout

		jsonForm(json, html) // we just wrap the snippet content into relevant
 form code 
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	import JsCmds._ 
\end_layout

\begin_layout Plain Layout

	object json extends JsonHandler {
\end_layout

\begin_layout Plain Layout

		def apply(in: Any): JsCmd = SetHtml("json_result", in match { 
\end_layout

\begin_layout Plain Layout

			case j @ JsonCmd("processForm", _, p: Map[String, _], _) => {
\end_layout

\begin_layout Plain Layout

				// process the form or whatever 
\end_layout

\begin_layout Plain Layout

				println("Cars = " + urlDecode(p("cars"))) 
\end_layout

\begin_layout Plain Layout

				println("Name = " + urlDecode(p("name"))) 
\end_layout

\begin_layout Plain Layout

				<b>{p}</b> 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			case x => <b>Problem...
 didn't handle JSON message {x}</b>
\end_layout

\begin_layout Plain Layout

		})
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def head = <head>{Script(json.jsCmd)}</head> 
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all the XHTML template is preety straight forward.
 It calls the JSONForm.head function which returns the JavaScript code that
 basically declares the function that is sending the Ajax JSON requst.
 The show function basically wraps the content of the snippet between <form>
 tag and sets the onsubmit event such as when the submit button is pressed,
 instead of submitting the form an Ajax call is set to server containing
 the JSON object that contains the form information.
 On server side Lif is automatically parsing the JSON construct and calls
 the apply function of our 
\family typewriter
json
\family default
 object (which is a JsonHandler).
 The apply function needs to return a JsCmd (JavaScript code) ehich in this
 case it sets the HTML content of the 
\family typewriter
json_result
\family default
 div element.
 When the form is strinigified into its JSON representation Lift uses a
 command property indicating the action that needs to be done on server
 and the actual JSON data.
 In the case of JSON forms the command is always 
\begin_inset Quotes eld
\end_inset

processForm
\begin_inset Quotes erd
\end_inset

 as this is important for pattern matching as seen above.
 The actuall form content is a Map object that can be easily use toobtain
 the values for each form field.
\end_layout

\end_body
\end_document
