#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
% "define" Scala
\lstdefinelanguage{scala}{morekeywords={class,object,trait,extends,with,new,if,while,for,def,val,var},sensitive=true,morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]"}

% Default settings for code listings
\lstset{frame=single,frameround=tttt,language=scala}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
The Mapper and Record Frameworks
\begin_inset LatexCommand label
name "cha:mapper_and_record"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
TODO:Link types to Java/ScalaDoc with footnotes where possible
\end_layout

\begin_layout Standard
Update Mapper section with IdPk (make sure I'm doing PK setup correctly
 even when not using IdPk)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Usually we find that most webapps end up wanting to store user data somewhere.
 Once you start working with user data, though, you start dealing with issues
 like coding up input forms, validation
\begin_inset LatexCommand index
name "validation"

\end_inset

, persistence, etc to handle the data.
 That's where the Mapper and Record frameworks comes in.
 These frameworks provides a scaffolding for all of your data manipulation
 needs.
 Mapper is the original Lift persistence framework, and is closely tied
 to JDBC for its storage.
 Record is a new refactorization of Mapper that is backing-store agnostic
 at its core, so it doesn't matter whether you want to save your data to
 JDBC, JPA, or even something like XML.
 With Record, selecting the proper driver is as simple as hooking the proper
 traits into your class.
 Because these frameworks are based on the same concepts, we will be covering
 them in parallel in this chapter.
\end_layout

\begin_layout Standard
\begin_inset Note Framed
status open

\begin_layout Standard
Unless we note otherwise, functionality for each framework is the same.
 We will point out minor differences like method names inline, while major
 differences will be covered in their own sections.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction to Mapper and MetaMapper
\end_layout

\begin_layout Standard
Let's start by discussing the relationship between the Mapper
\begin_inset LatexCommand index
name "Mapper"

\end_inset

 and MetaMapper
\begin_inset LatexCommand index
name "MetaMapper"

\end_inset

 traits (and the corresponding Record
\begin_inset LatexCommand index
name "Record"

\end_inset

 and MetaRecord
\begin_inset LatexCommand index
name "MetaRecord"

\end_inset

).
 Mapper provides the 
\emph on
per-instance
\emph default
 functionality for your class, while MetaMapper handles the 
\emph on
global
\emph default
 operations for your class and provides a common location to define per-class
 static specializations of things like field order, form generation and
 HTML representation.
 In fact, many of the Mapper methods actually delegate to methods on MetaMapper.
 In addition to Mapper and MetaMapper there is a third trait, MappedField,
 that provides the per-field functionality for your class.
 In Record the trait is simply called 
\begin_inset Quotes eld
\end_inset

Field
\begin_inset Quotes erd
\end_inset

.
 The MappedField trait lets you define the individual validators as well
 as things transform filters and filed name.
 Under Record, Field adds things like tab order and default error messages
 for form input handling.
\end_layout

\begin_layout Subsection
Setting Up the Database Connection
\end_layout

\begin_layout Standard
The first step you need to get out of the way is defining the database connectio
n.
 We do this by defining an object called 
\family typewriter
DBVendor
\family default
 (you can call it whatever you want).
 This object extends the net.liftweb.mapper.ConnectionManager trait and must
 implement two methods: newConnection and releaseConnection.
 You can make this as sophisticated as you want, with pooling, caching,
 etc, but for now, listing 
\begin_inset LatexCommand ref
reference "lst:Setting-up-the-database"

\end_inset

shows a basic implementation to set up a PostgreSQL driver.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting up the Database
\begin_inset LatexCommand label
name "lst:Setting-up-the-database"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object DBVendor extends ConnectionManager {
\end_layout

\begin_layout Standard

  // Force load the driver
\end_layout

\begin_layout Standard

  Class.forName("org.postgresql.Driver")
\end_layout

\begin_layout Standard

  // define methods
\end_layout

\begin_layout Standard

  def newConnection(name : ConnectionIdentifier) = {
\end_layout

\begin_layout Standard

    try {
\end_layout

\begin_layout Standard

      Full(DriverManager.getConnection(
\end_layout

\begin_layout Standard

           "jdbc:postgresql://localhost/mydatabase",
\end_layout

\begin_layout Standard

           "root", "secret"))
\end_layout

\begin_layout Standard

    } catch {
\end_layout

\begin_layout Standard

      case e : Exception => e.printStackTrace; Empty
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  def releaseConnection (conn : Connection) { conn.close }
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

DB.defineConnectionManager(DefaultConnectionIdentifier, DBVendor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few items to note:
\end_layout

\begin_layout Enumerate
The name parameter for newConnection can be used in case you need to have
 connections to multiple distinct databases.
 One specialized case of this is when you're doing DB sharding (horizontal
 scaling).
 Multiple database usage is covered in more depth in section 
\begin_inset LatexCommand ref
reference "sub:Multiple-Databases"

\end_inset


\end_layout

\begin_layout Enumerate
The newConnection method needs to return a Can[java.sql.Connection].
 Returning an Empty Can indicates failure
\end_layout

\begin_layout Enumerate
The releaseConnection method exists so that you have complete control over
 the lifecycle of the connection.
 For instance, if you were doing connection pooling yourself you would return
 the connection to the available pool rather than closing it
\end_layout

\begin_layout Enumerate
The DB.defineConnectionManager call is what binds our manager into Mapper.
 Without it your manager will never get called
\end_layout

\begin_layout Subsection
Constructing a Mapper-enabled class
\end_layout

\begin_layout Standard
Now that we've covered some basic background, we can start constructing
 some Mapper classes to get more familiar with the framework.
 We'll start with a simple example of a class for a ledger entry with the
 following fields:
\end_layout

\begin_layout Itemize
Date
\end_layout

\begin_layout Itemize
Description, with a max length of 100 chars
\end_layout

\begin_layout Itemize
Amount, a decimal value with a precsion of two places.
\end_layout

\begin_layout Standard
The first thing we do is declare our Entry class, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Entry-class-mapper"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Entry class in Mapper
\begin_inset LatexCommand label
name "lst:Entry-class-mapper"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class MapEntry extends KeyedMapper[Long,MapEntry] {
\end_layout

\begin_layout Standard

  def getSingleton = MapEntryMeta
\end_layout

\begin_layout Standard

  def primaryKeyField = id
\end_layout

\begin_layout Standard

  object id extends MappedLongIndex(this)
\end_layout

\begin_layout Standard

  object date extends MappedDateTime(this)
\end_layout

\begin_layout Standard

  object description extends MappedString(this,100)
\end_layout

\begin_layout Standard

  // 2 digits to the right
\end_layout

\begin_layout Standard

  object amount extends MappedDecimal(this,2)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Record version is shown in listing 
\begin_inset LatexCommand ref
reference "lst:Entry-class-record"

\end_inset

; the only differences are that the 
\family typewriter
getSingleton
\family default
 method has been renamed to 
\family typewriter
meta
\family default
, and the Field traits use different names under the Record framework (DateTimeF
ield vs MappedDateTime).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Entry class in Record
\begin_inset LatexCommand label
name "lst:Entry-class-record"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Entry extends KeyedRecord[Entry,Long] {
\end_layout

\begin_layout Standard

  def meta = EntryMeta
\end_layout

\begin_layout Standard

  def primaryKey = id
\end_layout

\begin_layout Standard

  object id extends LongField(this) with KeyField[Long,Entry]
\end_layout

\begin_layout Standard

  object date extends DateTimeField(this)
\end_layout

\begin_layout Standard

  object description extends StringField(this, 100)
\end_layout

\begin_layout Standard

  // 2 digits to the right
\end_layout

\begin_layout Standard

  object amount extends DecimalField(this, 2)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, we've set Entry to extend the KeyedMapper trait (we need
 to tell Mapper what the subtype is) and we've added the fields required
 by our class.
 We need to provide a primary key on the entity, so we use the KeyedMapper
\begin_inset LatexCommand index
name "KeyedMapper"

\end_inset

 trait instead of Mapper (or, correspondingly, KeyedRecord
\begin_inset LatexCommand index
name "KeyedRecord"

\end_inset

 instead of Record).
 When you use the KeyedMapper trait you need to provide an implementation
 for the primaryKeyField def, which must match the type of the KeyedMapper
 trait and be a subtype of IndexedField
\begin_inset LatexCommand index
name "IndexedField"

\end_inset

.
 Currently, Mapper supports both indexed Longs and Strings, so if you want
 to use some other type for your primary key you'll need to roll your own
 (section 
\begin_inset LatexCommand ref
reference "sub:Defining-Custom-Field-types-mapper"

\end_inset

).
 Technically Int indexes are supported as well, but there is no corresponding
 trait for an Int foreign key.
 That means that if you use an Int for the primary key you may not be able
 to do a relationship with other objects (section 
\begin_inset LatexCommand ref
reference "sub:Object-Relationships"

\end_inset

) unless you write your own.
 Record is a little more flexible in primary key selection since it uses,
 in effect, a marker trait (KeyField) to indicate that a particular field
 is a key field.
 One thing to note is that in Mapper, the table name
\begin_inset LatexCommand index
name "table name"

\end_inset

 foryour entity defaults to the name of the class (Entry in our case).
 If you want to change this then you just need to override the dbTableName
\begin_inset LatexCommand index
name "dbTableName"

\end_inset

 def.
\end_layout

\begin_layout Standard
Looking at these examples, you've probably noticed that the fields are defined
 as objects rather than instance members (vars).
 The basic reason for this is that the MetaMapper needs access to fields
 for its validation and form functionality; it wouldn't be possible to cleanly
 define these properties in the MetaMapper if it had to access member vars
 on each instance since a MetaMapper instance is itself an object.
 Also note that DecimalField is a custom field type, which we will cover
 in section 
\begin_inset LatexCommand ref
reference "sub:Defining-Custom-Field-types-record"

\end_inset

.
\end_layout

\begin_layout Standard
In order to tie all of this together, we need to define a matching KeyedMetaMapp
er
\begin_inset LatexCommand index
name "KeyedMetaMapper"

\end_inset

 object as the singleton for our entity, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:EntryMeta-object"

\end_inset

.
 The Meta object (whether MetMapper or MetaRecord) is where you define most
 behavior that is common across all of your instances.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
EntryMeta object
\begin_inset LatexCommand label
name "lst:EntryMeta-object"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object EntryMeta extends Entry with KeyedMetaMapper[Long,Entry] {
\end_layout

\begin_layout Standard

  override def fieldOrder = List(date, description, amount)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our case we're simply defining the order of fields as they'll be displayed
 in XHTML
\begin_inset LatexCommand index
name "XHTML"

\end_inset

 and forms
\begin_inset LatexCommand index
name "form"

\end_inset

 by overriding the 
\family typewriter
fieldOrder
\family default
 method.
 The default behavior is an empty list, which means no fields are involved
 in display or form generation; generally you will want to override 
\family typewriter
fieldOrder
\family default
 since this is not very useful.
 If you don't want a particular field to show up in forms or XHTML output,
 simply omit it from the fieldOrder
\begin_inset LatexCommand index
name "fieldOrder"

\end_inset

 list.
\end_layout

\begin_layout Standard
Since fields aren't actually instance members, operations on them are slightly
 different that a regular var.
 The biggest difference is in how we set fields: we use the apply method.
 In addition, field access can be chained so that you can set multiple field
 values in one statement, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Setting-field-values"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting field values
\begin_inset LatexCommand label
name "lst:Setting-field-values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.date(new Date).description("A sample entry")
\end_layout

\begin_layout Standard

myEntry.amount("127.20")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The underlying value of a given field can be retrieved with the 
\family typewriter
is
\family default
 method (
\family typewriter
value
\family default
 method in Record) as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Accessing-field-values"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Accessing field values in Record
\begin_inset LatexCommand label
name "lst:Accessing-field-values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

// mapper
\end_layout

\begin_layout Standard

val tenthOfAmount = myEntry.amount.is / 10
\end_layout

\begin_layout Standard

val formatted = String.format("%s : %s",
\end_layout

\begin_layout Standard

                              myEntry.description.is,
\end_layout

\begin_layout Standard

                              myEntry.amount.is.toString)
\end_layout

\begin_layout Standard

// record
\end_layout

\begin_layout Standard

if (myEntry.description.value == "Doughnuts") {
\end_layout

\begin_layout Standard

  println("Diet ruined!")
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object Relationships
\begin_inset LatexCommand label
name "sub:Object-Relationships"

\end_inset


\end_layout

\begin_layout Standard
Often it's appropriate to have relationships between different entities.
 The archetypical example of this is the parent-child relationship.
 In SQL, a relationship can be defined with a foreign key that associates
 one table to another based on the primary key of the associated table.
 In Mapper, there is a corresponding MappedForeignKey trait, with concrete
 implementations for Long and String foreign keys.
 To give an example, our ledger entries should be owned by a particular
 user.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Foreign-Key-Definition"

\end_inset

 shows a rough User entity definition along with the addition of the MappedForei
gnKey field on our existing Ledger class to specify a one-to-many from User
 to Entry.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Foreign Key Definition
\begin_inset LatexCommand label
name "lst:Foreign-Key-Definition"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class User extends KeyedMapper[Long,User] {
\end_layout

\begin_layout Standard

  def getSingleton = UserMeta // not shown here
\end_layout

\begin_layout Standard

  def primaryKeyField = id
\end_layout

\begin_layout Standard

  object id extends MappedLongIndex(this)
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

class Entry extends KeyedMapper[Long,Entry] {
\end_layout

\begin_layout Standard

  ...
\end_layout

\begin_layout Standard

  object owner extends MappedLongForeignKey(this,UserMeta)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we have this defined, accessing the object via the relationship is
 achieved by using the obj method on the foreign key field, as shown in
 listing 
\begin_inset LatexCommand ref
reference "lst:Accessing-Foreign-Objects"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Accessing Foreign Objects
\begin_inset LatexCommand label
name "lst:Accessing-Foreign-Objects"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Entry extends KeyedMapper[Long,Entry] {
\end_layout

\begin_layout Standard

 ...
\end_layout

\begin_layout Standard

 def parentName = Text("My parent is " + owner.obj.name.is)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the foreign key functionality you can easily do one-to-many and many-to-one
 relationships (depending on where you put the foreign key).
 If you want to do many-to-many mappings you'll need to provide your own
 
\begin_inset Quotes eld
\end_inset

join
\begin_inset Quotes erd
\end_inset

 class with foreign keys to both of your mapped entities.
 An example would be if we wanted to have categories for our ledger entries
 and wanted to be able to have a given entry have multiple categories (i.e.
 you purchase a book for your mother's birthday, so it has the categories
 Gift, Mom and Books).
 First we define the category entity, as shown in listing
\begin_inset LatexCommand ref
reference "lst:Category-Entity"

\end_inset

 .
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Category Entity
\begin_inset LatexCommand label
name "lst:Category-Entity"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Category extends KeyedMapper[Long,Category] {
\end_layout

\begin_layout Standard

  def getSingleton = CategoryMeta
\end_layout

\begin_layout Standard

  def primaryKeyField = id
\end_layout

\begin_layout Standard

  object id extends MappedLongIndex(this)
\end_layout

\begin_layout Standard

  object name extends MappedString(this,100)
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

object CategoryMeta extends Category with KeyedMetaMapper[Long,Category]
 {
\end_layout

\begin_layout Standard

  override def fieldOrder = List(name)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we define our join entity, as shown in listing .
 It's a KeyedMapper just like the rest of the entities, but it only contains
 foreign key fields to the other entities.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Join Entity
\begin_inset LatexCommand label
name "lst:Join-Entity"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class CategoryEntry extends KeyedMapper[Long,CategoryEntry] {
\end_layout

\begin_layout Standard

  ...
 singleton, primary key defs here ...
\end_layout

\begin_layout Standard

  object entry extends MappedLongForeignKey(this,EntryMeta)
\end_layout

\begin_layout Standard

  object category extends MappedLongForeignKey(this,CategoryMeta)
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

object CategoryEntryMeta extends CategoryEntry with KeyedMetaMapper[Long,Categor
yEntryMeta] {
\end_layout

\begin_layout Standard

  def join (category : Category, entry : Entry) = {
\end_layout

\begin_layout Standard

    val joiner = this.create
\end_layout

\begin_layout Standard

    joiner.entry(entry)
\end_layout

\begin_layout Standard

    joiner.category(category)
\end_layout

\begin_layout Standard

    joiner
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To use the join entity, you'll need to create a new instance and set the
 appropriate foreign keys to point to the associated instances.
 As you can see, we've defined a convenience method on out CategoryJoinMeta
 object to do just that.
 To make the many-to-many accessible as a field on our entities, we can
 use the HasManyThrough trait, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:HasManyThrough-for-Many-to-Many"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
HasManyThrough for Many-to-Many Relationships
\begin_inset LatexCommand label
name "lst:HasManyThrough-for-Many-to-Many"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object categories extends 
\end_layout

\begin_layout Standard

  HasManyThrough(this,
\end_layout

\begin_layout Standard

                 CategoryMeta,
\end_layout

\begin_layout Standard

                 CategoryEntryMeta,
\end_layout

\begin_layout Standard

                 CategoryEntryMeta.entry,
\end_layout

\begin_layout Standard

                 CategoryEntryMeta.category)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A similar field could be set up on the Category entity to point to entries.
 It's important to note a few items:
\end_layout

\begin_layout Itemize
The only way to add new entries is to directly construct the CategoryEntry
 instances and save them.
 You can't make any modifications via the HasManyThrough trait
\end_layout

\begin_layout Itemize
Although the field is defined as a query, the field is actually lazy and
 only runs once.
 That means if you query it and then add some new CategoryEntry instances,
 they won't show up in the field contents
\end_layout

\begin_layout Standard
If you want a way to retrieve the joined results such that it pulls fresh
 from the database each time, you can instead define a helper method as
 shown in listing 
\begin_inset LatexCommand vref
reference "lst:Convenience-methods"

\end_inset

.
\end_layout

\begin_layout Subsection
Persistence Operations on an Entity
\end_layout

\begin_layout Standard
Now that we've defined our entity we probably want to use it in the real
 world to load and store data.
 There are several operations on KeyedMetaMapper that we can use :
\end_layout

\begin_layout Description
create Creates a new instance of the entity
\end_layout

\begin_layout Description
save Saves an instance to the database.
\end_layout

\begin_layout Description
delete Deletes the given entity instance
\end_layout

\begin_layout Description
find* A whole host of means for locating entities, by primary key, typesafe
 queries, raw SQL queries, etc.
 These will be covered in detail in their own section, 
\begin_inset LatexCommand ref
reference "sub:Querying-for-Entities"

\end_inset


\end_layout

\begin_layout Standard
In general these operations will be supported in both Record and Mapper.
 However, because Record isn't coupled tightly to a JDBC backend some of
 the find methods may not be supported and there may be additional methods
 not available in Mapper for persistence.
 For this reason, this section will deal specifically with Mapper's persistence
 operations; Record's backends and their supported operations are covered
 in section 
\begin_inset LatexCommand ref
reference "sec:Record-Backends"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Creating an Instance
\end_layout

\begin_layout Standard
Once we have the KeyedMetaMapper object defined we can use it to create
 objects using the 
\family typewriter
create
\begin_inset LatexCommand index
name "create"

\end_inset


\family default
 method.
 You can't just use the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 operator because the framework has to set up internal data for the instance
 such as field owner, etc.
 This is important to remember, since nothing will prevent you from creating
 an instance manually; you'll just get all kinds of errors when you go to
 use the instance.
\end_layout

\begin_layout Subsubsection*
Saving an Instance
\end_layout

\begin_layout Standard
Saving an instance is as easy as calling the 
\family typewriter
save
\family default
 method on the instance you want to save.
 Optionally, you can call the 
\family typewriter
save
\family default
 method on the Meta object, passing in the instance you want to save.
 The save method uses the id field to determine whether an insert or update
 is required to persist the current state to the database, and returns a
 boolean to indicate whether the save was successful or not.
\end_layout

\begin_layout Subsubsection*
Deleting an Instance
\begin_inset LatexCommand label
name "sub:Deleting-an-Instance"

\end_inset


\end_layout

\begin_layout Standard
There are several ways to delete instances.
 The simplest way is to call the 
\family typewriter
delete_!
\family default
 method on the instance you'd like to remove.
 An alternative is to call the 
\family typewriter
delete_!
\family default
 method on the Meta object, passing in the instance to delete.
 In either case, the 
\family typewriter
delete_!
\family default
 method returns a boolean indicating whether the delete was successful or
 not.
\end_layout

\begin_layout Standard
Another approach to deleting entities is to use the 
\family typewriter
bulkDelete_!!
\family default
 method on MetaMapper.This method allows you to specify query parameters
 to control which entities are deleted.
 We will cover query parameters in section 
\begin_inset LatexCommand ref
reference "sub:Querying-for-Entities"

\end_inset

 (an example is in listing 
\begin_inset LatexCommand vref
reference "lst:Bulk-Deletion"

\end_inset

).
\end_layout

\begin_layout Subsection
Querying for Entities
\begin_inset LatexCommand label
name "sub:Querying-for-Entities"

\end_inset


\end_layout

\begin_layout Standard
There are a variety of methods on MetaMapper for querying for instances
 of a given entity.
 The simplest method is 
\family typewriter
findAll
\family default

\begin_inset LatexCommand index
name "findAll"

\end_inset

 called with no parameters.
 The 
\begin_inset Quotes eld
\end_inset

bare
\begin_inset Quotes erd
\end_inset

 
\family typewriter
findAll
\family default
 returns a List of all of the instances of a given entity loaded from the
 database.
 Note that each findAll...
 method has a corresponding method that takes a database connection for
 sharding or multiple database usage (see sharding in section 
\begin_inset LatexCommand ref
reference "sub:Multiple-Databases"

\end_inset

).
 Of course, for all but the smallest datasets, pulling the entire model
 to get one entity from the database is inefficient and slow.
 Instead, the MetMapper provides methods for using queries to narrow the
 set of entities returned.
 
\end_layout

\begin_layout Standard
The ability to use fine-grained queries to select data is a fundamental
 feature of relational databases, and Mapper provides first-class support
 for constructing queries in a manner that is not only easy to use, but
 type-safe.
 This means that you can catch query errors at compile time instead of runtime.
 The basis for this functionality is the QueryParam trait, which has several
 concrete implementations that are used to construct the actual query.
 The QueryParam impls can be broken up into two main groups:
\end_layout

\begin_layout Enumerate
Comparison - These are typically items that would go in the where clause
 of an SQL query.
 They are used to refine the set of instances that will be returned
\end_layout

\begin_layout Enumerate
Control - These are items that control things like sort order and pagination
 of the results
\end_layout

\begin_layout Standard
Although Mapper provides a large amount of the functionality in SQL, some
 features are not covered directly or at all.
 In some cases we can define helper methods to make querying easier, particularl
y for joins (section 
\begin_inset LatexCommand ref
reference "sub:helper-joins"

\end_inset

).
\end_layout

\begin_layout Standard
The simplest QueryParam to refine your query is the By
\begin_inset LatexCommand index
name "By"

\end_inset

 object, and its related objects.
 By is used for a direct value comparison of a given field, essentially
 an 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 in SQL.
 For instance, to get an instance of our ledger entry by its primary key,
 we use findAll as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Retrieving-by-Primary-key"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Retrieving by Primary Key
\begin_inset LatexCommand label
name "lst:Retrieving-by-Primary-key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val myEntry = EntryMeta.findAll(By(Entry.id, myId)).firstOption
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, we use the firstOption to convert from a List to an Option.
 If the Option is None it means that the entity could not be loaded.
 Loading a single entity is somewhat of a special case, but in this example
 we're selecting on the primary key, which has a unique constraint and thus
 should return either one entity or none (perfect for an Option).
 Besides By, the other basic clauses are:
\end_layout

\begin_layout Itemize
NotBy
\begin_inset LatexCommand index
name "NotBy"

\end_inset

 - Selects entities whose queried field is not equal to the given value
\end_layout

\begin_layout Itemize
By_>
\begin_inset Note Note
status open

\begin_layout Standard
Add index entry
\end_layout

\end_inset

 - Selects entities whose queried field is larger than the given value
\end_layout

\begin_layout Itemize
By_<
\begin_inset Note Note
status open

\begin_layout Standard
Add index entry
\end_layout

\end_inset

- Selects entities whose queried field is less than the given value
\end_layout

\begin_layout Itemize
ByList
\begin_inset LatexCommand index
name "ByList"

\end_inset

 - Selects entities whose queried field is equal to one of the values in
 the given List.
 This corresponds to the 
\begin_inset Quotes eld
\end_inset

field IN (x,y,z)
\begin_inset Quotes erd
\end_inset

 syntax in SQL.
\end_layout

\begin_layout Itemize
NullRef
\begin_inset LatexCommand index
name "NullRef"

\end_inset

 - Selects entities whose queried field is NULL
\end_layout

\begin_layout Itemize
NotNullRef
\begin_inset LatexCommand index
name "NotNullRef"

\end_inset

 - Select entities whose queried field is not NULL
\end_layout

\begin_layout Itemize
Like
\begin_inset LatexCommand index
name "Like"

\end_inset

 - Select entities whose queried field is like the given string.
 As in SQL, the percent sign is used as a wildcard
\end_layout

\begin_layout Standard
In addition to the basic clauses there are some slightly more complex ways
 to control the query.
 The first of these is ByRef
\begin_inset LatexCommand index
name "ByRef"

\end_inset

, which selects entities whose queried field is equal to the value of another
 query field 
\emph on
on the same entity
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Standard
Is there an example?
\end_layout

\end_inset

.
 The related NotByRef tests for inequality between two query fields.
\end_layout

\begin_layout Standard
Getting slightly more complex, we come to the In
\begin_inset LatexCommand index
name "In"

\end_inset

 QueryParameter, which is used just like an 
\begin_inset Quotes eld
\end_inset

IN
\begin_inset Quotes erd
\end_inset

 clause with a subselect in an SQL statement.
 As a totally contrived example 
\begin_inset Note Note
status open

\begin_layout Standard
Can we think of a better one?
\end_layout

\end_inset

, let's say we wanted to get all of the entries that belong to categories
 that start with the letter 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Using-In"

\end_inset

 shows the full breakdown.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using In
\begin_inset LatexCommand label
name "lst:Using-In"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

EntryMeta.findAll(
\end_layout

\begin_layout Standard

  ByRef(EntryMeta.id, CategoryJoinMeta.entry),
\end_layout

\begin_layout Standard

  In(CategoryJoinMeta.category,
\end_layout

\begin_layout Standard

     CategoryMeta.id,
\end_layout

\begin_layout Standard

     Like(CategoryMeta.name, "c%")))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use the ByRef params to do the join between the many-to-many entity on
 the query.
 Related to In is InRaw
\begin_inset LatexCommand index
name "InRaw"

\end_inset

, which allows you to specify your own SQL subquery for the 
\begin_inset Quotes eld
\end_inset

IN
\begin_inset Quotes erd
\end_inset

 portion of the where clause.
 An example in listing 
\begin_inset LatexCommand ref
reference "lst:Using-InRaw"

\end_inset

 shows how we could use this to find Categories for ledger entries made
 in the last 30 days.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using InRaw
\begin_inset LatexCommand label
name "lst:Using-InRaw"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def recentCategories = {
\end_layout

\begin_layout Standard

  val joins = CategoryJoinMeta.findAll(
\end_layout

\begin_layout Standard

    InRaw(CategoryJoinMeta.entry,
\end_layout

\begin_layout Standard

          "select id from Entry where Entry.date > (CURRENT_DATE - interval
 '30 days')",
\end_layout

\begin_layout Standard

          IHaveValidatedThisSQL("dchenbecker", "2008-12-03"))
\end_layout

\begin_layout Standard

  joins.map(_.category.obj).sort(_.id < _.id).removeDuplicates
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here things are starting to get a little hairy 
\begin_inset Note Note
status open

\begin_layout Standard
Is there a better way to do this?
\end_layout

\end_inset

.
 The InRaw only allows us to specify the subquery for the IN clause, so
 we have to do some postprocessing to get unique results.
 If you want to do this in the query itself you'll have to use the findAllByInse
cureSql or findAllByPreparedStatement methods, which are covered later in
 this section on page 
\begin_inset LatexCommand pageref
reference "sub:SQL-based-queries"

\end_inset

.
 The final parameter for InRaw acts as a code audit mechanism that says
 that someone has checked the SQL to make sure it's safe to use.
 Since the query fragment is added to the master query as-is, no escaping
 or other filtering is performed on the string.
 That means that if you take user input you need to be very careful about
 it or you run the risk of an SQL injection attack on your site.
\end_layout

\begin_layout Standard
The next QueryParam we'll cover is BySql, which lets you use a complete
 SQL fragment that gets put into the where clause.
 An example of this would be if we want to find all ledger entries within
 the last 30 days, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Using-BySql"

\end_inset

.
 The IHaveValidatedThieSQL case class is required as a code audit mechanism
 to make sure someone has verified that the SQL used is safe.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using BySql
\begin_inset LatexCommand label
name "lst:Using-BySql"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val recentEntries = EntryMeta.findAll(
\end_layout

\begin_layout Standard

  BySql("Entry.date > (CURRENT_DATE - interval '30 days')",
\end_layout

\begin_layout Standard

        IHaveValidatedThisSQL("dchenbecker","2008-12-03"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The tradeoff with using BySql is that you need to be careful with what you
 allow into the query string.
 BySql supports parameterized queries as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Parameterized-BySql"

\end_inset

, so use those if you need to have dynamic queries.
 Whatever you do, don't use string concatenation unless you really know
 what you're doing.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Parameterized BySql
\begin_inset LatexCommand label
name "lst:Parameterized-BySql"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val amountRange = EntryMeta.findAll(
\end_layout

\begin_layout Standard

  BySql("Entry.amount between ? and ?", lowVal, highVal))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we mentioned in section 
\begin_inset LatexCommand vref
reference "sub:Deleting-an-Instance"

\end_inset

, we can use the query parameters to effect bulk deletes in addition to
 querying for instances.
 Simply use the QueryParam classes to constrain what you want to delete.
 Obviously the control params that we'll cover next make no sense but the
 compiler won't complain 
\begin_inset Note Note
status open

\begin_layout Standard
Will the delete work, though?
\end_layout

\end_inset

.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Bulk-Deletion"

\end_inset

 shows an example of deleting all entries older than a certain date.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Bulk Deletion
\begin_inset LatexCommand label
name "lst:Bulk-Deletion"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def deleteBefore (date : Date) = 
\end_layout

\begin_layout Standard

  EntryMeta.bulkDelete_!!(By_<(EntryMeta.date, date))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now that we've covered the selection and comparison QueryParams, we can
 start to look at the control params.
 The first one that we'll look at is OrderBy.
 This operates exactly like the order by clause in SQL, and allows you to
 order on a given field in either ascending or descending order.
 Listing 
\begin_inset LatexCommand ref
reference "lst:OrderBy-Clause"

\end_inset

 shows an example of ordering our ledger entries by amount.
 The Ascending and Descending case objects are in the net.liftweb.mapper package.
 The OrderBySql case class operates similarly except you provide your own
 SQL fragment for the ordering, as shown in the example.
 Again, you need to validate this SQL.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
OrderBy Clause
\begin_inset LatexCommand label
name "lst:OrderBy-Clause"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val cheapestFirst = 
\end_layout

\begin_layout Standard

  EntryMeta.findAll(OrderBy(EntryMeta.amount,Ascending))
\end_layout

\begin_layout Standard

// or
\end_layout

\begin_layout Standard

val cheapestFirst = 
\end_layout

\begin_layout Standard

  EntryMeta.findAll(OrdeBySql("Entry.amount asc"),
\end_layout

\begin_layout Standard

    IHaveValidatedThisSQL("dchenbecker", "2008-12-03"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pagination of results is another feature that people often want to use,
 and Mapper provides a simple means for controlling it with two more QueryParam
 classes: StartAt and MaxRows, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Pagination-of-Results"

\end_inset

.
 In this example we take the offset from a parameter passed to our snippet,
 with a default of zero.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Pagination of Results
\begin_inset LatexCommand label
name "lst:Pagination-of-Results"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val offset = S.param("offset").map(_.toLong) openOr 0
\end_layout

\begin_layout Standard

EntryMeta.findAll(StartAt(offset), MaxRows(20))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An important feature of the methods that take QueryParams is that they can
 take multiple params, as shown in this example.
 A more complex example is shown in listing 
\begin_inset LatexCommand ref
reference "lst:Multiple-QueryParams"

\end_inset

.
 In this example we're doing a query using a Like clause, ordering on the
 date of the entries, and paginating the results, all in one statement!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Multiple QueryParams
\begin_inset LatexCommand label
name "lst:Multiple-QueryParams"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

EntryMeta.findAll(Like(EntryMeta.description, "Gift for%"),
\end_layout

\begin_layout Standard

                  OrderBy(EntryMeta.date,Descending),
\end_layout

\begin_layout Standard

                  StartAt(offset),
\end_layout

\begin_layout Standard

                  MaxRows(pageSize))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another useful QueryParam is the Distinct case class, which acts exactly
 the same way as the DISTINCT keyword in SQL.
 The final 
\begin_inset Quotes eld
\end_inset

control
\begin_inset Quotes erd
\end_inset

 QueryParam that we'll cover is PreCache
\begin_inset LatexCommand index
name "PreCache"

\end_inset

.
 It's used when you have a mapped foreign key field on an entity.
 Normally, when Mapper loads your main entity it leaves the foreign key
 field in a lazy state, so that the query to get the foreign object isn't
 executed until you access the field.
 This can obviously be inefficient when you have a whole lot of entities
 loaded that you need to access, so the PreCache parameter forces Mapper
 to preload the foreign objects as part of the query.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Using-PreCache"

\end_inset

 shows how we could use this to fetch a ledger entry as well as the owner
 of the entry (we would need to set up an owner field for this example to
 work).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using PreCache
\begin_inset LatexCommand label
name "lst:Using-PreCache"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def loadEntry (id : Long) =
\end_layout

\begin_layout Standard

  EntryMeta.findAll(By(EntryMeta.id, id),
\end_layout

\begin_layout Standard

                    PreCache(EntryMeta.owner))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Making Joins a Little Friendlier
\begin_inset LatexCommand label
name "sub:helper-joins"

\end_inset


\end_layout

\begin_layout Standard
In case you would prefer to keep your queries type-safe but you want a little
 more convenience in your joins between entities, you can define helper
 methods on your entities.
 One example would be finding all of the Categories for a given Entry, as
 shown in listing 
\begin_inset LatexCommand pageref
reference "lst:Join-Convenience-Method"

\end_inset

.
 Using this method in our example has an advantage over using HasManyThrough
 in that it will pull from the database each time instead of just once at
 query.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Join Convenience Method
\begin_inset LatexCommand label
name "lst:Join-Convenience-Method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def categoriesPull = CategoryEntryMeta.
\end_layout

\begin_layout Standard

  findAll(By(CategoryEntryMeta.entry, this.id)).map(_.category.obj)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Utility Functionality
\end_layout

\begin_layout Standard
In addition to the first-class persistence support in Mapper and Record,
 the frameworks provide additional functionality to make writing data-driven
 applications much simpler.
 This includes things like automatic XHtml representation of objects and
 support for generating everything from simple forms for an entity up to
 a full-fledged CRUD
\begin_inset Foot
status collapsed

\begin_layout Standard
An abbreviation (Create, Read, Update and Delete) representing the standard
 operations that are performed on database records.
 Taken from 
\begin_inset LatexCommand htmlurl
target "http://provost.uiowa.edu/maui/Glossary.html"

\end_inset


\end_layout

\end_inset

 implementation for your entities.
\end_layout

\begin_layout Subsection
Display generation
\end_layout

\begin_layout Standard
If you want to display a mapper instance as XHTML, simply call the 
\family typewriter
asHtml
\family default
 method (
\family typewriter
toXHtml
\family default
 in Record) on your instance.
 The default implementation turns each field's value into a Text node via
 the 
\family typewriter
toString
\family default
 method and concatenates the results, separated by newlines.
 If you want to change this behavior, override the 
\family typewriter
asHtml
\family default
 on your field definitions.
 For example, if we wanted to control formatting on our date we could modify
 the field as shown in listing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom field display
\begin_inset LatexCommand label
name "lst:Custom-field-display"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

import java.util.DateFormat
\end_layout

\begin_layout Standard

...
\end_layout

\begin_layout Standard

object date extends MappedDateTime(this) {
\end_layout

\begin_layout Standard

  final val dateFormat = 
\end_layout

\begin_layout Standard

    DateFormat.getDateInstance(DateFormat.SHORT)
\end_layout

\begin_layout Standard

  override def asHtml = Text(dateFormat.format(value.getTime))
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the DateTimeField contains a 
\family typewriter
java.util.Calendar
\family default
 instance, which is why we need to use the 
\family typewriter
getTime
\family default
 method on the value.
 A similar method, 
\family typewriter
asJSON
\family default
, will return the JSON representation of the instance
\begin_inset Note Note
status open

\begin_layout Standard
Still in flux and not implemented in Record
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Form generation
\begin_inset LatexCommand label
name "sub:Form-generation"

\end_inset


\begin_inset LatexCommand index
name "Forms"

\end_inset


\end_layout

\begin_layout Standard
One of the biggest pieces of functionality in the Mapper framework is the
 ability to generate entry forms for a given record.
 The 
\family typewriter
toForm
\begin_inset LatexCommand index
name "toForm"

\end_inset


\family default
 method on Mapper is overloaded so that you can control how your form is
 created.
 All three 
\family typewriter
toForm
\family default
 methods on Mapper take a 
\family typewriter
Can[String]
\family default
 as their first parameter to control the submit button; if the Can is Empty,
 no submit button is generated, otherwise, the String contents of the Can
 are used as the button label.
 If you opt to skip the submit button you'll need to provide it yourself
 via binding or some other mechanism, or you can rely on implicit form submissio
n (when the user hits enter in a text field, for instance).
 The first 
\family typewriter
toForm
\family default
 method simply takes a function to process the submitted form and returns
 the XHTML as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Default-toForm-method"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Default toForm method
\begin_inset LatexCommand label
name "lst:Default-toForm-method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.toForm(Full("Save"), { _.save })
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, this makes it very easy to generate a form for editing an
 entity.
 The second 
\family typewriter
toForm
\family default
 method allows you to provide a URL which the Mapper will redirect to if
 validation succeeds on form submission (this is not provided in Record
\begin_inset Note Note
status open

\begin_layout Standard
for now
\end_layout

\end_inset

).
 This can be used for something like a login form, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Custom-form-redirect"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom submit button
\begin_inset LatexCommand label
name "lst:Custom-form-redirect"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.toForm (Full("Login"), "/member/profile")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The third form of the toForm method is similar to the first form, with the
 addition of 
\begin_inset Quotes eld
\end_inset

redo
\begin_inset Quotes erd
\end_inset

 snippet parameter.
 This allows you to keep the current state of the snippet when validation
 fails so that the user doesn't have to re-enter all of the data in the
 form
\begin_inset Note Note
status open

\begin_layout Standard
Not yet in Record
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The Record framework allows for a little more flexibility in controlling
 form output.
 The MetaRecord object allows you to change the default template
\begin_inset LatexCommand index
name "Override form template"

\end_inset

 that the form uses by setting the formTemplate
\begin_inset LatexCommand index
name "formTemplate"

\end_inset

 var.
 The template may contain any XHTML you want, but specifically, the 
\family typewriter
toForm
\family default
 method will do special handling for the following tags:
\end_layout

\begin_layout Description
<lift:field_label\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> The label for the field with the given name will be rendered here.
\end_layout

\begin_layout Description
<lift:field\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> The field itself (specified by the given name) will be rendered here.
 Typically this will be an input field, although it can be anything type-appropr
iate.
 For example, a BooleanField would render a checkbox.
\end_layout

\begin_layout Description
<lift:field_msg\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> Any messages, such as from validation, for the field with the given name
 will be rendered here.
\end_layout

\begin_layout Standard
As an example, if we wanted to use tables to lay out the form for our ledger
 entry, the row for the description field could look like listing 
\begin_inset LatexCommand ref
reference "lst:Custom-form-template"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=XML"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom form template
\begin_inset LatexCommand label
name "lst:Custom-form-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

<tr>
\end_layout

\begin_layout Standard

  <th><lift:field_label name="description" /></th>
\end_layout

\begin_layout Standard

  <td><lift:field name="description" /> <lift:field_msg name="description"
 /></td>
\end_layout

\begin_layout Standard

</tr>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Technically, the field_msg binding looks up lift messages (section 
\begin_inset Note Note
status open

\begin_layout Standard
Cross-ref
\end_layout

\end_inset

) based on the field's uniqueId, so you can set your own messages outside
 of validation using the S.{error,notice,warning} methods as shown in listing
 
\begin_inset LatexCommand ref
reference "lst:Setting-messages-via-S"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting messages via S
\begin_inset LatexCommand label
name "lst:Setting-messages-via-S"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

S.warning(myEntry.amount.uniqueFieldId, 
\end_layout

\begin_layout Standard

          "You have entered a negative amount!")
\end_layout

\begin_layout Standard

S.warning("amount_id", "This is brittle")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For most purposes, though, using the validation mechanism discussed in the
 next section would be the appropriate way to handle error checking and
 reporting.
\end_layout

\begin_layout Subsection
Validation
\begin_inset LatexCommand index
name "Validation"

\end_inset


\end_layout

\begin_layout Standard
Validation is the process of checking a field during form processing to
 make sure that the submitted value meets requirements.
 This can be something as simple as ensuring that a value was submitted,
 or as complex as comparing multiple field values together.
 Validation is achieved via a 
\family typewriter
List
\family default
 of functions on a field that take the field value as input and return a
 
\family typewriter
List[FieldError]]
\family default
 (
\family typewriter
Can[Node]
\family default
 in Record).
 To indicate that validation succeeded, simply return an empty List, otherwise
 the list of 
\family typewriter
FieldErrors
\family default
 you return are used as the failure messages to be presented to the user.
 A FieldError is simply a case class that associates an error message with
 a particular field.
 As an example, let's say we don't want someone to be able to add a ledger
 entry in the future.
 First, we need to define a function for our date field that takes a Date
 as an input (For Record, java.util.Calendar
\begin_inset LatexCommand index
name "Calendar"

\end_inset

 and not Date is the actual value type of DateTimeField) and returns the
 proper List.
 We show a simple function in listing 
\begin_inset LatexCommand ref
reference "lst:Date-validation"

\end_inset

.
 In the method we simply check to see if the millisecond count is greater
 than 
\begin_inset Quotes eld
\end_inset

now
\begin_inset Quotes erd
\end_inset

 and return an error message if so.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Date validation
\begin_inset LatexCommand label
name "lst:Date-validation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def noFutureDates (time : java.util.Calendar) = {
\end_layout

\begin_layout Standard

  if (time.getTimeInMillis > System.currentTimeMillis) {
\end_layout

\begin_layout Standard

    List(FieldError(this, "You cannot make future ledger entries"))
\end_layout

\begin_layout Standard

  } else {
\end_layout

\begin_layout Standard

    List[FieldError]()
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to tie the validation into the field itself.
 We do this by slightly modifying our field definition for 
\family typewriter
date
\family default
 to set our list of validators as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Setting-validators"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting validators
\begin_inset LatexCommand label
name "lst:Setting-validators"

\end_inset


\end_layout

\end_inset

object date extends DateTimeField[Entry](this) {
\end_layout

\begin_layout Standard

  override def validations = noFutureDates _ :: Nil
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that we need to add the underscore for each validation function to
 be partially applied on the submitted value.
 When our form is submitted, all of the validators for each field are run,
 and if all of them return Empty then validation succeeds.
 If any validators return a Full Can, then the contents of the Can are displayed
 as error messages to the user.
\end_layout

\begin_layout Subsection
CRUD Support
\end_layout

\begin_layout Standard
Adding CRUD support to your Mapper classes is very simple.
 We just mix in the CRUDify trait to our class and it provides a full set
 of add, edit, list, delete and view pages automatically.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Mixing-in-CRUDify"

\end_inset

 shows our Entry class with CRUDify mixed in.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Mixing in CRUDify
\begin_inset LatexCommand label
name "lst:Mixing-in-CRUDify"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Entry extends KeyedMapper[Long,Entry] with CRUDify[Long,Entry] {
\end_layout

\begin_layout Standard

  ...
 normal def here ...
\end_layout

\begin_layout Standard

  // disable delete functionality
\end_layout

\begin_layout Standard

  override def deleteMenuLoc = Empty
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CRUDify behavior is very flexible, with plenty of defs you can override
 to control the templates for pages or whether pages are shown at all (as
 we do in our example).
 CRUDify automatically creates a set of menus for SiteMap (section 
\begin_inset Note Note
status open

\begin_layout Standard
cross-ref
\end_layout

\end_inset

) that we can use by appending them onto the rest of our menus as shown
 in listing 
\begin_inset LatexCommand ref
reference "lst:Using-CRUDify-Menus"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using CRUDify Menus
\begin_inset LatexCommand label
name "lst:Using-CRUDify-Menus"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val menus = ...
 Menu(Loc(...)) :: Entry.menus :: Nil
\end_layout

\begin_layout Standard

LiftRules.setSiteMap(SiteMap(menus : _*))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mutable vs Immutable on Record
\end_layout

\begin_layout Standard
Immutability
\begin_inset LatexCommand index
name "Immutability"

\end_inset

 of instances is an important property that programmers can use to simplify
 thread-safety; if an object is immutable then you don't need to worry about
 locking between multiple threads since no thread can modify the object.
 Record (but not Mapper) supports this via the 
\family typewriter
mutable_?
\family default
 method on MetaRecord.
 By default, Records are mutable, so if you need to use multiple threads
 (with actors, for instance) you need to be careful about changing the fields
 of a given Record instance.
 If you want a Record type to be immutable then simply override the 
\family typewriter
mutable_?
\family default
 method to return false.
 Note that making a record immutable doesn't mean that you can't change
 values on it, rather that changing the value of a field actually generates
 a new instance that copies over the original instances values and uses
 the new value for the given field.
 An example of using immutable fields is shown in listing 
\begin_inset LatexCommand ref
reference "lst:Immutable-fields"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Immutable fields
\begin_inset LatexCommand label
name "lst:Immutable-fields"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val firstDesc = myEntry.description("one")
\end_layout

\begin_layout Standard

val secondDesc = firstDesc("two")
\end_layout

\begin_layout Standard

println(firstDesc.value) // prints "one"
\end_layout

\begin_layout Standard

println(secondDesc.value) // prints "two"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Record's chaining of field operation makes this essentially transparent
 in general use.
\end_layout

\begin_layout Subsection
Lifecycle Callbacks
\end_layout

\begin_layout Standard
Mapper and Record provide for a set of callbacks that allow you to perform
 actions at various points during the lifecycle of a given instance.
 If you want to define your own handling for one of the lifecycle events,
 simply add the LifecycleCallbacks trait to your object.
 Note that there is a separate LifecycleCallback trait in each of the record
 and mapper pacakges, so make sure that you import the correct one.
 For example, if we wanted to notify a comet actor whenever a new ledger
 entry is saved, we could change our Entry as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Lifecycle-Callbacks"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Lifecycle callbacks
\begin_inset LatexCommand label
name "lst:Lifecycle-Callbacks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object Entry extends Mapper[Entry] with LifecycleCallbacks {
\end_layout

\begin_layout Standard

  ...
\end_layout

\begin_layout Standard

  override def afterSave { myActor ! this }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The lifecycle hooks come at the main operations in an instance lifecycle:
\end_layout

\begin_layout Itemize
Create - When a new instance is created
\end_layout

\begin_layout Itemize
Delete - When an instance is deleted
\end_layout

\begin_layout Itemize
Save - When a fresh instance is first saved (corresponding to a table insert)
\end_layout

\begin_layout Itemize
Update - When an instance that already exists in the database is updated
 (corresponding to a table update)
\end_layout

\begin_layout Itemize
Validation - When form validation occurs.
\end_layout

\begin_layout Standard
For each of these points you can execute your code before or after the operation
 is run.
\end_layout

\begin_layout Subsection
Base Field Types
\end_layout

\begin_layout Standard
The Record and Mapper frameworks define several basic field types.
 The following table shows the corresponding types between Mapper and Record,
 as well as a brief description of each type.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="28" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="3.75in">
<row topline="true" bottomline="true" endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mapper
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Record
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Notes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedBinary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BinaryField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a byte array.
 You must provide your own overrides for toForm and asXHtml/asHtml for input
 and display
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedBirthYear
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Holds an Int that represents a birth year.
 The constructor takes a minAge parameter that is used for validation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedBoolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BooleanField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a Boolean value.
 The default form representation is a checkbox
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedCountry
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CountryField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a choice from an enumeration of country phone codes as provided
 by the net.liftweb.mapper.Countries.I18NCountry class.
 The default form representation is a select
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedDateTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DateTimeField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a timestamp (java.util.Calender for Record, java.util.Date for Mapper).
 The default form representation is a text input
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedDouble
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DoubleField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a Double value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedEmail
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EmailField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents an email address with a maximum length
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedEnum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EnumField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a choice from a given scala.Enumeration.
 The default form representation is a select
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedEnumList
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a choice of multiple Enumerations.
 The default form representation is a set of checkboxes, one for each enum
 value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedFakeClob
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Fakes a CLOB value (really stores String bytes to a BINARY column)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedGender
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a Gender enumeration.
 Display values are localized via the I18NGenders.
 
\begin_inset Note Note
status open

\begin_layout Standard
Cross-ref to I18N section
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedInt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
IntField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents an Int value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedIntIndex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents an indexed Int field (typically a primary key).
 In Record this is achieved with the KeyField trait
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedLocale
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
LocaleField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a locale as selected from the java.util.Locale.getAvailableLocales
 method.
 The default form representation is a select
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedLong
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
LongField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a Long value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedLongForeignKey
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a mapping to another entity via the other entities Long primary
 key.
 This functionality in Record is not yet supported 
\begin_inset Note Note
status open

\begin_layout Standard
Keep this up-to-date as things progress
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedLongIndex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents an indexed Long field (typically a primary key).
 In Record this is achieved with the KeyField trait
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedPassword
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PasswordField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a password string.
 The default form representation is a password input (obscured text)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedPoliteString
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Just like MappedString, but the default value is an empty string and the
 input is automatically truncated to fit the database column size
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedPostalCode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PostalCodeField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a validated postal code string.
 The field takes a reference to a MappedCountry (CountryField in Record)
 at definition and validates the input string against the selected country's
 postal code format
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedString
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
StringField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a string value with a maximum length and optional default value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedStringForeignKey
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a mapping to another entity via the other entities String primary
 key.
 This functionality in Record is not yet supported 
\begin_inset Note Note
status open

\begin_layout Standard
Keep this up-to-date as things progress
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedStringIndex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents an indexed String field (typically a primary key).
 In Record this is achieved with the KeyField trait
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedText
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a String field that stores to a CLOB column in the database.
 This can be used for large volumes of text.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedTextArea
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
TextAreaField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a String field that will use an HTML textarea element for its
 form display.
 When you define the field you can override the textareaCols and textareaRows
 defs to control the dimensions of the textarea.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedTimeZone
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
TimeZoneField
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a time zone selected from java.util.TimeZone.getAvailableIDs.
 The default form representation is a select
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MappedUniqueId
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Represents a unique string of a specified length that is randomly generated.
 The implementation doesn't allow the user to write new values to the field.
 This can be thought of as a GUID field.
\begin_inset Note Note
status open

\begin_layout Standard
Update if Record ends up with this
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Defining Custom Field Types in Mapper
\begin_inset LatexCommand label
name "sub:Defining-Custom-Field-types-mapper"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Add optional precision to this class
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic MappedField types cover a wide range of needs, but sometimes you
 may find yourself wanting to cover a specific type.
 In our example, we would like a decimal value for our ledger amount.
 Using a double would be inappropriate due to imprecision and rounding errors
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset LatexCommand htmlurl
target "http://stephan.reposita.org/archives/2008/01/11/once-and-for-all-do-not-use-double-for-money/"

\end_inset


\end_layout

\end_inset

, so instead we base it on BigDecimal.
 Our first task is to specify the class signature and constructors, as shown
 in listing 
\begin_inset LatexCommand ref
reference "lst:MappedDecimal-constructors"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
MappedDecimal constructors
\begin_inset LatexCommand label
name "lst:MappedDecimal-constructors"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class MappedDecimal[OwnerType <: MappedField[T]]
\end_layout

\begin_layout Standard

    (val owner : OwnerType, scale : Int)
\end_layout

\begin_layout Standard

    extends MappedField[BigDecimal,T] {
\end_layout

\begin_layout Standard

  def this(rec : OwnerType, newVal : BigDecimal) = {
\end_layout

\begin_layout Standard

    this(rec, newVal.scale)
\end_layout

\begin_layout Standard

    set(newVal)
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  var rounding = RoundingMode.HALF_EVEN
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first part of the class definition is the type signature; basically
 the type 
\family typewriter
[T <: MappedField[T]]
\family default
 indicates that whatever type 
\begin_inset Quotes eld
\end_inset

owns
\begin_inset Quotes erd
\end_inset

 this field must be a Mapper subclass (<: specifies an upper type bound
\begin_inset Note Note
status open

\begin_layout Standard
Should we reference type bounds somewhere?
\end_layout

\end_inset

).
 With our constructor we specify the owner record as well as the 
\begin_inset Quotes eld
\end_inset

scale
\begin_inset Quotes erd
\end_inset

 of the decimal value.
 The scale in BigDecimal essentially represents the number of digits to
 the right of the decimal point.
 In addition, we specify a second constructor that allows us to initialize
 the field to a value.
 This second constructor uses the scale of the provided value as the default.
 At the end of the listing we provide a var to control the rounding mode
 of the field.
\end_layout

\begin_layout Standard
Now that we have the constructors in place, there are several abstract methods
 on MappedField that we need to define.
 The first of these is a method to provide a default value.
 The default value is used for uninitialized fields or if validation failes.
 We also need to specify the class for our value type by implementing the
 
\family typewriter
dbFieldClass
\family default
 method.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Setting-a-default-value"

\end_inset

 shows both of these methods.
 In our case, we default to a zero value, with the scale set as specified
 in the contructor.
 We also provide the vars and methods that handle the before and after values
 of the field.
 These values are used to handle persistence state; if you change the value
 of the field, the original value is held until the instance is saved to
 the database.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting a default value
\begin_inset LatexCommand label
name "lst:Setting-a-default-value"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  def defaultValue = (new BigDecimal("0")).setScale(scale)
\end_layout

\begin_layout Standard

  def dbFieldClass = classOf[BigDecimal]
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  private var data : BigDecimal = defaultValue
\end_layout

\begin_layout Standard

  private var orgData : BigDecimal = defaultValue
\end_layout

\begin_layout Standard

  private def st (in : BigDecimal) {
\end_layout

\begin_layout Standard

    data = in
\end_layout

\begin_layout Standard

    orgData = in
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  protected def i_is_! = data
\end_layout

\begin_layout Standard

  protected def i_was_! = orgData
\end_layout

\begin_layout Standard

  override def doneWithSave() {
\end_layout

\begin_layout Standard

    orgData = data
\end_layout

\begin_layout Standard

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next set of methods we need to provide deal with when and how we can
 access the data.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Access-Control"

\end_inset

 shows the overrides that set the read and write permissions to true (default
 to false for both) as well as the i_obscure_! and real_i_set_! methods.
 The i_obscure_! method returns the a value that is used then the user doesn't
 have read permissions.
 The real_i_set_! method is what actually stores the internal value and
 sets the dirty flag when the field is updated.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Access Control
\begin_inset LatexCommand label
name "lst:Access-Control"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  override def readPermission_? = true
\end_layout

\begin_layout Standard

  override def writePermission_? = true
\end_layout

\begin_layout Standard

  protected def i_obscure_!(in : BigDecimal) = defaultValue
\end_layout

\begin_layout Standard

  protected def real_i_set_!(value : BigDecimal): BigDecimal = {
\end_layout

\begin_layout Standard

    if (value != data) {
\end_layout

\begin_layout Standard

      data = value
\end_layout

\begin_layout Standard

      dirty_?(true)
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    data
\end_layout

\begin_layout Standard

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next two methods that we need to provide deal with actually setting
 the value of the field.
 The first is 
\family typewriter
setFromAny
\family default
, which takes an 
\family typewriter
Any
\family default
 parameter and must convert it into a 
\family typewriter
BigDecimal
\family default
.
 The second, 
\family typewriter
setFromString
\family default
 is a subset of 
\family typewriter
setFromAny
\family default
 in that it takes a 
\family typewriter
String
\family default
 parameter and must return a 
\family typewriter
BigDecimal
\family default
.
 Our implementation of these two methods is shown in listing 
\begin_inset LatexCommand ref
reference "lst:setFrom...-Methods"

\end_inset

.
 We've also added a setAll method so that we have a common place to properly
 set scale and rounding modes on the value of the field.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,numberstyle={\tiny},stepnumber=2"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
setFrom...
 Methods
\begin_inset LatexCommand label
name "lst:setFrom...-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  def setFromAny (in : Any) : BigDecimal =
\end_layout

\begin_layout Standard

    in match {
\end_layout

\begin_layout Standard

      case n :: _ => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case Some(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case Full(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case None | Empty | Failure(_, _, _) | null => setFromString("0")
\end_layout

\begin_layout Standard

      case n => setFromString(n.toString)
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  def setFromString (in : String) : BigDecimal = {
\end_layout

\begin_layout Standard

    this.setAll(new BigDecimal(in))
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  protected def setAll (in : BigDecimal) = set(in.setScale(scale, rounding))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our implementations are relatively straightforward.
 The only special handling we need for setFromAny is to properly deal with
 Lists, Cans, Options and the null value.
 The BigDecimal constructor takes Strings, so the setFromString method is
 easy.
 The only addition we make over the BigDecimal constructor is to properly
 set the scale and rounding on the returned value.
 
\end_layout

\begin_layout Standard
Our final step is to define the database-specific methods for our field,
 as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Database-Specific-Methods"

\end_inset

.
 The first method we implement is targetSQLType.
 This method tells Mapper what the corresponding SQL type is for our database
 column.
 The jdbcFriendly method returns a value that can be used in a JDBC statement;
 since BigDecimal is a type directly supported by JDBC we simply delegate
 to the internal value method, 
\family typewriter
i_is_!
\family default
.
 The buildSet...
 methods return functions that can be used to set the value of our field
 based on different input types.
 These are essentially conversion functions.
 Finally, the fieldCreatorString specifices what we would need in a CREATE
 TABLE statement to define this column
\begin_inset Note Note
status open

\begin_layout Standard
Need to modify to specify precision or change definition
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Database-Specific Methods
\begin_inset LatexCommand label
name "lst:Database-Specific-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def targetSQLType = Types.DECIMAL
\end_layout

\begin_layout Standard

def jdbcFriendly(field : String) = i_is_!
\end_layout

\begin_layout Standard

def buildSetBooleanValue(accessor : Method, columnName : String) : (T, Boolean,
 Boolean) => Unit = null
\end_layout

\begin_layout Standard

def buildSetDateValue(accessor : Method, columnName : String) : (T, Date)
 => Unit =
\end_layout

\begin_layout Standard

  (inst, v) => doField(inst, accessor, {case f: MappedDecimal[T] => f.st(if
 (v == null) defaultValue else (new BigDecimal(v.getTime).setScale(scale)))})
        def buildSetStringValue(accessor: Method, columnName: String): (T,
 String) => Unit =
\end_layout

\begin_layout Standard

  (inst, v) => doField(inst, accessor, {case f: MappedDecimal[T] => f.st(new
 BigDecimal(v).setScale(scale))})
\end_layout

\begin_layout Standard

def buildSetLongValue(accessor: Method, columnName : String) : (T, Long,
 Boolean) =>
\end_layout

\begin_layout Standard

  Unit = (inst, v, isNull) => doField(inst, accessor, {case f: MappedDecimal[T]
 => f.st(if (isNull) defaultValue else (new BigDecimal(v).setScale(scale)))})
      def buildSetActualValue(accessor: Method, data: AnyRef, columnName:
 String) : (T, AnyRef) =>
\end_layout

\begin_layout Standard

  Unit = (inst, v) => doField(inst, accessor, {case f: MappedDecimal[T]
 => f.st(new BigDecimal(v.toString).setScale(scale))})
\end_layout

\begin_layout Standard

def fieldCreatorString(dbType: DriverType, colName: String): String = colName
 + " DECIMAL(20," + scale + ")" 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make the field a little more useful, we can also specify some convenience
 methods on it to make arithmetic a little more natural, as shown in listing
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Convenience methods
\begin_inset LatexCommand label
name "lst:Convenience-methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  def += (other : BigDecimal) = setAll(data.add(other))
\end_layout

\begin_layout Standard

  def -= (other : BigDecimal) = setAll(data.subtract(other))
\end_layout

\begin_layout Standard

  def *= (other : BigDecimal) = setAll(data.multiply(other))
\end_layout

\begin_layout Standard

  def /= (other : BigDecimal) = setAll(data.divide(other))
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  // Use in practice:
\end_layout

\begin_layout Standard

  myEntry.amount *= BigDecimal.valueOf(2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You could expand on the convenience methods as you wish to cover Ints, Longs,
 Doubles, etc.
\end_layout

\begin_layout Subsection
Defining Custom Field Types in Record
\begin_inset LatexCommand label
name "sub:Defining-Custom-Field-types-record"

\end_inset


\end_layout

\begin_layout Standard
Similar to the example in section 
\begin_inset LatexCommand ref
reference "sub:Defining-Custom-Field-types-mapper"

\end_inset

, when using Record we would like a DecimalField to represent decimal currency
 amounts.
 Our implementation starts off looking very similar to the Mapper version,
 as shown in listing 
\begin_inset LatexCommand ref
reference "lst:DecimalField-constructors"

\end_inset

.
 The main difference so far is that the owner type has to be a subtype of
 Record instead of Mapper.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
DecimalField Constructors
\begin_inset LatexCommand label
name "lst:DecimalField-constructors"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class DecimalField[OwnerType <: Record[OwnerType]]
\end_layout

\begin_layout Standard

    (rec : OwnerType, scale : Int)
\end_layout

\begin_layout Standard

    extends Field[BigDecimal,OwnerType] {
\end_layout

\begin_layout Standard

  def this(rec : OwnerType, newVal : BigDecimal) = {
\end_layout

\begin_layout Standard

    this(rec, newVal.scale)
\end_layout

\begin_layout Standard

    set(newVal)
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  var rounding = RoundingMode.HALF_EVEN
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to start defining the methods that are left abstract on
 Field.
 Our first set deals with some basic housekeeping and presentation layer
 details, shown in listing 
\begin_inset LatexCommand ref
reference "lst:DecimalField-Methods"

\end_inset

.
 The defaultValue method simply defines the value that we use for new instances.
 The owner method lets Record know which Record instance owns this field.
 asXHtml and toForm define the methods for display and form generation,
 respectively.
 We use the setFromString method (defined later in this section) to handle
 form setting, which keeps the logic clean.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
DecimalField Methods
\begin_inset LatexCommand label
name "lst:DecimalField-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def defaultValue = (new BigDecimal("0")).setScale(scale)
\end_layout

\begin_layout Standard

def owner = rec
\end_layout

\begin_layout Standard

def asXHtml = Text(value.toString)
\end_layout

\begin_layout Standard

def toForm = text(value.toString, this.setFromString) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our final set of methods deals with setting the value of the field, shown
 in listing 
\begin_inset LatexCommand ref
reference "lst:DecimalField-Set-Methods"

\end_inset

.
 The setFromAny method, and its counterpart setFromString, have replaced
 the buildSet...
 method functionality that we would define in Mapper
\begin_inset Note Note
status open

\begin_layout Standard
Is that correct?
\end_layout

\end_inset

.
 setFromAny essentially defers to setFromString for all operations, and
 the only special handling we need is for Lists, Options and Cans.
 setFromString is required to catch any exceptions thrown during conversion;
 if we have a failure we need to return an Empty as well as calling couldNotSetV
alue to set a flag for validation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
DecimalField Set Methods
\begin_inset LatexCommand label
name "lst:DecimalField-Set-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def setFromAny (in : Any) : Can[BigDecimal] =
\end_layout

\begin_layout Standard

  in match {
\end_layout

\begin_layout Standard

    case n :: _ => setFromString(n.toString)
\end_layout

\begin_layout Standard

    case Some(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

    case Full(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

    case None | Empty | Failure(_, _, _) | null => setFromString("0")
\end_layout

\begin_layout Standard

    case n => setFromString(n.toString)
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

def setFromString (in : String) : Can[BigDecimal] = {
\end_layout

\begin_layout Standard

  try {
\end_layout

\begin_layout Standard

    Full(this.setAll(new BigDecimal(in)))
\end_layout

\begin_layout Standard

  } catch {
\end_layout

\begin_layout Standard

    case e : Exception => couldNotSetValue; Empty
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

/** Set the value along with proper scale and rounding */
\end_layout

\begin_layout Standard

protected def setAll (in : BigDecimal) = set(in.setScale(scale,rounding))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since BigDecimal takes a string as a constructor (in fact, this is the recommend
ed way to initialize it to avoid precision issues with numerics), the setFromStr
ing method is relatively easy to implement.
 To make things even simpler, we add the setAll method that takes a BigDecimal
 as input and then sets the proper scale and rounding on it.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Confirm change in behavior from Mapper to not save the original value
\end_layout

\end_inset


\end_layout

\begin_layout Section
Record Backends
\begin_inset LatexCommand label
name "sec:Record-Backends"

\end_inset


\end_layout

\begin_layout Subsection
JDBC Records
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This part of the library hasn't been finished yet
\end_layout

\end_inset

TBD
\end_layout

\begin_layout Subsection
JPA Records
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This part of the library hasn't been finished yet
\end_layout

\end_inset

TBD
\end_layout

\begin_layout Section
Advanced Features
\end_layout

\begin_layout Standard
In this section we'll cover some of the advanced features of Mapper
\end_layout

\begin_layout Subsection
Using Multiple Databases 
\begin_inset LatexCommand label
name "sub:Multiple-Databases"

\end_inset


\end_layout

\begin_layout Standard
It's common for an application to need to access data in more than one database.
 Lift supports this feature through the use of overrides on your MetaMapper
 classes.
 First, we need to define the identifiers for the various databases using
 the ConnectionIdentifier trait and overriding the jndiName def.
 Lift comes with one pre-made: DefaultConnectionIdentifier.
 It's jndiName is set to 
\begin_inset Quotes eld
\end_inset

lift
\begin_inset Quotes erd
\end_inset

, so it's recommended that you use something else.
 Let's say we have two databases: sales and employees.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Defining-Connection-Identifiers"

\end_inset

 shows how we would define the ConnectionIdentifier objects for these.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Defining Connection Identifiers
\begin_inset LatexCommand label
name "lst:Defining-Connection-Identifiers"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object SalesDB extends ConnectionIdentifier {
\end_layout

\begin_layout Standard

  def jndiName = "sales"
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

object EmployeeDB extends ConnectionIdentifier {
\end_layout

\begin_layout Standard

  def jndiName = "employees"
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Simple enough.
 Now, we need to create connection managers for each one, or we can combine
 the functionality into a single manager.
 To keep things clean we'll use a single manager, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Multi-database-Connection-Manager"

\end_inset

.
 Scala's match operator allows us to easily return the correct connection
\begin_inset Note Note
status open

\begin_layout Standard
Validate this code
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Multi-database Connection Manager
\begin_inset LatexCommand label
name "lst:Multi-database-Connection-Manager"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object DBVendor extends ConnectionManager {
\end_layout

\begin_layout Standard

  Class.forName("org.postgresql.Driver")
\end_layout

\begin_layout Standard

 
\end_layout

\begin_layout Standard

  def newConnection(name : ConnectionIdentifier) = {
\end_layout

\begin_layout Standard

    try {
\end_layout

\begin_layout Standard

      name match {
\end_layout

\begin_layout Standard

        case SalesDB =>
\end_layout

\begin_layout Standard

          Full(DriverManager.getConnection(
\end_layout

\begin_layout Standard

            "jdbc:postgresql://localhost/sales",
\end_layout

\begin_layout Standard

            "root", "secret"))
\end_layout

\begin_layout Standard

        case EmployeeDB =>
\end_layout

\begin_layout Standard

          Full(DriverManager.getConnection(
\end_layout

\begin_layout Standard

            "jdbc:postgresql://server/employees",
\end_layout

\begin_layout Standard

            "root", "hidden"))
\end_layout

\begin_layout Standard

    } catch {
\end_layout

\begin_layout Standard

      case e : Exception => e.printStackTrace; Empty
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  def releaseConnection (conn : Connection) { conn.close }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of using multiple databases is 
\emph on
sharding
\emph default

\begin_inset Foot
status collapsed

\begin_layout Standard
For more information on sharding, see this article: 
\begin_inset LatexCommand htmlurl
target "http://highscalability.com/unorthodox-approach-database-design-coming-shard"

\end_inset


\end_layout

\end_inset

.
 Sharding is a means to scale your database capacity by associating entities
 with one database instance out of a federation of servers based on some
 property of the entity.
 For instance, we could distribute user entites across 3 database servers
 by using the first character of the last name: A-H goes to server 1, I-P
 goes to server 2, and Q-Z goes to server 3.
 As simple as this sounds, there are some important factors to remember:
\end_layout

\begin_layout Itemize
Sharding increases the complexity of your code a little
\end_layout

\begin_layout Itemize
To get the most benefit out of sharding, you need to carefully choose and
 tune your 
\begin_inset Quotes eld
\end_inset

selector
\begin_inset Quotes erd
\end_inset

.
 If you're not careful you can get an uneven distribution where some servers
 handle significantly more load than others, defeating the purpose of sharding.
 If you decide to re-tune your selctor later on you need to redistribute
 the data to the proper servers in concert with changing your code or you
 won't be able to find things
\end_layout

\begin_layout Itemize
When you use sharding, you can't just use normal joins anymore, since the
 data isn't all within one instance.
 This means more work on your part to properly retrieve and associate data
\end_layout

\begin_layout Standard
Mapper provides a handy feature 
\begin_inset Note Note
status open

\begin_layout Standard
Or does it? Confirm whether or not this is supported.
\end_layout

\end_inset

for sharding that allows you to choose which database connection you want
 to use for a specific entity.
 There are two methods we can use to control the behavior: 
\family typewriter
dbSelectDBConnectionForFind
\family default
, and 
\family typewriter
dbCalculateConnectionIdentifier
\family default
.
 dbSelect...
 is used in a find by primary key, and takes a partial function (typically
 a match clause) to determine which connection to use.
 dbCalculate...
 is used when a new instance is created to decide where to store the new
 instance.
 As an example, say we've defined two database connections, SalesA and SalesB.
 We want to place new instances in SalesA if the amount is > $100 and SalesB
 otherwise.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Sharding-in-Action"

\end_inset

 shows our method in action.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Sharding in Action
\begin_inset LatexCommand label
name "lst:Sharding-in-Action"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Entry extends Mapper[Entry] {
\end_layout

\begin_layout Standard

  ...
 fields, etc ...
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  override def dbCalculateConnectionIdentifier = {
\end_layout

\begin_layout Standard

    case n if n.amount.is > 100 => SalesA
\end_layout

\begin_layout Standard

    case _ => SalesB
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This needs to be revised and expanded once sharding is truly figured out
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SQL-based Queries
\begin_inset LatexCommand label
name "sub:SQL-based-queries"

\end_inset


\end_layout

\begin_layout Standard
If, despite all that Mapper covers, you find yourself still wanting more
 control over the query, there are two more options available to you: findAllByP
reparedStatement and findAllByInsecureSql.
 The findAllByPreparedStatement method allows you to, in essence, construct
 your query completely by hand.
 The added benefit of using a PreparedStatement
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset LatexCommand htmlurl
target "http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html"

\end_inset


\end_layout

\end_inset

 means that you can easily include user-defined data in your queries.
 The findAllByPreparedStatement method takes a single function parameter;
 this function needs to take a SuperConnection
\begin_inset Foot
status collapsed

\begin_layout Standard
Essentially a thin wrapper on java.sql.Connection, 
\begin_inset LatexCommand htmlurl
target "http://scala-tools.org/mvnsites/liftweb/lift-webkit/scaladocs/net/liftweb/mapper/SuperConnection.html"

\end_inset


\end_layout

\end_inset

 and return a PreparedStatement instance.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Using-findAllByPreparedStatement"

\end_inset

 shows our previous example of looking up all Categories for a recent ledger
 entries using findAllByPreparedStatement instead
\begin_inset Note Note
status open

\begin_layout Standard
Validate this SQL
\end_layout

\end_inset

.
 The query that you provide must at least return the fields that are mapped
 by your entity, but you can return other columns as well (they'll just
 be ignored) in case you just want to do a 
\begin_inset Quotes eld
\end_inset

select *
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Using findAllByPreparedStatement
\begin_inset LatexCommand label
name "lst:Using-findAllByPreparedStatement"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def recentCategories = CategoryMeta.findAllByPreparedStatement({ superconn
 =>
\end_layout

\begin_layout Standard

  superconn.connection.prepareStatement(
\end_layout

\begin_layout Standard

    "select distinct category.id, category.name " +
\end_layout

\begin_layout Standard

    "from Category category " +
\end_layout

\begin_layout Standard

    "join CategoryJoin cj on category.id = cj.category " +
\end_layout

\begin_layout Standard

    "join Entry entry on entry.id = cj.entry " +
\end_layout

\begin_layout Standard

    "where entry.date > (CURRENT_DATE - interval '30 days')")
\end_layout

\begin_layout Standard

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The findAllByInsecureSql method goes even further, executing the string
 you submit directly as a statement without any checks.
 The same general rules apply as for findAllByPreparedStatement, although
 you need to add the IHaveValidatedThisSQL parameter as a code audit check.
 In either case, the ability to use full SQL queries can allow you to do
 some very powerful things, but it comes at the cost of losing type safety
 and possibly making your app non-portable.
\end_layout

\end_body
\end_document
