#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
% "define" Scala
\lstdefinelanguage{scala}{morekeywords={class,object,trait,extends,with,new,if,while,for,def,val,var},sensitive=true,morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]"}

% Default settings for code listings
\lstset{frame=single,frameround=tttt,language=scala}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
The Mapper and Record Frameworks
\begin_inset LatexCommand label
name "cha:mapper_and_record"

\end_inset


\end_layout

\begin_layout Standard
Usually we find that most webapps end up wanting to store user data somewhere.
 Once you start working with user data, though, you start dealing with issues
 like coding up input forms, validation
\begin_inset LatexCommand index
name "validation"

\end_inset

, persistence, etc to handle the data.
 That's where the Mapper and Record frameworks comes in.
 These frameworks provides a scaffolding for all of your data manipulation
 needs.
 Mapper is the original Lift persistence framework, and is closely tied
 to JDBC for its storage.
 Record is a new refactorization of Mapper that is backing-store agnostic
 at its core, so it doesn't matter whether you want to save your data to
 JDBC, JPA, or even something like XML.
 With Record, selecting the proper driver is as simple as hooking the proper
 traits into your class.
 Because these frameworks are based on the same concepts, we will be covering
 them in parallel in this chapter.
\end_layout

\begin_layout Standard
\begin_inset Note Framed
status open

\begin_layout Standard
Unless we note otherwise, functionality for each framework is the same.
 We will point out minor differences like method names inline, while major
 differences will be covered in their own sections.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction to Mapper and MetaMapper
\end_layout

\begin_layout Standard
Let's start by discussing the relationship between the Mapper
\begin_inset LatexCommand index
name "Mapper"

\end_inset

 and MetaRecord
\begin_inset LatexCommand index
name "MetaRecord"

\end_inset

 traits (and the corresponding Record
\begin_inset LatexCommand index
name "Record"

\end_inset

 and MetaRecord
\begin_inset LatexCommand index
name "MetaRecord"

\end_inset

).
 Mapper provides the 
\emph on
per-instance
\emph default
 functionality for your class, while MetaMapper handles the 
\emph on
global
\emph default
 operations for your class and provides a common location to define per-class
 static specializations of things like field order, form generation and
 HTML representation.
 In fact, many of the Mapper methods actually delegate to methods on MetaMapper.
 In addition to Mapper and MetaMapper there is a third trait, MappedField,
 that provides the per-field functionality for your class.
 In Record the trait is simply called 
\begin_inset Quotes eld
\end_inset

Field
\begin_inset Quotes erd
\end_inset

.
 The MappedField trait lets you define the individual validators as well
 as things like tab order and error messages for form input handling.
\end_layout

\begin_layout Subsection
Constructing a Mapper-enabled class
\end_layout

\begin_layout Standard
Now that we've covered some basic background, we can start constructing
 some Mapper classes to get more familiar with the framework.
 We'll start with a simple example of a class for a ledger entry with the
 following fields:
\end_layout

\begin_layout Itemize
Date
\end_layout

\begin_layout Itemize
Description, with a max length of 100 chars
\end_layout

\begin_layout Itemize
Amount, a decimal value with a precsion of two places.
\end_layout

\begin_layout Standard
The first thing we do is declare our Entry class, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Entry-class-mapper"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Entry class in Mapper
\begin_inset LatexCommand label
name "lst:Entry-class-mapper"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class MapEntry extends KeyedMapper[Long,MapEntry] {
\end_layout

\begin_layout Standard

  def getSingleton = MapEntryMeta
\end_layout

\begin_layout Standard

  def primaryKeyField = id
\end_layout

\begin_layout Standard

  object id extends MappedLongIndex(this)
\end_layout

\begin_layout Standard

  object date extends MappedDateTime(this)
\end_layout

\begin_layout Standard

  object description extends MappedString(this,100)
\end_layout

\begin_layout Standard

  // 2 digits to the right
\end_layout

\begin_layout Standard

  object amount extends MappedDecimal(this,2)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Record version is shown in listing 
\begin_inset LatexCommand ref
reference "lst:Entry-class-record"

\end_inset

; the only differences are that the 
\family typewriter
getSingleton
\family default
 method has been renamed to 
\family typewriter
meta
\family default
, and the Field traits use different names under the Record framework (DateTimeF
ield vs MappedDateTime).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Entry class in Record
\begin_inset LatexCommand label
name "lst:Entry-class-record"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class Entry extends KeyedRecord[Entry,Long] {
\end_layout

\begin_layout Standard

  def meta = EntryMeta
\end_layout

\begin_layout Standard

  def primaryKey = id
\end_layout

\begin_layout Standard

  object id extends LongField(this) with KeyField
\end_layout

\begin_layout Standard

  object date extends DateTimeField(this)
\end_layout

\begin_layout Standard

  object description extends StringField(this, 100)
\end_layout

\begin_layout Standard

  // 2 digits to the right
\end_layout

\begin_layout Standard

  object amount extends DecimalField(this, 2)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, we've set Entry to extend the KeyedMapper trait (we need
 to tell Mapper what the subtype is) and we've added the fields required
 by our class.
 We need to provide a primary key on the entity, so we use the KeyedMapper
 trait instead of Mapper (or, correspondingly, KeyedRecord
\begin_inset Note Note
status open

\begin_layout Standard
Something is wrong in the lift code here.
\end_layout

\end_inset

 instead of Record).
 When you use the KeyedMapper trait you need to provide an implementation
 for the primaryKeyField def, which must match the type of the KeyedMapper
 trait and be a subtype of IndexedField.
 Currently, Mapper supports indexed Ints, Longs and Strings, so if you want
 to use some other type for your primary key you'll need to roll your own
\begin_inset Note Note
status open

\begin_layout Standard
Add section on custom Mapped fields
\end_layout

\end_inset

.
 You must also provide a KeyedMetaMapper object instead of just MetaMapper.
 The identity of an entity is a unique value associated with the entity
 that can be used, typically by the underlying data store, for retrieval
 and indexing.
 In SQL this is essentially a primary synthetic key on the table holding
 the entity.
 
\end_layout

\begin_layout Standard
Looking at these examples, you've probably noticed that the fields are defined
 as objects rather than instance members (vars).
 The basic reason for this is that the MetaMapper needs access to fields
 for its validation and form functionality; it wouldn't be possible to cleanly
 define these properties in the MetaMapper if it had to access member vars
 on each instance since a MetaMapper instance is itself an object.
 Also note that DecimalField is a custom field type, which we will cover
 in section 
\begin_inset LatexCommand ref
reference "sub:Defining-Custom-Field-types"

\end_inset

.
\end_layout

\begin_layout Standard
In order to tie all of this together, we need to define a matching MetaMapper
\begin_inset LatexCommand index
name "MetaRecord"

\end_inset

 object, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:EntryMeta-object"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
EntryMeta object
\begin_inset LatexCommand label
name "lst:EntryMeta-object"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object EntryMeta extends Entry with KeyedMetaMapper[Long,Entry] {
\end_layout

\begin_layout Standard

  override def fieldOrder = List(date, description, amount)
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our case we'll simply define the order of fields as they'll be displayed
 in XHTML
\begin_inset LatexCommand index
name "XHTML"

\end_inset

 and forms
\begin_inset LatexCommand index
name "form"

\end_inset

.
 If you don't want a particular field to show up in forms or XHTML output,
 simply omit it from the fieldOrder
\begin_inset LatexCommand index
name "fieldOrder"

\end_inset

 list.
\end_layout

\begin_layout Standard
Since fields aren't actually instance members, operations on them are slightly
 different that a regular var.
 The biggest difference is in how we set fields: we use the apply method.
 In addition, field access can be chained so that you can set multiple field
 values in one statement, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Setting-field-values"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting field values
\begin_inset LatexCommand label
name "lst:Setting-field-values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.date(new Date).description("A sample entry")
\end_layout

\begin_layout Standard

myEntry.amount("127.20")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The underlying value of a given field can be retrieved with the 
\family typewriter
is
\family default
 method (
\family typewriter
value
\family default
 method in Record) as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Accessing-field-values"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Accessing field values in Record
\begin_inset LatexCommand label
name "lst:Accessing-field-values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

// mapper
\end_layout

\begin_layout Standard

val tenthOfAmount = myEntry.amount.is / 10
\end_layout

\begin_layout Standard

val formatted = String.format("%s : %s",
\end_layout

\begin_layout Standard

                              myEntry.description.is,
\end_layout

\begin_layout Standard

                              myEntry.amount.is.toString)
\end_layout

\begin_layout Standard

// record
\end_layout

\begin_layout Standard

if (myEntry.description.value == "Doughnuts") {
\end_layout

\begin_layout Standard

  println("Diet ruined!")
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object Relationships
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Need something here.
 Search mail archives for discussion
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Persistence Operations on an Entity
\end_layout

\begin_layout Standard
Now that we've defined our entity we probably want to use it in the real
 world to load and store data.
 There are several operations on KeyedMetaMapper that we can use :
\end_layout

\begin_layout Description
create Creates a new instance of the entity
\end_layout

\begin_layout Description
save Saves an instance to the database.
 This method correctly handles updates versus completely new instances
\end_layout

\begin_layout Description
delete Deletes the given entity instance
\end_layout

\begin_layout Description
find* A whole host of means for locating entities, by primary key, typesafe
 queries, raw SQL queries, etc.
 These will be covered in detail in their own section, 
\begin_inset LatexCommand ref
reference "sub:Querying-for-Entities"

\end_inset


\end_layout

\begin_layout Standard
In general these operations will be supported in both Record and Mapper.
 However, because Record isn't coupled tightly to a JDBC backend some of
 the find methods may not be supported and there may be additional methods
 not available in Mapper for persistence.
 For this reason, this section will deal specifically with Mapper's persistence
 operations; Record's backends and their supported operations are covered
 in section 
\begin_inset LatexCommand ref
reference "sec:Record-Backends"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Creating an Instance
\end_layout

\begin_layout Standard
Once we have the KeyedMetaMapper object defined we can use it to create
 objects using the 
\family typewriter
create
\begin_inset LatexCommand index
name "create"

\end_inset


\family default
 method.
 You can't just use the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 operator because the framework has to set up internal data for the instance
 such as field owner, etc.
 This is important to remember, since nothing will prevent you from creating
 an instance manually; you'll just get all kinds of errors when you go to
 use the instance.
\end_layout

\begin_layout Subsubsection*
Saving an Instance
\end_layout

\begin_layout Standard
Saving an instance is as easy as calling the 
\family typewriter
save
\family default
 method on the instance you want to save.
 Optionally, you 
\end_layout

\begin_layout Subsection
Querying for Entities
\begin_inset LatexCommand label
name "sub:Querying-for-Entities"

\end_inset


\end_layout

\begin_layout Standard
Here we cover how to find entities
\end_layout

\begin_layout Section
Utility Functionality
\end_layout

\begin_layout Standard
In addition to the first-class persistence support in Mapper and Record,
 the frameworks provide additional functionality to make writing data-driven
 applications much simpler.
 This includes things like automatic XHtml representation of objects and
 support for generating everything from simple forms for an entity up to
 a full-fledged CRUD
\begin_inset Foot
status collapsed

\begin_layout Standard
An abbreviation (Create, Read, Update and Delete) representing the standard
 operations that are performed on database records.
 Taken from 
\begin_inset LatexCommand htmlurl
target "http://provost.uiowa.edu/maui/Glossary.html"

\end_inset


\end_layout

\end_inset

 implementation for your entities.
\end_layout

\begin_layout Subsection
Display generation
\end_layout

\begin_layout Standard
If you want to display a mapper instance as XHTML, simply call the 
\family typewriter
asHtml
\family default
 method (
\family typewriter
toXHtml
\family default
 in Record) on your instance.
 The default implementation turns each field's value into a Text node via
 the 
\family typewriter
toString
\family default
 method and concatenates the results, separated by newlines.
 If you want to change this behavior, override the 
\family typewriter
asHtml
\family default
 on your field definitions.
 For example, if we wanted to control formatting on our date we could modify
 the field as shown in listing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom field display
\begin_inset LatexCommand label
name "lst:Custom-field-display"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

import java.util.DateFormat
\end_layout

\begin_layout Standard

...
\end_layout

\begin_layout Standard

object date extends MappedDateTime(this) {
\end_layout

\begin_layout Standard

  final val dateFormat = 
\end_layout

\begin_layout Standard

    DateFormat.getDateInstance(DateFormat.SHORT)
\end_layout

\begin_layout Standard

  override def asHtml = Text(dateFormat.format(value.getTime))
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the DateTimeField contains a 
\family typewriter
java.util.Calendar
\family default
 instance, which is why we need to use the 
\family typewriter
getTime
\family default
 method on the value.
 A similar method, 
\family typewriter
asJSON
\family default
, will return the JSON representation of the instance
\begin_inset Note Note
status open

\begin_layout Standard
Still in flux and not implemented in Record
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Form generation
\begin_inset LatexCommand label
name "sub:Form-generation"

\end_inset


\begin_inset LatexCommand index
name "Forms"

\end_inset


\end_layout

\begin_layout Standard
One of the biggest pieces of functionality in the Mapper framework is the
 ability to generate entry forms for a given record.
 The 
\family typewriter
toForm
\begin_inset LatexCommand index
name "toForm"

\end_inset


\family default
 method on Mapper is overloaded so that you can control how your form is
 created.
 All three 
\family typewriter
toForm
\family default
 methods on Mapper take a 
\family typewriter
Can[String]
\family default
 as their first parameter to control the submit button; if the Can is Empty,
 no submit button is generated, otherwise, the String contents of the Can
 are used as the button label.
 If you opt to skip the submit button you'll need to provide it yourself
 via binding or some other mechanism, or you can rely on implicit form submissio
n (when the user hits enter in a text field, for instance).
 The first 
\family typewriter
toForm
\family default
 method simply takes a function to process the submitted form and returns
 the XHTML as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Default-toForm-method"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Default toForm method
\begin_inset LatexCommand label
name "lst:Default-toForm-method"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.toForm(Full("Save"), { _.save })
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, this makes it very easy to generate a form for editing an
 entity.
 The second 
\family typewriter
toForm
\family default
 method allows you to provide a URL which the Mapper will redirect to if
 validation succeeds on form submission (this is not provided in Record
\begin_inset Note Note
status open

\begin_layout Standard
for now
\end_layout

\end_inset

).
 This can be used for something like a login form, as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Custom-form-redirect"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom submit button
\begin_inset LatexCommand label
name "lst:Custom-form-redirect"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

myEntry.toForm (Full("Login"), "/member/profile")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The third form of the toForm method is similar to the first form, with the
 addition of 
\begin_inset Quotes eld
\end_inset

redo
\begin_inset Quotes erd
\end_inset

 snippet parameter.
 This allows you to present a different snippet to the user if validation
 fails.
\begin_inset Note Note
status open

\begin_layout Standard
What's the use case here? Examples? Will this exist in Record?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Record framework allows for a little more flexibility in controlling
 form output.
 The MetaRecord object allows you to change the default template
\begin_inset LatexCommand index
name "Override form template"

\end_inset

 that the form uses by setting the formTemplate
\begin_inset LatexCommand index
name "formTemplate"

\end_inset

 var.
 The template may contain any XHTML you want, but specifically, the 
\family typewriter
toForm
\family default
 method will do special handling for the following tags:
\end_layout

\begin_layout Description
<lift:field_label\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> The label for the field with the given name will be rendered here.
\end_layout

\begin_layout Description
<lift:field\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> The field itself (specified by the given name) will be rendered here.
 Typically this will be an input field, although it can be anything type-appropr
iate.
 For example, a BooleanField would render a checkbox.
\end_layout

\begin_layout Description
<lift:field_msg\InsetSpace ~
name=
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

\InsetSpace ~
/> Any messages, such as from validation, for the field with the given name
 will be rendered here.
\end_layout

\begin_layout Standard
As an example, if we wanted to use tables to lay out the form for our ledger
 entry, the row for the description field could look like listing 
\begin_inset LatexCommand ref
reference "lst:Custom-form-template"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=XML"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Custom form template
\begin_inset LatexCommand label
name "lst:Custom-form-template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

<tr>
\end_layout

\begin_layout Standard

  <th><lift:field_label name="description" /></th>
\end_layout

\begin_layout Standard

  <td><lift:field name="description" /> <lift:field_msg name="description"
 /></td>
\end_layout

\begin_layout Standard

</tr>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Technically, the field_msg binding looks up lift messages (section 
\begin_inset Note Note
status open

\begin_layout Standard
Cross-ref
\end_layout

\end_inset

) based on the field's uniqueId, so you can set your own messages outside
 of validation using the S.{error,notice,warning} methods as shown in listing
 
\begin_inset LatexCommand ref
reference "lst:Setting-messages-via-S"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting messages via S
\begin_inset LatexCommand label
name "lst:Setting-messages-via-S"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

S.warning(myEntry.amount.uniqueFieldId, 
\end_layout

\begin_layout Standard

          "You have entered a negative amount!")
\end_layout

\begin_layout Standard

S.warning("amount_id", "This is brittle")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For most purposes, though, using the validation mechanism discussed in the
 next section would be the appropriate way to handle error checking and
 reporting.
\end_layout

\begin_layout Subsection
Validation
\begin_inset LatexCommand index
name "Validation"

\end_inset


\end_layout

\begin_layout Standard
Validation is the process of checking a field during form processing to
 make sure that the submitted value meets requirements.
 This can be something as simple as ensuring that a value was submitted,
 or as complex as comparing multiple field values together.
 Validation is achieved via a 
\family typewriter
List
\family default
 of functions on a field that take the field value as input and return a
 
\family typewriter
List[FieldError]]
\family default
 (
\family typewriter
Can[Node]
\family default
 in Record).
 To indicate that validation succeeded, simply return an empty List, otherwise
 the list of 
\family typewriter
FieldErrors
\family default
 you return are used as the failure messages to be presented to the user.
 A FieldError is simply a case class that associates an error message with
 a particular field.
 As an example, let's say we don't want someone to be able to add a ledger
 entry in the future.
 First, we need to define a function for our date field that takes a Date
 as an input (For Record, java.util.Calendar
\begin_inset LatexCommand index
name "Calendar"

\end_inset

 and not Date is the actual value type of DateTimeField) and returns the
 proper List.
 We show a simple function in listing 
\begin_inset LatexCommand ref
reference "lst:Date-validation"

\end_inset

.
 In the method we simply check to see if the millisecond count is greater
 than 
\begin_inset Quotes eld
\end_inset

now
\begin_inset Quotes erd
\end_inset

 and return an error message if so.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Date validation
\begin_inset LatexCommand label
name "lst:Date-validation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def noFutureDates (time : java.util.Calendar) = {
\end_layout

\begin_layout Standard

  if (time.getTimeInMillis > System.currentTimeMillis) {
\end_layout

\begin_layout Standard

    List(FieldError(this, "You cannot make future ledger entries"))
\end_layout

\begin_layout Standard

  } else {
\end_layout

\begin_layout Standard

    List[FieldError]()
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to tie the validation into the field itself.
 We do this by slightly modifying our field definition for 
\family typewriter
date
\family default
 to set our list of validators as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Setting-validators"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting validators
\begin_inset LatexCommand label
name "lst:Setting-validators"

\end_inset


\end_layout

\end_inset

object date extends DateTimeField[Entry](this) {
\end_layout

\begin_layout Standard

  override def validations = noFutureDates _ :: Nil
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that we need to add the underscore for each validation function to
 be partially applied on the submitted value.
 When our form is submitted, all of the validators for each field are run,
 and if all of them return Empty then validation succeeds.
 If any validators return a Full Can, then the contents of the Can are displayed
 as error messages to the user.
\end_layout

\begin_layout Subsection
CRUD Support
\end_layout

\begin_layout Subsection
Mutable vs Immutable on Record
\end_layout

\begin_layout Standard
Immutability
\begin_inset LatexCommand index
name "Immutability"

\end_inset

 of instances is an important property that programmers can use to simplify
 thread-safety; if an object is immutable then you don't need to worry about
 locking between multiple threads since no thread can modify the object.
 Record (but not Mapper) supports this via the 
\family typewriter
mutable_?
\family default
 method on MetaRecord.
 By default, Records are mutable, so if you need to use multiple threads
 (with actors, for instance) you need to be careful about changing the fields
 of a given Record instance.
 If you want a Record type to be immutable then simply override the 
\family typewriter
mutable_?
\family default
 method to return false.
 Note that making a record immutable doesn't mean that you can't change
 values on it, rather that changing the value of a field actually generates
 a new instance that copies over the original instances values and uses
 the new value for the given field.
 An example of using immutable fields is shown in listing 
\begin_inset LatexCommand ref
reference "lst:Immutable-fields"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Immutable fields
\begin_inset LatexCommand label
name "lst:Immutable-fields"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

val firstDesc = myEntry.description("one")
\end_layout

\begin_layout Standard

val secondDesc = firstDesc("two")
\end_layout

\begin_layout Standard

println(firstDesc.value) // prints "one"
\end_layout

\begin_layout Standard

println(secondDesc.value) // prints "two"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Record's chaining of field operation makes this essentially transparent
 in general use.
\end_layout

\begin_layout Subsection
Lifecycle Callbacks
\end_layout

\begin_layout Standard
Mapper and Record provide for a set of callbacks that allow you to perform
 actions at various points during the lifecycle of a given instance.
 If you want to define your own handling for one of the lifecycle events,
 simply add the LifecycleCallbacks trait to your object.
 Note that there is a separate LifecycleCallback trait in each of the record
 and mapper pacakges, so make sure that you import the correct one.
 For example, if we wanted to notify a comet actor whenever a new ledger
 entry is saved, we could change our Entry as shown in listing 
\begin_inset LatexCommand ref
reference "lst:Lifecycle-Callbacks"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Lifecycle callbacks
\begin_inset LatexCommand label
name "lst:Lifecycle-Callbacks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

object Entry extends Mapper[Entry] with LifecycleCallbacks {
\end_layout

\begin_layout Standard

  ...
\end_layout

\begin_layout Standard

  override def afterSave { myActor ! this }
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Base Field Types
\end_layout

\begin_layout Standard
The Record and Mapper frameworks define several basic field types.
 The following table shows the corresponding types between Mapper and Record,
 as well as a brief description
\end_layout

\begin_layout Description
MappedBinary,\InsetSpace ~
BinaryField Represents a byte array.
 You must provide your own overrides for toForm and asXHtml for input and
 display
\end_layout

\begin_layout Description
BooleanField Represents a Boolean value.
 The default form representation is a checkbox
\end_layout

\begin_layout Description
CountryField Represents a choice from an enumeration of country phone codes
 as provided by the net.liftweb.mapper.Countries.I18NCountry class.
 The default form representation is a select
\end_layout

\begin_layout Description
DateTimeField Represents a timestamp (java.util.Date).
 The default form representation is a text input
\end_layout

\begin_layout Description
DoubleField Represents a Double value
\end_layout

\begin_layout Description
EmailField Represents an email address
\end_layout

\begin_layout Description
EnumField Represents a choice from a given scala.Enumeration.
 The default form representation is a select
\end_layout

\begin_layout Description
IntField Represents an Int value
\end_layout

\begin_layout Description
LocaleField Represents a locale as selected from the java.util.Locale.getAvailableL
ocales method.
 The default form representation is a select
\end_layout

\begin_layout Description
LongField Represents a Long value
\end_layout

\begin_layout Description
PasswordField Represents a password string.
 The default form representation is a password input (obscured text)
\end_layout

\begin_layout Description
PostalCodeField Represents a validated postal code string.
 The field takes a reference to a CountryField at definition and validates
 the input string against the selected country's postal code format
\end_layout

\begin_layout Description
StringField Represents a string value with a maximum length and optional
 default value
\end_layout

\begin_layout Description
TextareaField Represents a text area (string) value.
 You can override the textareaRows and textareaCols methods to change the
 default size of the text area
\end_layout

\begin_layout Description
TimeZoneField Represents a time zone selected from java.util.TimeZone.getAvailableI
Ds.
 The default form representation is a select
\end_layout

\begin_layout Subsection
Defining Custom Field Types in Record
\begin_inset LatexCommand label
name "sub:Defining-Custom-Field-types"

\end_inset


\end_layout

\begin_layout Standard
The basic field types cover a wide range of needs, but sometimes you may
 find yourself wanting to cover a specific type.
 In our case, we would like a DecimalField to represent decimal currency
 amounts.
 Using a double would be inappropriate due to imprecision and rounding errors
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset LatexCommand htmlurl
target "http://stephan.reposita.org/archives/2008/01/11/once-and-for-all-do-not-use-double-for-money/"

\end_inset


\end_layout

\end_inset

, so instead we base it on BigDecimal.
 Our first task is to specify the class signature and constructors, as shown
 in listing 
\begin_inset LatexCommand ref
reference "lst:DecimalField-constructors"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
DecimalField constructors
\begin_inset LatexCommand label
name "lst:DecimalField-constructors"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

class DecimalField[OwnerType <: Record[OwnerType]]
\end_layout

\begin_layout Standard

    (rec : OwnerType, scale : Int)
\end_layout

\begin_layout Standard

    extends Field[BigDecimal,OwnerType] {
\end_layout

\begin_layout Standard

  def this(rec : OwnerType, newVal : BigDecimal) = {
\end_layout

\begin_layout Standard

    this(rec, newVal.scale)
\end_layout

\begin_layout Standard

    set(newVal)
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

  var rounding = RoundingMode.HALF_EVEN
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first part of the class definition is the type signature; basically
 the type 
\family typewriter
[OwnerType <: Record[OwnerType]]
\family default
 indicates that whatever type 
\begin_inset Quotes eld
\end_inset

owns
\begin_inset Quotes erd
\end_inset

 this field must be a Record subclass (<: specifies an upper type bound).
 With our constructor we specify the owner record as well as the 
\begin_inset Quotes eld
\end_inset

scale
\begin_inset Quotes erd
\end_inset

 of the decimal value.
 The scale in BigDecimal essentially represents the number of digits to
 the right of the decimal point.
 In addition, we specify a second constructor that allows us to initialize
 the field to a value.
 This second constructor uses the scale of the provided value as the default.
 At the end of the listing we provide a var to control the rounding mode
 of the field.
\end_layout

\begin_layout Standard
Now that we have the constructors in place, there are several abstract methods
 on Field that we need to define.
 The first of these is a method to provide a default value.
 The default value is used for uninitialized fields or if validation failes.
 We also need to specify the owner of this field via the owner method.
 Listing 
\begin_inset LatexCommand ref
reference "lst:Setting-a-default-value"

\end_inset

 shows both of these methods.
 In our case, we default to a zero value, with the scale set as specified
 in the contructor, and our owner def simply returns the rec value from
 our constructor.
 We also provide the methods that convert the field into a display NodeSeq
 and a form.
 Since we already have the setFromString method (covered later in this section)
 to take an input string and convert it to the proper value we simply pass
 this method into our text form element for the setter.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Setting a default value
\begin_inset LatexCommand label
name "lst:Setting-a-default-value"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

def owner = rec
\end_layout

\begin_layout Standard

def defaultValue = (new BigDecimal("0")).setScale(scale)
\end_layout

\begin_layout Standard

def asXHtml = Text(value.toString)
\end_layout

\begin_layout Standard

def toForm = SHtml.text(value.toString, this.setFromString)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next two methods that we need to provide deal with actually setting
 the value of the field.
 The first is 
\family typewriter
setFromAny
\family default
, which takes an 
\family typewriter
Any
\family default
 parameter and must convert it into a 
\family typewriter
Can[BigDecimal]
\family default
.
 The second, 
\family typewriter
setFromString
\family default
 is a subset of 
\family typewriter
setFromAny
\family default
 in that it takes a 
\family typewriter
String
\family default
 parameter and must return a 
\family typewriter
Can[BigDecimal]
\family default
.
 With either of these methods, if the conversion is unsuccesful, you need
 to return an 
\family typewriter
Empty
\family default
 as well as call the 
\family typewriter
couldNotSetValue
\family default
 method (from the Field trait) to set a flag on the field that other parts
 of the library use.
 Our implementation of these two methods is shown in listing 
\begin_inset LatexCommand ref
reference "lst:setFrom...-Methods"

\end_inset

.
 We've also added a setAll method so that we have a common place to properly
 set scale and rounding modes on the value of the field.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,numberstyle={\tiny},stepnumber=2"
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
setFrom...
 Methods
\begin_inset LatexCommand label
name "lst:setFrom...-Methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  def setFromAny (in : Any) : Can[BigDecimal] =
\end_layout

\begin_layout Standard

    in match {
\end_layout

\begin_layout Standard

      case n :: _ => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case Some(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case Full(n) => setFromString(n.toString)
\end_layout

\begin_layout Standard

      case None | Empty | Failure(_, _, _) | null => setFromString("0")
\end_layout

\begin_layout Standard

      case n => setFromString(n.toString)
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  def setFromString (in : String) : Can[BigDecimal] = {
\end_layout

\begin_layout Standard

    try {
\end_layout

\begin_layout Standard

      Full(this.setAll(new BigDecimal(in)))
\end_layout

\begin_layout Standard

    } catch {
\end_layout

\begin_layout Standard

      case e : Exception => couldNotSetValue; Empty
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

  }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  protected def setAll (in : BigDecimal) = set(in.setScale(scale, rounding))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our implementations are relatively straightforward.
 The only special handling we need for setFromAny is to properly deal with
 Lists, Cans, Options and the null value.
 The BigDecimal constructor takes Strings, so the setFromString method is
 easy.
 The only addition we make over the BigDecimal constructor is to properly
 set the scale and rounding on the returned value.
 To make the field a little more useful, we can also specify some convenience
 methods on it to make arithmetic a little more natural, as shown in listing
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Convenience methods
\begin_inset LatexCommand label
name "lst:Convenience-methods"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

  def += (other : BigDecimal) = setAll(value.add(other))
\end_layout

\begin_layout Standard

  def -= (other : BigDecimal) = setAll(value.subtract(other))
\end_layout

\begin_layout Standard

  def *= (other : BigDecimal) = setAll(value.multiply(other))
\end_layout

\begin_layout Standard

  def /= (other : BigDecimal) = setAll(value.divide(other))
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  // Use in practice:
\end_layout

\begin_layout Standard

  myEntry.amount *= BigDecimal.valueOf(2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You could expand on the convenience methods as you wish to cover Ints, Longs,
 Doubles, etc.
\end_layout

\begin_layout Section
Record Backends
\begin_inset LatexCommand label
name "sec:Record-Backends"

\end_inset


\end_layout

\begin_layout Subsection
JDBC Records
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This part of the library hasn't been finished yet
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
JPA Records
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This part of the library hasn't been finished yet
\end_layout

\end_inset


\end_layout

\end_body
\end_document
