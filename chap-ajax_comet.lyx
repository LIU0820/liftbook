#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
AJAX and COMET
\begin_inset CommandInset label
LatexCommand label
name "cha:AJAX-and-COMET"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we're going to discuss AJAX and COMET, two approaches to
 improving the user experience through dynamic web pages.
 While a full treatment of the techniques and technologies behind these
 approaches is beyond the scope of this book
\begin_inset Foot
status open

\begin_layout Plain Layout
There are a number of good resources on the web that you can find by searching
 for 
\begin_inset Quotes eld
\end_inset

AJAX
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

, we're going to cover the basics of how AJAX and COMET work.
 In particular, we're going to look at how Lift handles them behind the
 scenes to simplify your work.
\end_layout

\begin_layout Section
What are AJAX and COMET, really?
\end_layout

\begin_layout Standard
AJAX and Comet are variations on the traditional model of the web application
 request/response lifecycle.
 In the traditional model, the user starts by making a request for a page.
 The server receives this request, performs processing, then sends a response
 back to the user.
 The response is then rendered by the user's browser.
 At this point there are no further interactions between the user and the
 server until the user clicks on a link or performs some other action that
 starts a completely new request/response lifecycle.
 AJAX and COMET extend this model to allow for asynchronous updates from
 either the user to the server (AJAX), or from the server back to the user
 (COMET).
\end_layout

\begin_layout Standard
If we take the example of adding a comment to a blog post, the traditional
 model has the user fill in a form, hit the submit button, and send the
 request to the server.
 The server processes and adds the comment and then sends the updated blog
 post back to the user with the newly added comment.
 At the same time, if other people are viewing the blog post, they won't
 see the new comment until they reload the page.
\end_layout

\begin_layout Standard
The AJAX model of this session changes such that the display of the new
 comment is not tied to the response from the server.
 When the user hits submit, the request to add the comment is sent to the
 server 
\emph on
in the background
\emph default
.
 While it's being processed by the server, a JavaScript fragment (the 
\begin_inset Quotes eld
\end_inset

J
\begin_inset Quotes erd
\end_inset

 in AJAX) updates the user's page via DOM
\begin_inset Foot
status open

\begin_layout Plain Layout
Document Object Model.
 More information can be found at 
\begin_inset CommandInset href
LatexCommand href
target "http://www.w3.org/DOM/"

\end_inset


\end_layout

\end_inset

 and adds the comment without the need for a full page reload.
 
\end_layout

\begin_layout Standard
COMET changes the traditional model by using a long-polling HTTP request
 in the background that allows the server to push data to the browser without
 requiring additional requests.
 Essentially this is like AJAX, except in the opposite direction.
 While the AJAX model increases the richness of the User Experience for
 a single client at a time, Comet can do the same for multiple users.
 Going back to our example of a blog post, COMET would enable the server
 to notify anyone viewing the current blog post to automatically have their
 pages updated when the new comment is added.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:model-comparisons"

\end_inset

 shows a graphical representation of how the modesl differ in terms of timeline
 and server interaction.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Traditional Application Model
\begin_inset CommandInset label
LatexCommand label
name "subfig:Traditional-Application-Model"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Traditional Model.pdf
	width 3in

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AJAX Application Model
\begin_inset CommandInset label
LatexCommand label
name "subfig:AJAX-Application-Model"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Ajax Model.pdf
	width 3in

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
COMET Application Model
\begin_inset CommandInset label
LatexCommand label
name "subfig:COMET-Application-Model"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/COMET Model.pdf
	width 3in

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:model-comparisons"

\end_inset

Application Model Comparisons
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
AJAX in Lift
\end_layout

\begin_layout Standard
In previous chapters we've shown how to use AJAX in Lift through SHtml functions
 or AJAX forms(TK REF).
 Lift's AJAX support sits on top of the JavaScript framework used by Lift
 and exploits these frameworks for reliable JavaScript support.
 On top of that Lift comes with its own JavaScript that actually uses the
 underlying JS framework to submit Ajax resquests and process the responses.
 It adds functionality such as failsafe, retry mechanisms, graceful degradation
 etc.
 [TK This is confusing]
\end_layout

\begin_layout Standard
Looking at the source page generated by Lift we are seeing:
\end_layout

\begin_layout Standard

\family typewriter
<script type="text/javascript" src="/ajax_request/liftAjax.js/>
\end_layout

\begin_layout Standard
This will actually load the JavaScript code used by Lift to properly manage
 Ajax requests and responses.
\end_layout

\begin_layout Standard
The diagram above explains both classic and Ajax enabled web applications.
 It worth tomention that Lift distingushes Ajax request by regular request
 based on the URI path give by 
\family typewriter
LuftRules.ajaxPath
\family default
 variable which by default is set to 
\begin_inset Quotes eld
\end_inset

ajax_request
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In terms of Lift API it is also possible to submit AJax request on more
 special cases not only when clicking a button, link etc.
 You can use 
\family typewriter
SHtml.ajaxCall 
\family default
to simply submit an AjaxRequest.
 You are passing tothis function the actual data that needs to be submitted
 as a JsExp and the Scala function that will be called when this Ajax request
 will be submitted.
 This callback function has the form 
\family typewriter
(String => JsCmd) 
\family default
so you need to return a JsCmd that will be sent to client.
\end_layout

\begin_layout Standard
Using Ajax in Lift is really a trivial thing to do as Lift provides the
 necessary wiring, abstractions etc.
 to do this even with a single line of code.
\end_layout

\begin_layout Section
COMET in Lift
\end_layout

\begin_layout Standard
The diagam above describes that Comet model.
 You can also find relevant information about Comet here: http://en.wikipedia.org/
wiki/Comet_(programming).
 In essence Comet is not a technology but a technique which allows a web
 application to push messages from server to client.
 Think about a web chat application when you are chatting with your friend
 and you just see his/hers messages.
 Let's see how it works (in a glance):
\end_layout

\begin_layout Enumerate
Client sends an Ajax request to server
\end_layout

\begin_layout Enumerate
Server does not response imediately but waits until there is a message that
 needs to be sent for that client.
 
\end_layout

\begin_layout Enumerate
When a message is available server actually responds to the initial request
 from client.
\end_layout

\begin_layout Enumerate
Client receives the response, process it and issues another Ajax request
 and the process continues.
\end_layout

\begin_layout Standard
Of course things are more complicated then that.
 For instance when the client is sending the request to the server it may
 take a while until the response is actually provided back.
 Well in this period of time the connection can be simply dropped by whatever
 reasons and the client should be smart enough to re-establish the connection
 automatically.
 But there is another problem: scallability.
 If we have these long term connections the server would typically put the
 processing threads into a waiting state until messages are available to
 actually respond to client.
 This is of course a scallability killer because the threads from the web
 container's thread pool will mostly in wait state doing nothing but 
\begin_inset Quotes eld
\end_inset

wait
\begin_inset Quotes erd
\end_inset

 for messages and before you know your entire thread pool will be empty.
 The imediate consequence is that your server can not do any other request
 processing.
 So such approach is totally unnacceptable.
 The key to scallability is NON-BLOCKING IO.
 Most operating systems support non-blocking IO which it actaully means
 that when your read/write from/to an IO source (say the streams from a
 socket) there is no blocking operation.
 So if you read from a stream your read function would imediately return
 regardess if there is data available or not.
 In Java non-blocking IO can be used by the means of NIO library using Selectors
 and perhaps the Reactor pattern (...
 an interesting paper http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf).
 This has major impact on scallability because the threads are returned
 to the thread pool very fast being able to be re-used for processing other
 requests.
 IN this model th threads are allocated to connections only when data is
 available for processing this inherently leading the a better threads managemen
t system.
\end_layout

\begin_layout Standard
So having non-blocking IO enabled by the web container has a major impact
 into application scallability if we are talking about long live connections
 from client to server.
 But his is not all there is to it.
 Lift framework has support for Jetty Continuations.
 Jetty is a very nice J(2)EE web container (http://www.mortbay.org/jetty/).
 It has a so called Jetty Continuation mecahnism which in fact it not about
 pure web continuations mechanism.
 It based on the suspent-resume mechanism (which BTW will be introduced
 in th Servlet 3.0 specifications).
 In a glance how it works is:
\end_layout

\begin_layout Enumerate
You application receives a reuest and wants to hold of the response as there
 is no message yet.
\end_layout

\begin_layout Enumerate
You call 
\family typewriter
suspend
\family default
 on the Jetty continuation object.
 Here Jetty will throw a special exception that will be caught in the container.
 Current thread is immediately retrned to the thread pool being able to
 process other requests.
\end_layout

\begin_layout Enumerate
Assume that after a while you have a message for that particular client.
 You call 
\family typewriter
resume
\family default
 on the same continuation object.
 Here Jetty will actually replay the initial HTTP request and your servlet
 behaves like that request was just recived from client and of course returns
 the appropriate response.
\end_layout

\begin_layout Standard
You can read more details about Jetty Continuations here: http://docs.codehaus.org
/display/JETTY/Continuations.
 
\end_layout

\begin_layout Standard
If you run your ift application on Jetty container Lift will automatically
 detect that and exploits the Jetty's Continuation mechanism.
 On other container (with only blocking IO) COmet in Lift will still work
 but it won't scale that good due to container's limitations.
 
\end_layout

\begin_layout Standard
It is important to know that Comet support in Lift is also done by the means
 of Scala Actors.
 We won't get into much details regarding Scala Actors as you can find detailed
 information such as: http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf.
 Scala Actors are build somehow similar with Erlang Actors system where
 an Actor is an asynchronous component that receives messages and sends/replies
 messages.
 It simply reacts to incomming mesages.
 Actors are build on the messaging paradigm and not by 
\begin_inset Quotes eld
\end_inset

shared state
\begin_inset Quotes erd
\end_inset

 one.
 It is important to note that Actors by their very definition are thread
 safe components making them ideal for high scallable parallelization and
 a very fitfull model for multi-core/multi-proc systems.
\end_layout

\begin_layout Subsection
Comet in Lift
\end_layout

\begin_layout Standard
As we have seen the Comet support in Lift is provide by Scala Actors.
 In fact there is a CometActor trait that does almost all the work.
 If you want to use Comet technique in Lift you have to make your own CometActor
 by extending the CometActor trait.
 Note that your CometActor classes needs to exist in the Scala package described
 by the pacakge that you provided in Boot by calling 
\family typewriter
LiftRules.addToPackages(...)
\family default
.
 For example if in Boot you are calling 
\family typewriter
LiftRules.addToPackages(
\begin_inset Quotes eld
\end_inset

com.myapp
\begin_inset Quotes erd
\end_inset

)
\family default
, you comet actors must exists in the package 
\family typewriter
com.myapp.comet
\family default
 just as snippets needs to exists in the 
\family typewriter
com.myapp.snippet
\family default
 package.
 But let's take a look on a simple example.
 Let's say that we want to build a Clock examples where server sends down
 to client every 10 seconds the time from the server.
 
\end_layout

\begin_layout Enumerate
First let's see how the marjup would look like:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Comet Clock markup example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<lift:surround with="default" at="content">
\end_layout

\begin_layout Plain Layout

    <lift:comet type="Clock" name="Other">
\end_layout

\begin_layout Plain Layout

		Current Time: <clk:time>Missing Clock</clk:time>
\end_layout

\begin_layout Plain Layout

	</lift:comet>  
\end_layout

\begin_layout Plain Layout

</lift:surround>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The Comet Actor
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Clock Comet Actor example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

class Clock extends CometActor {
\end_layout

\begin_layout Plain Layout

  override def defaultPrefix = Full("clk")   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def render = bind("time" -> timeSpan)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def timeSpan = (<span id=
\begin_inset Quotes erd
\end_inset

time
\begin_inset Quotes erd
\end_inset

>{timeNow}</span>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ActorPing.schedule(this, Tick, 10000L) // schedule a ping every 10 seconds
 so we redraw
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  override def lowPriority : PartialFunction[Any, Unit] = {
\end_layout

\begin_layout Plain Layout

    case Tick => {
\end_layout

\begin_layout Plain Layout

      println("Got tick " + new Date());
\end_layout

\begin_layout Plain Layout

      partialUpdate(SetHtml("time", Text(timeNow.toString))) 
\end_layout

\begin_layout Plain Layout

      ActorPing.schedule(this, Tick, 10000L) // schedule an update in 10
 seconds
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

case object Tick
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
First of all in our markup definition use used 
\family typewriter
<lift:comet>
\family default
 tag.
 This tag makes the bound between the actual CometActor and the page real-estate
 that is designated for this actor to render XHTML content.
 In other words the zone in the page where the asynchronous content comming
 from server will be rendered.
 The body of the 
\family typewriter
<lift:comet>
\family default
 tag is quite similar with the body of a snippet.
 
\family typewriter
<clk:time>
\family default
 tag will be bound in the Clock actor.
 The 
\family typewriter
type=
\begin_inset Quotes erd
\end_inset

Clock
\begin_inset Quotes erd
\end_inset


\family default
 attribute is telling Lift which CometAcvtor to call and the 
\family typewriter
name=
\begin_inset Quotes erd
\end_inset

Other
\begin_inset Quotes erd
\end_inset


\family default
 is the name of this CometActor.
 Thename is a discriminator as you may have more then one CometActor-s of
 the same type.
\end_layout

\begin_layout Standard
Now let's takea look at ou Clock actor.
 First, it defines the default prefix.
 This is the prefix that should be used for all nodes that will be bound
 inside 
\family typewriter
<lift:comet>
\family default
 tag.
 As you've noticed 
\family typewriter
<clk:time>
\family default
 tag which has the correct prefix 
\begin_inset Quotes eld
\end_inset

clk
\begin_inset Quotes erd
\end_inset

.
 Then we have the render function where we do the binding between the 
\family typewriter
<clk:time>
\family default
 node and the result of the 
\family typewriter
timespan
\family default
 function.
 Basically the 
\family typewriter
<clk:time> 
\family default
node will be replaced by the 
\family typewriter
span
\family default
 element returnedby the 
\family typewriter
timespan
\family default
 function.
 It is important to note that Comet content rendered by 
\family typewriter
<lift:comet>
\family default
 tag is allways a 
\family typewriter
<span>
\family default
 element as you can see by looking at the page source in your browser.
 This can of course be changed by overriding the 
\family typewriter
parentTag
\family default
 function in your comet actor.
 
\family typewriter
timeNow
\family default
 is a function from TimeHelpers trait that just returns the current system
 time.
 We use here ActorPing to send a Tick mesage after 10 seconds.
 This will be called when Clock class is instantiated.
 And finally we have the lowPriority function that returns a PartialFunction.
 To process messages in your CometActor you have the following functions:
 
\family typewriter
highPriority
\family default
, 
\family typewriter
mediumPriority
\family default
 and 
\family typewriter
lowPriority
\family default
 that you can override to process your application specific messages.
 This is just the way of prioritizing application messages.
 Of course 
\family typewriter
hightPriority
\family default
 will called before 
\family typewriter
mediumPriority
\family default
 which will be called before the 
\family typewriter
lowPriority
\family default
.
 The only thing that we do here is to pattern match the messages.
 In this simple example we have only the Tick object.
 So when Tick is send by the ActorPing our code gets executed andthe following
 actions are happening:
\end_layout

\begin_layout Enumerate
We print at the console the current time (just for fun)
\end_layout

\begin_layout Enumerate
And we call partialUpdate function.
 With partial update we can update specific fragments on client side and
 not actually re-render the entire content that the CometActor may produce.
 So this is an optimization that we send down to client something very specific
 to be updated.
 If instead of the partialUpdate call we would be calling 
\family typewriter
reRender(true);
\family default
 the entire real estate on the client side will be re-rendered.
 So getting back to our partialUpdate call we are basically saying that
 we want to set the XHTML content for the element that has the id 
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

.
 Which is the 
\family typewriter
span
\family default
 element returned by 
\family typewriter
timeSpan
\family default
 function.
 
\end_layout

\begin_layout Enumerate
We tell the ActorPing to send another Tick message after 10 seconds.
\end_layout

\begin_layout Standard
As you have seen with a very few lines of code we were able to create a
 Clock application where server is telling the client every 10 seconds what
 is the time on server side.
 Of course this is just a trivial example but now you have a clear picture
 howCometActor-s work so you can build really complex cases for you compelling
 Lift application.
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
As described earlier It is also possible to use notices (notice/warning/error)
 from your comet actor.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
